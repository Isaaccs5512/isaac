// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app.terminal.proto

#ifndef PROTOBUF_app_2eterminal_2eproto__INCLUDED
#define PROTOBUF_app_2eterminal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace app {
namespace terminal {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_app_2eterminal_2eproto();
void protobuf_AssignDesc_app_2eterminal_2eproto();
void protobuf_ShutdownFile_app_2eterminal_2eproto();

class LoginRequest;
class LoginResponse;
class RegisterStatusNotification;
class Group;
class GroupsResponse;
class Participant;
class GroupParticipantsRequest;
class GroupParticipantsResponse;
class MediaMessageRequest;
class MediaMessage;
class MediaMessageResponse;
class JoinedGroupNotification;
class LeaveGroupNotification;
class OthersJoinedGroupNotification;
class OthersLeaveGroupNotification;
class MediaMessageNotification;
class JoinGroupRequest;
class ConnectGroupRequest;
class SessionStatusNotification;
class SpeakRequest;
class JoinSessionRequest;
class LeaveSessionRequest;
class ReleaseTokenRequest;
class AppointSpeakRequest;
class SendMessageRequest;
class SubscribeLocationRequest;
class SubscribeLocationResponse;
class LocationNotification;
class Alert;
class AlertsResponse;
class AlertRequest;
class AlertResponse;
class AlertCreateNotification;
class AlertModifyNotification;
class AlertOveredNotification;
class HistoryAlertsRequest;
class HistoryAlert;
class HistoryAlertsResponse;
class HistoryAlertRequest;
class HistoryAlertResponse;
class HistoryAlertMesageRequest;
class HistoryAlertMesageResponse;
class Request;
class Response;
class Indication;
class Message;

enum MSG {
  Login_Request = 300001,
  Login_Response = 300002,
  Logout_Request = 300003,
  Logout_Response = 300004,
  Keepalive_Request = 300005,
  Keepalive_Response = 300006,
  Groups_Request = 300007,
  Groups_Response = 300008,
  Group_Participants_Request = 300009,
  Group_Participants_Response = 300010,
  Media_Message_Request = 300011,
  Media_Message_Response = 300012,
  Join_Group_Request = 300013,
  Join_Group_Response = 300014,
  Connect_Group_Request = 300015,
  Connect_Group_Response = 300016,
  Speak_Request = 300017,
  Speak_Response = 300018,
  Join_Session_Request = 300019,
  Join_Session_Response = 300020,
  Leave_Session_Request = 300021,
  Leave_Session_Response = 300022,
  Release_Token_Request = 300023,
  Release_Token_Response = 300024,
  Appoint_Speak_Request = 300025,
  Appoint_Speak_Response = 300026,
  Send_Message_Request = 300027,
  Send_Message_Response = 300028,
  Subscribe_Location_Request = 300029,
  Subscribe_Location_Response = 300030,
  Alerts_Request = 300031,
  Alerts_Response = 300032,
  Alert_Request = 300033,
  Alert_Response = 300034,
  History_Alerts_Request = 300035,
  History_Alerts_Response = 300036,
  History_Alert_Request = 300037,
  History_Alert_Response = 300038,
  History_Alert_Mesage_Request = 300039,
  History_Alert_Mesage_Response = 300040,
  Register_Status_Notification = 310001,
  Joined_Group_Notification = 310002,
  Leave_Group_Notification = 310003,
  Others_Joined_Group_Notification = 310004,
  Others_Leave_Group_Notification = 310005,
  Media_Message_Notification = 310006,
  Session_Status_Notification = 310007,
  Location_Notification = 310008,
  Alert_Create_Notification = 310009,
  Alert_Modify_Notification = 310010,
  Alert_Overed_Notification = 310011
};
bool MSG_IsValid(int value);
const MSG MSG_MIN = Login_Request;
const MSG MSG_MAX = Alert_Overed_Notification;
const int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_descriptor();
inline const ::std::string& MSG_Name(MSG value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_descriptor(), value);
}
inline bool MSG_Parse(
    const ::std::string& name, MSG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
enum CallPrivilege {
  CallForbid = 0,
  CallFreedom = 1,
  CallPolicy = 2
};
bool CallPrivilege_IsValid(int value);
const CallPrivilege CallPrivilege_MIN = CallForbid;
const CallPrivilege CallPrivilege_MAX = CallPolicy;
const int CallPrivilege_ARRAYSIZE = CallPrivilege_MAX + 1;

const ::google::protobuf::EnumDescriptor* CallPrivilege_descriptor();
inline const ::std::string& CallPrivilege_Name(CallPrivilege value) {
  return ::google::protobuf::internal::NameOfEnum(
    CallPrivilege_descriptor(), value);
}
inline bool CallPrivilege_Parse(
    const ::std::string& name, CallPrivilege* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CallPrivilege>(
    CallPrivilege_descriptor(), name, value);
}
enum TokenPrivilege {
  TokenForbid = 0,
  TokenFreedom = 1,
  TokenPolicy = 2
};
bool TokenPrivilege_IsValid(int value);
const TokenPrivilege TokenPrivilege_MIN = TokenForbid;
const TokenPrivilege TokenPrivilege_MAX = TokenPolicy;
const int TokenPrivilege_ARRAYSIZE = TokenPrivilege_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenPrivilege_descriptor();
inline const ::std::string& TokenPrivilege_Name(TokenPrivilege value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenPrivilege_descriptor(), value);
}
inline bool TokenPrivilege_Parse(
    const ::std::string& name, TokenPrivilege* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenPrivilege>(
    TokenPrivilege_descriptor(), name, value);
}
enum GpsReportMode {
  GpsManualPull = 0,
  GpsManualPush = 1,
  GpsAutoPush = 2
};
bool GpsReportMode_IsValid(int value);
const GpsReportMode GpsReportMode_MIN = GpsManualPull;
const GpsReportMode GpsReportMode_MAX = GpsAutoPush;
const int GpsReportMode_ARRAYSIZE = GpsReportMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpsReportMode_descriptor();
inline const ::std::string& GpsReportMode_Name(GpsReportMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpsReportMode_descriptor(), value);
}
inline bool GpsReportMode_Parse(
    const ::std::string& name, GpsReportMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpsReportMode>(
    GpsReportMode_descriptor(), name, value);
}
enum RegisterStatus {
  OffLine = 0,
  OnLine = 1
};
bool RegisterStatus_IsValid(int value);
const RegisterStatus RegisterStatus_MIN = OffLine;
const RegisterStatus RegisterStatus_MAX = OnLine;
const int RegisterStatus_ARRAYSIZE = RegisterStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterStatus_descriptor();
inline const ::std::string& RegisterStatus_Name(RegisterStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterStatus_descriptor(), value);
}
inline bool RegisterStatus_Parse(
    const ::std::string& name, RegisterStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterStatus>(
    RegisterStatus_descriptor(), name, value);
}
enum SessionStatus {
  IDLE = 0,
  InGroup = 1,
  Talking = 2
};
bool SessionStatus_IsValid(int value);
const SessionStatus SessionStatus_MIN = IDLE;
const SessionStatus SessionStatus_MAX = Talking;
const int SessionStatus_ARRAYSIZE = SessionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionStatus_descriptor();
inline const ::std::string& SessionStatus_Name(SessionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionStatus_descriptor(), value);
}
inline bool SessionStatus_Parse(
    const ::std::string& name, SessionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionStatus>(
    SessionStatus_descriptor(), name, value);
}
enum AlertLevel {
  Exigency = 0,
  Importance = 1,
  Subordination = 2,
  Ordinary = 3
};
bool AlertLevel_IsValid(int value);
const AlertLevel AlertLevel_MIN = Exigency;
const AlertLevel AlertLevel_MAX = Ordinary;
const int AlertLevel_ARRAYSIZE = AlertLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlertLevel_descriptor();
inline const ::std::string& AlertLevel_Name(AlertLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlertLevel_descriptor(), value);
}
inline bool AlertLevel_Parse(
    const ::std::string& name, AlertLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlertLevel>(
    AlertLevel_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:app.terminal.LoginRequest)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* number_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sip_uri = 1;
  inline bool has_sip_uri() const;
  inline void clear_sip_uri();
  static const int kSipUriFieldNumber = 1;
  inline const ::std::string& sip_uri() const;
  inline void set_sip_uri(const ::std::string& value);
  inline void set_sip_uri(const char* value);
  inline void set_sip_uri(const char* value, size_t size);
  inline ::std::string* mutable_sip_uri();
  inline ::std::string* release_sip_uri();
  inline void set_allocated_sip_uri(::std::string* sip_uri);

  // required fixed32 your_id = 2;
  inline bool has_your_id() const;
  inline void clear_your_id();
  static const int kYourIdFieldNumber = 2;
  inline ::google::protobuf::uint32 your_id() const;
  inline void set_your_id(::google::protobuf::uint32 value);

  // optional bytes display_name = 3;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const void* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // required fixed32 talk_priority = 4;
  inline bool has_talk_priority() const;
  inline void clear_talk_priority();
  static const int kTalkPriorityFieldNumber = 4;
  inline ::google::protobuf::uint32 talk_priority() const;
  inline void set_talk_priority(::google::protobuf::uint32 value);

  // required .app.terminal.CallPrivilege call_privilege = 5;
  inline bool has_call_privilege() const;
  inline void clear_call_privilege();
  static const int kCallPrivilegeFieldNumber = 5;
  inline ::app::terminal::CallPrivilege call_privilege() const;
  inline void set_call_privilege(::app::terminal::CallPrivilege value);

  // required .app.terminal.TokenPrivilege token_privilege = 6;
  inline bool has_token_privilege() const;
  inline void clear_token_privilege();
  static const int kTokenPrivilegeFieldNumber = 6;
  inline ::app::terminal::TokenPrivilege token_privilege() const;
  inline void set_token_privilege(::app::terminal::TokenPrivilege value);

  // required string number = 7;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 7;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // required fixed32 ttl = 8;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 8;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // required .app.terminal.GpsReportMode gps_report_mode = 9;
  inline bool has_gps_report_mode() const;
  inline void clear_gps_report_mode();
  static const int kGpsReportModeFieldNumber = 9;
  inline ::app::terminal::GpsReportMode gps_report_mode() const;
  inline void set_gps_report_mode(::app::terminal::GpsReportMode value);

  // required string upload_address = 10;
  inline bool has_upload_address() const;
  inline void clear_upload_address();
  static const int kUploadAddressFieldNumber = 10;
  inline const ::std::string& upload_address() const;
  inline void set_upload_address(const ::std::string& value);
  inline void set_upload_address(const char* value);
  inline void set_upload_address(const char* value, size_t size);
  inline ::std::string* mutable_upload_address();
  inline ::std::string* release_upload_address();
  inline void set_allocated_upload_address(::std::string* upload_address);

  // @@protoc_insertion_point(class_scope:app.terminal.LoginResponse)
 private:
  inline void set_has_sip_uri();
  inline void clear_has_sip_uri();
  inline void set_has_your_id();
  inline void clear_has_your_id();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_talk_priority();
  inline void clear_has_talk_priority();
  inline void set_has_call_privilege();
  inline void clear_has_call_privilege();
  inline void set_has_token_privilege();
  inline void clear_has_token_privilege();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_gps_report_mode();
  inline void clear_has_gps_report_mode();
  inline void set_has_upload_address();
  inline void clear_has_upload_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sip_uri_;
  ::std::string* display_name_;
  ::google::protobuf::uint32 your_id_;
  ::google::protobuf::uint32 talk_priority_;
  int call_privilege_;
  int token_privilege_;
  ::std::string* number_;
  ::google::protobuf::uint32 ttl_;
  int gps_report_mode_;
  ::std::string* upload_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterStatusNotification : public ::google::protobuf::Message {
 public:
  RegisterStatusNotification();
  virtual ~RegisterStatusNotification();

  RegisterStatusNotification(const RegisterStatusNotification& from);

  inline RegisterStatusNotification& operator=(const RegisterStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterStatusNotification& default_instance();

  void Swap(RegisterStatusNotification* other);

  // implements Message ----------------------------------------------

  RegisterStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterStatusNotification& from);
  void MergeFrom(const RegisterStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.terminal.RegisterStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::app::terminal::RegisterStatus status() const;
  inline void set_status(::app::terminal::RegisterStatus value);

  // @@protoc_insertion_point(class_scope:app.terminal.RegisterStatusNotification)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static RegisterStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // @@protoc_insertion_point(class_scope:app.terminal.Group)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* number_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class GroupsResponse : public ::google::protobuf::Message {
 public:
  GroupsResponse();
  virtual ~GroupsResponse();

  GroupsResponse(const GroupsResponse& from);

  inline GroupsResponse& operator=(const GroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupsResponse& default_instance();

  void Swap(GroupsResponse* other);

  // implements Message ----------------------------------------------

  GroupsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupsResponse& from);
  void MergeFrom(const GroupsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .app.terminal.Group joined_groups = 1;
  inline int joined_groups_size() const;
  inline void clear_joined_groups();
  static const int kJoinedGroupsFieldNumber = 1;
  inline const ::app::terminal::Group& joined_groups(int index) const;
  inline ::app::terminal::Group* mutable_joined_groups(int index);
  inline ::app::terminal::Group* add_joined_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >&
      joined_groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >*
      mutable_joined_groups();

  // repeated .app.terminal.Group unjoin_groups = 2;
  inline int unjoin_groups_size() const;
  inline void clear_unjoin_groups();
  static const int kUnjoinGroupsFieldNumber = 2;
  inline const ::app::terminal::Group& unjoin_groups(int index) const;
  inline ::app::terminal::Group* mutable_unjoin_groups(int index);
  inline ::app::terminal::Group* add_unjoin_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >&
      unjoin_groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >*
      mutable_unjoin_groups();

  // @@protoc_insertion_point(class_scope:app.terminal.GroupsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::Group > joined_groups_;
  ::google::protobuf::RepeatedPtrField< ::app::terminal::Group > unjoin_groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static GroupsResponse* default_instance_;
};
// -------------------------------------------------------------------

class Participant : public ::google::protobuf::Message {
 public:
  Participant();
  virtual ~Participant();

  Participant(const Participant& from);

  inline Participant& operator=(const Participant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Participant& default_instance();

  void Swap(Participant* other);

  // implements Message ----------------------------------------------

  Participant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Participant& from);
  void MergeFrom(const Participant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required bytes account_name = 2;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 2;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const void* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // required fixed32 talk_priority = 3;
  inline bool has_talk_priority() const;
  inline void clear_talk_priority();
  static const int kTalkPriorityFieldNumber = 3;
  inline ::google::protobuf::uint32 talk_priority() const;
  inline void set_talk_priority(::google::protobuf::uint32 value);

  // optional .app.terminal.CallPrivilege call_privilege = 4;
  inline bool has_call_privilege() const;
  inline void clear_call_privilege();
  static const int kCallPrivilegeFieldNumber = 4;
  inline ::app::terminal::CallPrivilege call_privilege() const;
  inline void set_call_privilege(::app::terminal::CallPrivilege value);

  // optional .app.terminal.TokenPrivilege token_privilege = 5;
  inline bool has_token_privilege() const;
  inline void clear_token_privilege();
  static const int kTokenPrivilegeFieldNumber = 5;
  inline ::app::terminal::TokenPrivilege token_privilege() const;
  inline void set_token_privilege(::app::terminal::TokenPrivilege value);

  // required .app.terminal.SessionStatus status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::app::terminal::SessionStatus status() const;
  inline void set_status(::app::terminal::SessionStatus value);

  // @@protoc_insertion_point(class_scope:app.terminal.Participant)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_talk_priority();
  inline void clear_has_talk_priority();
  inline void set_has_call_privilege();
  inline void clear_has_call_privilege();
  inline void set_has_token_privilege();
  inline void clear_has_token_privilege();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_name_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 talk_priority_;
  int call_privilege_;
  int token_privilege_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Participant* default_instance_;
};
// -------------------------------------------------------------------

class GroupParticipantsRequest : public ::google::protobuf::Message {
 public:
  GroupParticipantsRequest();
  virtual ~GroupParticipantsRequest();

  GroupParticipantsRequest(const GroupParticipantsRequest& from);

  inline GroupParticipantsRequest& operator=(const GroupParticipantsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupParticipantsRequest& default_instance();

  void Swap(GroupParticipantsRequest* other);

  // implements Message ----------------------------------------------

  GroupParticipantsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupParticipantsRequest& from);
  void MergeFrom(const GroupParticipantsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.GroupParticipantsRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static GroupParticipantsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GroupParticipantsResponse : public ::google::protobuf::Message {
 public:
  GroupParticipantsResponse();
  virtual ~GroupParticipantsResponse();

  GroupParticipantsResponse(const GroupParticipantsResponse& from);

  inline GroupParticipantsResponse& operator=(const GroupParticipantsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupParticipantsResponse& default_instance();

  void Swap(GroupParticipantsResponse* other);

  // implements Message ----------------------------------------------

  GroupParticipantsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupParticipantsResponse& from);
  void MergeFrom(const GroupParticipantsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated .app.terminal.Participant participants = 2;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 2;
  inline const ::app::terminal::Participant& participants(int index) const;
  inline ::app::terminal::Participant* mutable_participants(int index);
  inline ::app::terminal::Participant* add_participants();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >&
      participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >*
      mutable_participants();

  // @@protoc_insertion_point(class_scope:app.terminal.GroupParticipantsResponse)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant > participants_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static GroupParticipantsResponse* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageRequest : public ::google::protobuf::Message {
 public:
  MediaMessageRequest();
  virtual ~MediaMessageRequest();

  MediaMessageRequest(const MediaMessageRequest& from);

  inline MediaMessageRequest& operator=(const MediaMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageRequest& default_instance();

  void Swap(MediaMessageRequest* other);

  // implements Message ----------------------------------------------

  MediaMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageRequest& from);
  void MergeFrom(const MediaMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string from_timestamp = 2;
  inline bool has_from_timestamp() const;
  inline void clear_from_timestamp();
  static const int kFromTimestampFieldNumber = 2;
  inline const ::std::string& from_timestamp() const;
  inline void set_from_timestamp(const ::std::string& value);
  inline void set_from_timestamp(const char* value);
  inline void set_from_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_from_timestamp();
  inline ::std::string* release_from_timestamp();
  inline void set_allocated_from_timestamp(::std::string* from_timestamp);

  // optional fixed32 from_message_id = 3;
  inline bool has_from_message_id() const;
  inline void clear_from_message_id();
  static const int kFromMessageIdFieldNumber = 3;
  inline ::google::protobuf::uint32 from_message_id() const;
  inline void set_from_message_id(::google::protobuf::uint32 value);

  // required fixed32 max_message_count = 4;
  inline bool has_max_message_count() const;
  inline void clear_max_message_count();
  static const int kMaxMessageCountFieldNumber = 4;
  inline ::google::protobuf::uint32 max_message_count() const;
  inline void set_max_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.MediaMessageRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_from_timestamp();
  inline void clear_has_from_timestamp();
  inline void set_has_from_message_id();
  inline void clear_has_from_message_id();
  inline void set_has_max_message_count();
  inline void clear_has_max_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_timestamp_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 from_message_id_;
  ::google::protobuf::uint32 max_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessage : public ::google::protobuf::Message {
 public:
  MediaMessage();
  virtual ~MediaMessage();

  MediaMessage(const MediaMessage& from);

  inline MediaMessage& operator=(const MediaMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessage& default_instance();

  void Swap(MediaMessage* other);

  // implements Message ----------------------------------------------

  MediaMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessage& from);
  void MergeFrom(const MediaMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required bytes sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const void* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional bytes text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string picture_uri = 4;
  inline bool has_picture_uri() const;
  inline void clear_picture_uri();
  static const int kPictureUriFieldNumber = 4;
  inline const ::std::string& picture_uri() const;
  inline void set_picture_uri(const ::std::string& value);
  inline void set_picture_uri(const char* value);
  inline void set_picture_uri(const char* value, size_t size);
  inline ::std::string* mutable_picture_uri();
  inline ::std::string* release_picture_uri();
  inline void set_allocated_picture_uri(::std::string* picture_uri);

  // optional string audio_uri = 5;
  inline bool has_audio_uri() const;
  inline void clear_audio_uri();
  static const int kAudioUriFieldNumber = 5;
  inline const ::std::string& audio_uri() const;
  inline void set_audio_uri(const ::std::string& value);
  inline void set_audio_uri(const char* value);
  inline void set_audio_uri(const char* value, size_t size);
  inline ::std::string* mutable_audio_uri();
  inline ::std::string* release_audio_uri();
  inline void set_allocated_audio_uri(::std::string* audio_uri);

  // optional fixed32 audio_length = 6;
  inline bool has_audio_length() const;
  inline void clear_audio_length();
  static const int kAudioLengthFieldNumber = 6;
  inline ::google::protobuf::uint32 audio_length() const;
  inline void set_audio_length(::google::protobuf::uint32 value);

  // optional string video_uri = 7;
  inline bool has_video_uri() const;
  inline void clear_video_uri();
  static const int kVideoUriFieldNumber = 7;
  inline const ::std::string& video_uri() const;
  inline void set_video_uri(const ::std::string& value);
  inline void set_video_uri(const char* value);
  inline void set_video_uri(const char* value, size_t size);
  inline ::std::string* mutable_video_uri();
  inline ::std::string* release_video_uri();
  inline void set_allocated_video_uri(::std::string* video_uri);

  // optional fixed32 video_length = 8;
  inline bool has_video_length() const;
  inline void clear_video_length();
  static const int kVideoLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 video_length() const;
  inline void set_video_length(::google::protobuf::uint32 value);

  // optional string timestamp = 9;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:app.terminal.MediaMessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_picture_uri();
  inline void clear_has_picture_uri();
  inline void set_has_audio_uri();
  inline void clear_has_audio_uri();
  inline void set_has_audio_length();
  inline void clear_has_audio_length();
  inline void set_has_video_uri();
  inline void clear_has_video_uri();
  inline void set_has_video_length();
  inline void clear_has_video_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* text_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 audio_length_;
  ::std::string* picture_uri_;
  ::std::string* audio_uri_;
  ::std::string* video_uri_;
  ::std::string* timestamp_;
  ::google::protobuf::uint32 video_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static MediaMessage* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageResponse : public ::google::protobuf::Message {
 public:
  MediaMessageResponse();
  virtual ~MediaMessageResponse();

  MediaMessageResponse(const MediaMessageResponse& from);

  inline MediaMessageResponse& operator=(const MediaMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageResponse& default_instance();

  void Swap(MediaMessageResponse* other);

  // implements Message ----------------------------------------------

  MediaMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageResponse& from);
  void MergeFrom(const MediaMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated .app.terminal.MediaMessage messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::app::terminal::MediaMessage& messages(int index) const;
  inline ::app::terminal::MediaMessage* mutable_messages(int index);
  inline ::app::terminal::MediaMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >*
      mutable_messages();

  // required fixed32 leave_message_count = 3;
  inline bool has_leave_message_count() const;
  inline void clear_leave_message_count();
  static const int kLeaveMessageCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leave_message_count() const;
  inline void set_leave_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.MediaMessageResponse)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_leave_message_count();
  inline void clear_has_leave_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage > messages_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 leave_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class JoinedGroupNotification : public ::google::protobuf::Message {
 public:
  JoinedGroupNotification();
  virtual ~JoinedGroupNotification();

  JoinedGroupNotification(const JoinedGroupNotification& from);

  inline JoinedGroupNotification& operator=(const JoinedGroupNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinedGroupNotification& default_instance();

  void Swap(JoinedGroupNotification* other);

  // implements Message ----------------------------------------------

  JoinedGroupNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinedGroupNotification& from);
  void MergeFrom(const JoinedGroupNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required bytes group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const void* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string group_number = 3;
  inline bool has_group_number() const;
  inline void clear_group_number();
  static const int kGroupNumberFieldNumber = 3;
  inline const ::std::string& group_number() const;
  inline void set_group_number(const ::std::string& value);
  inline void set_group_number(const char* value);
  inline void set_group_number(const char* value, size_t size);
  inline ::std::string* mutable_group_number();
  inline ::std::string* release_group_number();
  inline void set_allocated_group_number(::std::string* group_number);

  // required fixed32 talk_priority = 4;
  inline bool has_talk_priority() const;
  inline void clear_talk_priority();
  static const int kTalkPriorityFieldNumber = 4;
  inline ::google::protobuf::uint32 talk_priority() const;
  inline void set_talk_priority(::google::protobuf::uint32 value);

  // required .app.terminal.CallPrivilege call_privilege = 5;
  inline bool has_call_privilege() const;
  inline void clear_call_privilege();
  static const int kCallPrivilegeFieldNumber = 5;
  inline ::app::terminal::CallPrivilege call_privilege() const;
  inline void set_call_privilege(::app::terminal::CallPrivilege value);

  // required .app.terminal.TokenPrivilege token_privilege = 6;
  inline bool has_token_privilege() const;
  inline void clear_token_privilege();
  static const int kTokenPrivilegeFieldNumber = 6;
  inline ::app::terminal::TokenPrivilege token_privilege() const;
  inline void set_token_privilege(::app::terminal::TokenPrivilege value);

  // @@protoc_insertion_point(class_scope:app.terminal.JoinedGroupNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_number();
  inline void clear_has_group_number();
  inline void set_has_talk_priority();
  inline void clear_has_talk_priority();
  inline void set_has_call_privilege();
  inline void clear_has_call_privilege();
  inline void set_has_token_privilege();
  inline void clear_has_token_privilege();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* group_name_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 talk_priority_;
  ::std::string* group_number_;
  int call_privilege_;
  int token_privilege_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static JoinedGroupNotification* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGroupNotification : public ::google::protobuf::Message {
 public:
  LeaveGroupNotification();
  virtual ~LeaveGroupNotification();

  LeaveGroupNotification(const LeaveGroupNotification& from);

  inline LeaveGroupNotification& operator=(const LeaveGroupNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveGroupNotification& default_instance();

  void Swap(LeaveGroupNotification* other);

  // implements Message ----------------------------------------------

  LeaveGroupNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveGroupNotification& from);
  void MergeFrom(const LeaveGroupNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.LeaveGroupNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static LeaveGroupNotification* default_instance_;
};
// -------------------------------------------------------------------

class OthersJoinedGroupNotification : public ::google::protobuf::Message {
 public:
  OthersJoinedGroupNotification();
  virtual ~OthersJoinedGroupNotification();

  OthersJoinedGroupNotification(const OthersJoinedGroupNotification& from);

  inline OthersJoinedGroupNotification& operator=(const OthersJoinedGroupNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OthersJoinedGroupNotification& default_instance();

  void Swap(OthersJoinedGroupNotification* other);

  // implements Message ----------------------------------------------

  OthersJoinedGroupNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OthersJoinedGroupNotification& from);
  void MergeFrom(const OthersJoinedGroupNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated .app.terminal.Participant participants = 2;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 2;
  inline const ::app::terminal::Participant& participants(int index) const;
  inline ::app::terminal::Participant* mutable_participants(int index);
  inline ::app::terminal::Participant* add_participants();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >&
      participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >*
      mutable_participants();

  // @@protoc_insertion_point(class_scope:app.terminal.OthersJoinedGroupNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant > participants_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static OthersJoinedGroupNotification* default_instance_;
};
// -------------------------------------------------------------------

class OthersLeaveGroupNotification : public ::google::protobuf::Message {
 public:
  OthersLeaveGroupNotification();
  virtual ~OthersLeaveGroupNotification();

  OthersLeaveGroupNotification(const OthersLeaveGroupNotification& from);

  inline OthersLeaveGroupNotification& operator=(const OthersLeaveGroupNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OthersLeaveGroupNotification& default_instance();

  void Swap(OthersLeaveGroupNotification* other);

  // implements Message ----------------------------------------------

  OthersLeaveGroupNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OthersLeaveGroupNotification& from);
  void MergeFrom(const OthersLeaveGroupNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated fixed32 account_ids = 2;
  inline int account_ids_size() const;
  inline void clear_account_ids();
  static const int kAccountIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 account_ids(int index) const;
  inline void set_account_ids(int index, ::google::protobuf::uint32 value);
  inline void add_account_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      account_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_account_ids();

  // @@protoc_insertion_point(class_scope:app.terminal.OthersLeaveGroupNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > account_ids_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static OthersLeaveGroupNotification* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageNotification : public ::google::protobuf::Message {
 public:
  MediaMessageNotification();
  virtual ~MediaMessageNotification();

  MediaMessageNotification(const MediaMessageNotification& from);

  inline MediaMessageNotification& operator=(const MediaMessageNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageNotification& default_instance();

  void Swap(MediaMessageNotification* other);

  // implements Message ----------------------------------------------

  MediaMessageNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageNotification& from);
  void MergeFrom(const MediaMessageNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required .app.terminal.MediaMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::app::terminal::MediaMessage& msg() const;
  inline ::app::terminal::MediaMessage* mutable_msg();
  inline ::app::terminal::MediaMessage* release_msg();
  inline void set_allocated_msg(::app::terminal::MediaMessage* msg);

  // @@protoc_insertion_point(class_scope:app.terminal.MediaMessageNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::MediaMessage* msg_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageNotification* default_instance_;
};
// -------------------------------------------------------------------

class JoinGroupRequest : public ::google::protobuf::Message {
 public:
  JoinGroupRequest();
  virtual ~JoinGroupRequest();

  JoinGroupRequest(const JoinGroupRequest& from);

  inline JoinGroupRequest& operator=(const JoinGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGroupRequest& default_instance();

  void Swap(JoinGroupRequest* other);

  // implements Message ----------------------------------------------

  JoinGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinGroupRequest& from);
  void MergeFrom(const JoinGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.JoinGroupRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static JoinGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectGroupRequest : public ::google::protobuf::Message {
 public:
  ConnectGroupRequest();
  virtual ~ConnectGroupRequest();

  ConnectGroupRequest(const ConnectGroupRequest& from);

  inline ConnectGroupRequest& operator=(const ConnectGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectGroupRequest& default_instance();

  void Swap(ConnectGroupRequest* other);

  // implements Message ----------------------------------------------

  ConnectGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectGroupRequest& from);
  void MergeFrom(const ConnectGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.ConnectGroupRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static ConnectGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class SessionStatusNotification : public ::google::protobuf::Message {
 public:
  SessionStatusNotification();
  virtual ~SessionStatusNotification();

  SessionStatusNotification(const SessionStatusNotification& from);

  inline SessionStatusNotification& operator=(const SessionStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStatusNotification& default_instance();

  void Swap(SessionStatusNotification* other);

  // implements Message ----------------------------------------------

  SessionStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStatusNotification& from);
  void MergeFrom(const SessionStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required fixed32 account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required .app.terminal.MediaMessage status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::app::terminal::MediaMessage& status() const;
  inline ::app::terminal::MediaMessage* mutable_status();
  inline ::app::terminal::MediaMessage* release_status();
  inline void set_allocated_status(::app::terminal::MediaMessage* status);

  // @@protoc_insertion_point(class_scope:app.terminal.SessionStatusNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 account_id_;
  ::app::terminal::MediaMessage* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static SessionStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class SpeakRequest : public ::google::protobuf::Message {
 public:
  SpeakRequest();
  virtual ~SpeakRequest();

  SpeakRequest(const SpeakRequest& from);

  inline SpeakRequest& operator=(const SpeakRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeakRequest& default_instance();

  void Swap(SpeakRequest* other);

  // implements Message ----------------------------------------------

  SpeakRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeakRequest& from);
  void MergeFrom(const SpeakRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.SpeakRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static SpeakRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionRequest : public ::google::protobuf::Message {
 public:
  JoinSessionRequest();
  virtual ~JoinSessionRequest();

  JoinSessionRequest(const JoinSessionRequest& from);

  inline JoinSessionRequest& operator=(const JoinSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionRequest& default_instance();

  void Swap(JoinSessionRequest* other);

  // implements Message ----------------------------------------------

  JoinSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionRequest& from);
  void MergeFrom(const JoinSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.JoinSessionRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveSessionRequest : public ::google::protobuf::Message {
 public:
  LeaveSessionRequest();
  virtual ~LeaveSessionRequest();

  LeaveSessionRequest(const LeaveSessionRequest& from);

  inline LeaveSessionRequest& operator=(const LeaveSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveSessionRequest& default_instance();

  void Swap(LeaveSessionRequest* other);

  // implements Message ----------------------------------------------

  LeaveSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveSessionRequest& from);
  void MergeFrom(const LeaveSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.LeaveSessionRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static LeaveSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseTokenRequest : public ::google::protobuf::Message {
 public:
  ReleaseTokenRequest();
  virtual ~ReleaseTokenRequest();

  ReleaseTokenRequest(const ReleaseTokenRequest& from);

  inline ReleaseTokenRequest& operator=(const ReleaseTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseTokenRequest& default_instance();

  void Swap(ReleaseTokenRequest* other);

  // implements Message ----------------------------------------------

  ReleaseTokenRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseTokenRequest& from);
  void MergeFrom(const ReleaseTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.ReleaseTokenRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static ReleaseTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppointSpeakRequest : public ::google::protobuf::Message {
 public:
  AppointSpeakRequest();
  virtual ~AppointSpeakRequest();

  AppointSpeakRequest(const AppointSpeakRequest& from);

  inline AppointSpeakRequest& operator=(const AppointSpeakRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppointSpeakRequest& default_instance();

  void Swap(AppointSpeakRequest* other);

  // implements Message ----------------------------------------------

  AppointSpeakRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppointSpeakRequest& from);
  void MergeFrom(const AppointSpeakRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.AppointSpeakRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AppointSpeakRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageRequest : public ::google::protobuf::Message {
 public:
  SendMessageRequest();
  virtual ~SendMessageRequest();

  SendMessageRequest(const SendMessageRequest& from);

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageRequest& default_instance();

  void Swap(SendMessageRequest* other);

  // implements Message ----------------------------------------------

  SendMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageRequest& from);
  void MergeFrom(const SendMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional bytes text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string picture_uri = 3;
  inline bool has_picture_uri() const;
  inline void clear_picture_uri();
  static const int kPictureUriFieldNumber = 3;
  inline const ::std::string& picture_uri() const;
  inline void set_picture_uri(const ::std::string& value);
  inline void set_picture_uri(const char* value);
  inline void set_picture_uri(const char* value, size_t size);
  inline ::std::string* mutable_picture_uri();
  inline ::std::string* release_picture_uri();
  inline void set_allocated_picture_uri(::std::string* picture_uri);

  // optional string audio_uri = 4;
  inline bool has_audio_uri() const;
  inline void clear_audio_uri();
  static const int kAudioUriFieldNumber = 4;
  inline const ::std::string& audio_uri() const;
  inline void set_audio_uri(const ::std::string& value);
  inline void set_audio_uri(const char* value);
  inline void set_audio_uri(const char* value, size_t size);
  inline ::std::string* mutable_audio_uri();
  inline ::std::string* release_audio_uri();
  inline void set_allocated_audio_uri(::std::string* audio_uri);

  // optional fixed32 audio_length = 5;
  inline bool has_audio_length() const;
  inline void clear_audio_length();
  static const int kAudioLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 audio_length() const;
  inline void set_audio_length(::google::protobuf::uint32 value);

  // optional string video_uri = 6;
  inline bool has_video_uri() const;
  inline void clear_video_uri();
  static const int kVideoUriFieldNumber = 6;
  inline const ::std::string& video_uri() const;
  inline void set_video_uri(const ::std::string& value);
  inline void set_video_uri(const char* value);
  inline void set_video_uri(const char* value, size_t size);
  inline ::std::string* mutable_video_uri();
  inline ::std::string* release_video_uri();
  inline void set_allocated_video_uri(::std::string* video_uri);

  // optional fixed32 video_length = 7;
  inline bool has_video_length() const;
  inline void clear_video_length();
  static const int kVideoLengthFieldNumber = 7;
  inline ::google::protobuf::uint32 video_length() const;
  inline void set_video_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.SendMessageRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_picture_uri();
  inline void clear_has_picture_uri();
  inline void set_has_audio_uri();
  inline void clear_has_audio_uri();
  inline void set_has_audio_length();
  inline void clear_has_audio_length();
  inline void set_has_video_uri();
  inline void clear_has_video_uri();
  inline void set_has_video_length();
  inline void clear_has_video_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::std::string* picture_uri_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 audio_length_;
  ::std::string* audio_uri_;
  ::std::string* video_uri_;
  ::google::protobuf::uint32 video_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static SendMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeLocationRequest : public ::google::protobuf::Message {
 public:
  SubscribeLocationRequest();
  virtual ~SubscribeLocationRequest();

  SubscribeLocationRequest(const SubscribeLocationRequest& from);

  inline SubscribeLocationRequest& operator=(const SubscribeLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeLocationRequest& default_instance();

  void Swap(SubscribeLocationRequest* other);

  // implements Message ----------------------------------------------

  SubscribeLocationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeLocationRequest& from);
  void MergeFrom(const SubscribeLocationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool subscribing = 1;
  inline bool has_subscribing() const;
  inline void clear_subscribing();
  static const int kSubscribingFieldNumber = 1;
  inline bool subscribing() const;
  inline void set_subscribing(bool value);

  // required fixed32 ttl = 2;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 2;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.SubscribeLocationRequest)
 private:
  inline void set_has_subscribing();
  inline void clear_has_subscribing();
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool subscribing_;
  ::google::protobuf::uint32 ttl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static SubscribeLocationRequest* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeLocationResponse : public ::google::protobuf::Message {
 public:
  SubscribeLocationResponse();
  virtual ~SubscribeLocationResponse();

  SubscribeLocationResponse(const SubscribeLocationResponse& from);

  inline SubscribeLocationResponse& operator=(const SubscribeLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeLocationResponse& default_instance();

  void Swap(SubscribeLocationResponse* other);

  // implements Message ----------------------------------------------

  SubscribeLocationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeLocationResponse& from);
  void MergeFrom(const SubscribeLocationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longtitude = 1;
  inline bool has_longtitude() const;
  inline void clear_longtitude();
  static const int kLongtitudeFieldNumber = 1;
  inline double longtitude() const;
  inline void set_longtitude(double value);

  // required double latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline double latitude() const;
  inline void set_latitude(double value);

  // required fixed32 acquire_location_time = 3;
  inline bool has_acquire_location_time() const;
  inline void clear_acquire_location_time();
  static const int kAcquireLocationTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 acquire_location_time() const;
  inline void set_acquire_location_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.SubscribeLocationResponse)
 private:
  inline void set_has_longtitude();
  inline void clear_has_longtitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_acquire_location_time();
  inline void clear_has_acquire_location_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double longtitude_;
  double latitude_;
  ::google::protobuf::uint32 acquire_location_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static SubscribeLocationResponse* default_instance_;
};
// -------------------------------------------------------------------

class LocationNotification : public ::google::protobuf::Message {
 public:
  LocationNotification();
  virtual ~LocationNotification();

  LocationNotification(const LocationNotification& from);

  inline LocationNotification& operator=(const LocationNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationNotification& default_instance();

  void Swap(LocationNotification* other);

  // implements Message ----------------------------------------------

  LocationNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocationNotification& from);
  void MergeFrom(const LocationNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longtitude = 1;
  inline bool has_longtitude() const;
  inline void clear_longtitude();
  static const int kLongtitudeFieldNumber = 1;
  inline double longtitude() const;
  inline void set_longtitude(double value);

  // required double latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional fixed32 acquire_location_time = 3;
  inline bool has_acquire_location_time() const;
  inline void clear_acquire_location_time();
  static const int kAcquireLocationTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 acquire_location_time() const;
  inline void set_acquire_location_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.LocationNotification)
 private:
  inline void set_has_longtitude();
  inline void clear_has_longtitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_acquire_location_time();
  inline void clear_has_acquire_location_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double longtitude_;
  double latitude_;
  ::google::protobuf::uint32 acquire_location_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static LocationNotification* default_instance_;
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::Message {
 public:
  Alert();
  virtual ~Alert();

  Alert(const Alert& from);

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alert& default_instance();

  void Swap(Alert* other);

  // implements Message ----------------------------------------------

  Alert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required fixed32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // optional .app.terminal.AlertLevel level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::app::terminal::AlertLevel level() const;
  inline void set_level(::app::terminal::AlertLevel value);

  // optional bytes describe = 5;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 5;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const void* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // optional string alarm_time = 6;
  inline bool has_alarm_time() const;
  inline void clear_alarm_time();
  static const int kAlarmTimeFieldNumber = 6;
  inline const ::std::string& alarm_time() const;
  inline void set_alarm_time(const ::std::string& value);
  inline void set_alarm_time(const char* value);
  inline void set_alarm_time(const char* value, size_t size);
  inline ::std::string* mutable_alarm_time();
  inline ::std::string* release_alarm_time();
  inline void set_allocated_alarm_time(::std::string* alarm_time);

  // optional fixed32 use_cars = 7;
  inline bool has_use_cars() const;
  inline void clear_use_cars();
  static const int kUseCarsFieldNumber = 7;
  inline ::google::protobuf::uint32 use_cars() const;
  inline void set_use_cars(::google::protobuf::uint32 value);

  // optional string create_time = 8;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 8;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const char* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // @@protoc_insertion_point(class_scope:app.terminal.Alert)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_describe();
  inline void clear_has_describe();
  inline void set_has_alarm_time();
  inline void clear_has_alarm_time();
  inline void set_has_use_cars();
  inline void clear_has_use_cars();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 group_id_;
  ::std::string* describe_;
  int level_;
  ::google::protobuf::uint32 use_cars_;
  ::std::string* alarm_time_;
  ::std::string* create_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Alert* default_instance_;
};
// -------------------------------------------------------------------

class AlertsResponse : public ::google::protobuf::Message {
 public:
  AlertsResponse();
  virtual ~AlertsResponse();

  AlertsResponse(const AlertsResponse& from);

  inline AlertsResponse& operator=(const AlertsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertsResponse& default_instance();

  void Swap(AlertsResponse* other);

  // implements Message ----------------------------------------------

  AlertsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertsResponse& from);
  void MergeFrom(const AlertsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .app.terminal.Alert alerts = 4;
  inline int alerts_size() const;
  inline void clear_alerts();
  static const int kAlertsFieldNumber = 4;
  inline const ::app::terminal::Alert& alerts(int index) const;
  inline ::app::terminal::Alert* mutable_alerts(int index);
  inline ::app::terminal::Alert* add_alerts();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Alert >&
      alerts() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Alert >*
      mutable_alerts();

  // @@protoc_insertion_point(class_scope:app.terminal.AlertsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::Alert > alerts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertsResponse* default_instance_;
};
// -------------------------------------------------------------------

class AlertRequest : public ::google::protobuf::Message {
 public:
  AlertRequest();
  virtual ~AlertRequest();

  AlertRequest(const AlertRequest& from);

  inline AlertRequest& operator=(const AlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertRequest& default_instance();

  void Swap(AlertRequest* other);

  // implements Message ----------------------------------------------

  AlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertRequest& from);
  void MergeFrom(const AlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 alert_id() const;
  inline void set_alert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.AlertRequest)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class AlertResponse : public ::google::protobuf::Message {
 public:
  AlertResponse();
  virtual ~AlertResponse();

  AlertResponse(const AlertResponse& from);

  inline AlertResponse& operator=(const AlertResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertResponse& default_instance();

  void Swap(AlertResponse* other);

  // implements Message ----------------------------------------------

  AlertResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertResponse& from);
  void MergeFrom(const AlertResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.terminal.Alert alert = 1;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 1;
  inline const ::app::terminal::Alert& alert() const;
  inline ::app::terminal::Alert* mutable_alert();
  inline ::app::terminal::Alert* release_alert();
  inline void set_allocated_alert(::app::terminal::Alert* alert);

  // @@protoc_insertion_point(class_scope:app.terminal.AlertResponse)
 private:
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::Alert* alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertResponse* default_instance_;
};
// -------------------------------------------------------------------

class AlertCreateNotification : public ::google::protobuf::Message {
 public:
  AlertCreateNotification();
  virtual ~AlertCreateNotification();

  AlertCreateNotification(const AlertCreateNotification& from);

  inline AlertCreateNotification& operator=(const AlertCreateNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertCreateNotification& default_instance();

  void Swap(AlertCreateNotification* other);

  // implements Message ----------------------------------------------

  AlertCreateNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertCreateNotification& from);
  void MergeFrom(const AlertCreateNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 alert_id() const;
  inline void set_alert_id(::google::protobuf::uint32 value);

  // required bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required fixed32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.AlertCreateNotification)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 alert_id_;
  ::google::protobuf::uint32 group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertCreateNotification* default_instance_;
};
// -------------------------------------------------------------------

class AlertModifyNotification : public ::google::protobuf::Message {
 public:
  AlertModifyNotification();
  virtual ~AlertModifyNotification();

  AlertModifyNotification(const AlertModifyNotification& from);

  inline AlertModifyNotification& operator=(const AlertModifyNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertModifyNotification& default_instance();

  void Swap(AlertModifyNotification* other);

  // implements Message ----------------------------------------------

  AlertModifyNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertModifyNotification& from);
  void MergeFrom(const AlertModifyNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.terminal.Alert alert = 1;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 1;
  inline const ::app::terminal::Alert& alert() const;
  inline ::app::terminal::Alert* mutable_alert();
  inline ::app::terminal::Alert* release_alert();
  inline void set_allocated_alert(::app::terminal::Alert* alert);

  // @@protoc_insertion_point(class_scope:app.terminal.AlertModifyNotification)
 private:
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::Alert* alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertModifyNotification* default_instance_;
};
// -------------------------------------------------------------------

class AlertOveredNotification : public ::google::protobuf::Message {
 public:
  AlertOveredNotification();
  virtual ~AlertOveredNotification();

  AlertOveredNotification(const AlertOveredNotification& from);

  inline AlertOveredNotification& operator=(const AlertOveredNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertOveredNotification& default_instance();

  void Swap(AlertOveredNotification* other);

  // implements Message ----------------------------------------------

  AlertOveredNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertOveredNotification& from);
  void MergeFrom(const AlertOveredNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 alert_id() const;
  inline void set_alert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.AlertOveredNotification)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static AlertOveredNotification* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertsRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertsRequest();
  virtual ~HistoryAlertsRequest();

  HistoryAlertsRequest(const HistoryAlertsRequest& from);

  inline HistoryAlertsRequest& operator=(const HistoryAlertsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertsRequest& default_instance();

  void Swap(HistoryAlertsRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertsRequest& from);
  void MergeFrom(const HistoryAlertsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string create_time_from = 2;
  inline bool has_create_time_from() const;
  inline void clear_create_time_from();
  static const int kCreateTimeFromFieldNumber = 2;
  inline const ::std::string& create_time_from() const;
  inline void set_create_time_from(const ::std::string& value);
  inline void set_create_time_from(const char* value);
  inline void set_create_time_from(const char* value, size_t size);
  inline ::std::string* mutable_create_time_from();
  inline ::std::string* release_create_time_from();
  inline void set_allocated_create_time_from(::std::string* create_time_from);

  // optional string create_time_to = 3;
  inline bool has_create_time_to() const;
  inline void clear_create_time_to();
  static const int kCreateTimeToFieldNumber = 3;
  inline const ::std::string& create_time_to() const;
  inline void set_create_time_to(const ::std::string& value);
  inline void set_create_time_to(const char* value);
  inline void set_create_time_to(const char* value, size_t size);
  inline ::std::string* mutable_create_time_to();
  inline ::std::string* release_create_time_to();
  inline void set_allocated_create_time_to(::std::string* create_time_to);

  // optional string alram_time_from = 4;
  inline bool has_alram_time_from() const;
  inline void clear_alram_time_from();
  static const int kAlramTimeFromFieldNumber = 4;
  inline const ::std::string& alram_time_from() const;
  inline void set_alram_time_from(const ::std::string& value);
  inline void set_alram_time_from(const char* value);
  inline void set_alram_time_from(const char* value, size_t size);
  inline ::std::string* mutable_alram_time_from();
  inline ::std::string* release_alram_time_from();
  inline void set_allocated_alram_time_from(::std::string* alram_time_from);

  // optional string alram_time_to = 5;
  inline bool has_alram_time_to() const;
  inline void clear_alram_time_to();
  static const int kAlramTimeToFieldNumber = 5;
  inline const ::std::string& alram_time_to() const;
  inline void set_alram_time_to(const ::std::string& value);
  inline void set_alram_time_to(const char* value);
  inline void set_alram_time_to(const char* value, size_t size);
  inline ::std::string* mutable_alram_time_to();
  inline ::std::string* release_alram_time_to();
  inline void set_allocated_alram_time_to(::std::string* alram_time_to);

  // optional string over_time_from = 6;
  inline bool has_over_time_from() const;
  inline void clear_over_time_from();
  static const int kOverTimeFromFieldNumber = 6;
  inline const ::std::string& over_time_from() const;
  inline void set_over_time_from(const ::std::string& value);
  inline void set_over_time_from(const char* value);
  inline void set_over_time_from(const char* value, size_t size);
  inline ::std::string* mutable_over_time_from();
  inline ::std::string* release_over_time_from();
  inline void set_allocated_over_time_from(::std::string* over_time_from);

  // optional string over_time_to = 7;
  inline bool has_over_time_to() const;
  inline void clear_over_time_to();
  static const int kOverTimeToFieldNumber = 7;
  inline const ::std::string& over_time_to() const;
  inline void set_over_time_to(const ::std::string& value);
  inline void set_over_time_to(const char* value);
  inline void set_over_time_to(const char* value, size_t size);
  inline ::std::string* mutable_over_time_to();
  inline ::std::string* release_over_time_to();
  inline void set_allocated_over_time_to(::std::string* over_time_to);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertsRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_create_time_from();
  inline void clear_has_create_time_from();
  inline void set_has_create_time_to();
  inline void clear_has_create_time_to();
  inline void set_has_alram_time_from();
  inline void clear_has_alram_time_from();
  inline void set_has_alram_time_to();
  inline void clear_has_alram_time_to();
  inline void set_has_over_time_from();
  inline void clear_has_over_time_from();
  inline void set_has_over_time_to();
  inline void clear_has_over_time_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* create_time_from_;
  ::std::string* create_time_to_;
  ::std::string* alram_time_from_;
  ::std::string* alram_time_to_;
  ::std::string* over_time_from_;
  ::std::string* over_time_to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertsRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlert : public ::google::protobuf::Message {
 public:
  HistoryAlert();
  virtual ~HistoryAlert();

  HistoryAlert(const HistoryAlert& from);

  inline HistoryAlert& operator=(const HistoryAlert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlert& default_instance();

  void Swap(HistoryAlert* other);

  // implements Message ----------------------------------------------

  HistoryAlert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlert& from);
  void MergeFrom(const HistoryAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .app.terminal.AlertLevel level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::app::terminal::AlertLevel level() const;
  inline void set_level(::app::terminal::AlertLevel value);

  // optional bytes describe = 4;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 4;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const void* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // optional string alarm_time = 5;
  inline bool has_alarm_time() const;
  inline void clear_alarm_time();
  static const int kAlarmTimeFieldNumber = 5;
  inline const ::std::string& alarm_time() const;
  inline void set_alarm_time(const ::std::string& value);
  inline void set_alarm_time(const char* value);
  inline void set_alarm_time(const char* value, size_t size);
  inline ::std::string* mutable_alarm_time();
  inline ::std::string* release_alarm_time();
  inline void set_allocated_alarm_time(::std::string* alarm_time);

  // optional fixed32 use_cars = 6;
  inline bool has_use_cars() const;
  inline void clear_use_cars();
  static const int kUseCarsFieldNumber = 6;
  inline ::google::protobuf::uint32 use_cars() const;
  inline void set_use_cars(::google::protobuf::uint32 value);

  // optional string create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const char* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // optional string over_time = 8;
  inline bool has_over_time() const;
  inline void clear_over_time();
  static const int kOverTimeFieldNumber = 8;
  inline const ::std::string& over_time() const;
  inline void set_over_time(const ::std::string& value);
  inline void set_over_time(const char* value);
  inline void set_over_time(const char* value, size_t size);
  inline ::std::string* mutable_over_time();
  inline ::std::string* release_over_time();
  inline void set_allocated_over_time(::std::string* over_time);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlert)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_describe();
  inline void clear_has_describe();
  inline void set_has_alarm_time();
  inline void clear_has_alarm_time();
  inline void set_has_use_cars();
  inline void clear_has_use_cars();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_over_time();
  inline void clear_has_over_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  int level_;
  ::std::string* describe_;
  ::std::string* alarm_time_;
  ::std::string* create_time_;
  ::std::string* over_time_;
  ::google::protobuf::uint32 use_cars_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlert* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertsResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertsResponse();
  virtual ~HistoryAlertsResponse();

  HistoryAlertsResponse(const HistoryAlertsResponse& from);

  inline HistoryAlertsResponse& operator=(const HistoryAlertsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertsResponse& default_instance();

  void Swap(HistoryAlertsResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertsResponse& from);
  void MergeFrom(const HistoryAlertsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .app.terminal.HistoryAlert history_alerts = 1;
  inline int history_alerts_size() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 1;
  inline const ::app::terminal::HistoryAlert& history_alerts(int index) const;
  inline ::app::terminal::HistoryAlert* mutable_history_alerts(int index);
  inline ::app::terminal::HistoryAlert* add_history_alerts();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::HistoryAlert >&
      history_alerts() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::HistoryAlert >*
      mutable_history_alerts();

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::HistoryAlert > history_alerts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertsResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertRequest();
  virtual ~HistoryAlertRequest();

  HistoryAlertRequest(const HistoryAlertRequest& from);

  inline HistoryAlertRequest& operator=(const HistoryAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertRequest& default_instance();

  void Swap(HistoryAlertRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertRequest& from);
  void MergeFrom(const HistoryAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertRequest)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertResponse();
  virtual ~HistoryAlertResponse();

  HistoryAlertResponse(const HistoryAlertResponse& from);

  inline HistoryAlertResponse& operator=(const HistoryAlertResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertResponse& default_instance();

  void Swap(HistoryAlertResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertResponse& from);
  void MergeFrom(const HistoryAlertResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.terminal.HistoryAlert history_alert = 1;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 1;
  inline const ::app::terminal::HistoryAlert& history_alert() const;
  inline ::app::terminal::HistoryAlert* mutable_history_alert();
  inline ::app::terminal::HistoryAlert* release_history_alert();
  inline void set_allocated_history_alert(::app::terminal::HistoryAlert* history_alert);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertResponse)
 private:
  inline void set_has_history_alert();
  inline void clear_has_history_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::HistoryAlert* history_alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertMesageRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertMesageRequest();
  virtual ~HistoryAlertMesageRequest();

  HistoryAlertMesageRequest(const HistoryAlertMesageRequest& from);

  inline HistoryAlertMesageRequest& operator=(const HistoryAlertMesageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertMesageRequest& default_instance();

  void Swap(HistoryAlertMesageRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertMesageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertMesageRequest& from);
  void MergeFrom(const HistoryAlertMesageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // optional fixed32 from_message_id = 2;
  inline bool has_from_message_id() const;
  inline void clear_from_message_id();
  static const int kFromMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_message_id() const;
  inline void set_from_message_id(::google::protobuf::uint32 value);

  // optional string from_time = 3;
  inline bool has_from_time() const;
  inline void clear_from_time();
  static const int kFromTimeFieldNumber = 3;
  inline const ::std::string& from_time() const;
  inline void set_from_time(const ::std::string& value);
  inline void set_from_time(const char* value);
  inline void set_from_time(const char* value, size_t size);
  inline ::std::string* mutable_from_time();
  inline ::std::string* release_from_time();
  inline void set_allocated_from_time(::std::string* from_time);

  // required fixed32 max_message_count = 4;
  inline bool has_max_message_count() const;
  inline void clear_max_message_count();
  static const int kMaxMessageCountFieldNumber = 4;
  inline ::google::protobuf::uint32 max_message_count() const;
  inline void set_max_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertMesageRequest)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();
  inline void set_has_from_message_id();
  inline void clear_has_from_message_id();
  inline void set_has_from_time();
  inline void clear_has_from_time();
  inline void set_has_max_message_count();
  inline void clear_has_max_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_alert_id_;
  ::google::protobuf::uint32 from_message_id_;
  ::std::string* from_time_;
  ::google::protobuf::uint32 max_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertMesageRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertMesageResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertMesageResponse();
  virtual ~HistoryAlertMesageResponse();

  HistoryAlertMesageResponse(const HistoryAlertMesageResponse& from);

  inline HistoryAlertMesageResponse& operator=(const HistoryAlertMesageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertMesageResponse& default_instance();

  void Swap(HistoryAlertMesageResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertMesageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertMesageResponse& from);
  void MergeFrom(const HistoryAlertMesageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // repeated .app.terminal.MediaMessage messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::app::terminal::MediaMessage& messages(int index) const;
  inline ::app::terminal::MediaMessage* mutable_messages(int index);
  inline ::app::terminal::MediaMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >*
      mutable_messages();

  // required fixed32 leave_message_count = 3;
  inline bool has_leave_message_count() const;
  inline void clear_leave_message_count();
  static const int kLeaveMessageCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leave_message_count() const;
  inline void set_leave_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.terminal.HistoryAlertMesageResponse)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();
  inline void set_has_leave_message_count();
  inline void clear_has_leave_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage > messages_;
  ::google::protobuf::uint32 history_alert_id_;
  ::google::protobuf::uint32 leave_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertMesageResponse* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.terminal.LoginRequest login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::app::terminal::LoginRequest& login() const;
  inline ::app::terminal::LoginRequest* mutable_login();
  inline ::app::terminal::LoginRequest* release_login();
  inline void set_allocated_login(::app::terminal::LoginRequest* login);

  // optional .app.terminal.GroupParticipantsRequest gourp_participants = 2;
  inline bool has_gourp_participants() const;
  inline void clear_gourp_participants();
  static const int kGourpParticipantsFieldNumber = 2;
  inline const ::app::terminal::GroupParticipantsRequest& gourp_participants() const;
  inline ::app::terminal::GroupParticipantsRequest* mutable_gourp_participants();
  inline ::app::terminal::GroupParticipantsRequest* release_gourp_participants();
  inline void set_allocated_gourp_participants(::app::terminal::GroupParticipantsRequest* gourp_participants);

  // optional .app.terminal.MediaMessageRequest group_message = 3;
  inline bool has_group_message() const;
  inline void clear_group_message();
  static const int kGroupMessageFieldNumber = 3;
  inline const ::app::terminal::MediaMessageRequest& group_message() const;
  inline ::app::terminal::MediaMessageRequest* mutable_group_message();
  inline ::app::terminal::MediaMessageRequest* release_group_message();
  inline void set_allocated_group_message(::app::terminal::MediaMessageRequest* group_message);

  // optional .app.terminal.JoinGroupRequest join_group = 4;
  inline bool has_join_group() const;
  inline void clear_join_group();
  static const int kJoinGroupFieldNumber = 4;
  inline const ::app::terminal::JoinGroupRequest& join_group() const;
  inline ::app::terminal::JoinGroupRequest* mutable_join_group();
  inline ::app::terminal::JoinGroupRequest* release_join_group();
  inline void set_allocated_join_group(::app::terminal::JoinGroupRequest* join_group);

  // optional .app.terminal.ConnectGroupRequest connect_group = 5;
  inline bool has_connect_group() const;
  inline void clear_connect_group();
  static const int kConnectGroupFieldNumber = 5;
  inline const ::app::terminal::ConnectGroupRequest& connect_group() const;
  inline ::app::terminal::ConnectGroupRequest* mutable_connect_group();
  inline ::app::terminal::ConnectGroupRequest* release_connect_group();
  inline void set_allocated_connect_group(::app::terminal::ConnectGroupRequest* connect_group);

  // optional .app.terminal.SpeakRequest speak = 6;
  inline bool has_speak() const;
  inline void clear_speak();
  static const int kSpeakFieldNumber = 6;
  inline const ::app::terminal::SpeakRequest& speak() const;
  inline ::app::terminal::SpeakRequest* mutable_speak();
  inline ::app::terminal::SpeakRequest* release_speak();
  inline void set_allocated_speak(::app::terminal::SpeakRequest* speak);

  // optional .app.terminal.JoinSessionRequest jone_session = 7;
  inline bool has_jone_session() const;
  inline void clear_jone_session();
  static const int kJoneSessionFieldNumber = 7;
  inline const ::app::terminal::JoinSessionRequest& jone_session() const;
  inline ::app::terminal::JoinSessionRequest* mutable_jone_session();
  inline ::app::terminal::JoinSessionRequest* release_jone_session();
  inline void set_allocated_jone_session(::app::terminal::JoinSessionRequest* jone_session);

  // optional .app.terminal.LeaveSessionRequest leave_session = 8;
  inline bool has_leave_session() const;
  inline void clear_leave_session();
  static const int kLeaveSessionFieldNumber = 8;
  inline const ::app::terminal::LeaveSessionRequest& leave_session() const;
  inline ::app::terminal::LeaveSessionRequest* mutable_leave_session();
  inline ::app::terminal::LeaveSessionRequest* release_leave_session();
  inline void set_allocated_leave_session(::app::terminal::LeaveSessionRequest* leave_session);

  // optional .app.terminal.ReleaseTokenRequest release_token = 9;
  inline bool has_release_token() const;
  inline void clear_release_token();
  static const int kReleaseTokenFieldNumber = 9;
  inline const ::app::terminal::ReleaseTokenRequest& release_token() const;
  inline ::app::terminal::ReleaseTokenRequest* mutable_release_token();
  inline ::app::terminal::ReleaseTokenRequest* release_release_token();
  inline void set_allocated_release_token(::app::terminal::ReleaseTokenRequest* release_token);

  // optional .app.terminal.AppointSpeakRequest appoint_speak = 10;
  inline bool has_appoint_speak() const;
  inline void clear_appoint_speak();
  static const int kAppointSpeakFieldNumber = 10;
  inline const ::app::terminal::AppointSpeakRequest& appoint_speak() const;
  inline ::app::terminal::AppointSpeakRequest* mutable_appoint_speak();
  inline ::app::terminal::AppointSpeakRequest* release_appoint_speak();
  inline void set_allocated_appoint_speak(::app::terminal::AppointSpeakRequest* appoint_speak);

  // optional .app.terminal.SendMessageRequest send_message = 11;
  inline bool has_send_message() const;
  inline void clear_send_message();
  static const int kSendMessageFieldNumber = 11;
  inline const ::app::terminal::SendMessageRequest& send_message() const;
  inline ::app::terminal::SendMessageRequest* mutable_send_message();
  inline ::app::terminal::SendMessageRequest* release_send_message();
  inline void set_allocated_send_message(::app::terminal::SendMessageRequest* send_message);

  // optional .app.terminal.SubscribeLocationRequest subscribe_location = 12;
  inline bool has_subscribe_location() const;
  inline void clear_subscribe_location();
  static const int kSubscribeLocationFieldNumber = 12;
  inline const ::app::terminal::SubscribeLocationRequest& subscribe_location() const;
  inline ::app::terminal::SubscribeLocationRequest* mutable_subscribe_location();
  inline ::app::terminal::SubscribeLocationRequest* release_subscribe_location();
  inline void set_allocated_subscribe_location(::app::terminal::SubscribeLocationRequest* subscribe_location);

  // optional .app.terminal.AlertRequest alert = 13;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 13;
  inline const ::app::terminal::AlertRequest& alert() const;
  inline ::app::terminal::AlertRequest* mutable_alert();
  inline ::app::terminal::AlertRequest* release_alert();
  inline void set_allocated_alert(::app::terminal::AlertRequest* alert);

  // optional .app.terminal.HistoryAlertsRequest history_alerts = 14;
  inline bool has_history_alerts() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 14;
  inline const ::app::terminal::HistoryAlertsRequest& history_alerts() const;
  inline ::app::terminal::HistoryAlertsRequest* mutable_history_alerts();
  inline ::app::terminal::HistoryAlertsRequest* release_history_alerts();
  inline void set_allocated_history_alerts(::app::terminal::HistoryAlertsRequest* history_alerts);

  // optional .app.terminal.HistoryAlertRequest history_alert = 15;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 15;
  inline const ::app::terminal::HistoryAlertRequest& history_alert() const;
  inline ::app::terminal::HistoryAlertRequest* mutable_history_alert();
  inline ::app::terminal::HistoryAlertRequest* release_history_alert();
  inline void set_allocated_history_alert(::app::terminal::HistoryAlertRequest* history_alert);

  // optional .app.terminal.HistoryAlertMesageRequest history_alert_message = 16;
  inline bool has_history_alert_message() const;
  inline void clear_history_alert_message();
  static const int kHistoryAlertMessageFieldNumber = 16;
  inline const ::app::terminal::HistoryAlertMesageRequest& history_alert_message() const;
  inline ::app::terminal::HistoryAlertMesageRequest* mutable_history_alert_message();
  inline ::app::terminal::HistoryAlertMesageRequest* release_history_alert_message();
  inline void set_allocated_history_alert_message(::app::terminal::HistoryAlertMesageRequest* history_alert_message);

  // @@protoc_insertion_point(class_scope:app.terminal.Request)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_gourp_participants();
  inline void clear_has_gourp_participants();
  inline void set_has_group_message();
  inline void clear_has_group_message();
  inline void set_has_join_group();
  inline void clear_has_join_group();
  inline void set_has_connect_group();
  inline void clear_has_connect_group();
  inline void set_has_speak();
  inline void clear_has_speak();
  inline void set_has_jone_session();
  inline void clear_has_jone_session();
  inline void set_has_leave_session();
  inline void clear_has_leave_session();
  inline void set_has_release_token();
  inline void clear_has_release_token();
  inline void set_has_appoint_speak();
  inline void clear_has_appoint_speak();
  inline void set_has_send_message();
  inline void clear_has_send_message();
  inline void set_has_subscribe_location();
  inline void clear_has_subscribe_location();
  inline void set_has_alert();
  inline void clear_has_alert();
  inline void set_has_history_alerts();
  inline void clear_has_history_alerts();
  inline void set_has_history_alert();
  inline void clear_has_history_alert();
  inline void set_has_history_alert_message();
  inline void clear_has_history_alert_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::LoginRequest* login_;
  ::app::terminal::GroupParticipantsRequest* gourp_participants_;
  ::app::terminal::MediaMessageRequest* group_message_;
  ::app::terminal::JoinGroupRequest* join_group_;
  ::app::terminal::ConnectGroupRequest* connect_group_;
  ::app::terminal::SpeakRequest* speak_;
  ::app::terminal::JoinSessionRequest* jone_session_;
  ::app::terminal::LeaveSessionRequest* leave_session_;
  ::app::terminal::ReleaseTokenRequest* release_token_;
  ::app::terminal::AppointSpeakRequest* appoint_speak_;
  ::app::terminal::SendMessageRequest* send_message_;
  ::app::terminal::SubscribeLocationRequest* subscribe_location_;
  ::app::terminal::AlertRequest* alert_;
  ::app::terminal::HistoryAlertsRequest* history_alerts_;
  ::app::terminal::HistoryAlertRequest* history_alert_;
  ::app::terminal::HistoryAlertMesageRequest* history_alert_message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // required bool last_response = 2;
  inline bool has_last_response() const;
  inline void clear_last_response();
  static const int kLastResponseFieldNumber = 2;
  inline bool last_response() const;
  inline void set_last_response(bool value);

  // optional bytes error_describe = 3;
  inline bool has_error_describe() const;
  inline void clear_error_describe();
  static const int kErrorDescribeFieldNumber = 3;
  inline const ::std::string& error_describe() const;
  inline void set_error_describe(const ::std::string& value);
  inline void set_error_describe(const char* value);
  inline void set_error_describe(const void* value, size_t size);
  inline ::std::string* mutable_error_describe();
  inline ::std::string* release_error_describe();
  inline void set_allocated_error_describe(::std::string* error_describe);

  // optional .app.terminal.LoginResponse login = 4;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 4;
  inline const ::app::terminal::LoginResponse& login() const;
  inline ::app::terminal::LoginResponse* mutable_login();
  inline ::app::terminal::LoginResponse* release_login();
  inline void set_allocated_login(::app::terminal::LoginResponse* login);

  // optional .app.terminal.GroupsResponse groups = 5;
  inline bool has_groups() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 5;
  inline const ::app::terminal::GroupsResponse& groups() const;
  inline ::app::terminal::GroupsResponse* mutable_groups();
  inline ::app::terminal::GroupsResponse* release_groups();
  inline void set_allocated_groups(::app::terminal::GroupsResponse* groups);

  // optional .app.terminal.GroupParticipantsResponse group_participants = 6;
  inline bool has_group_participants() const;
  inline void clear_group_participants();
  static const int kGroupParticipantsFieldNumber = 6;
  inline const ::app::terminal::GroupParticipantsResponse& group_participants() const;
  inline ::app::terminal::GroupParticipantsResponse* mutable_group_participants();
  inline ::app::terminal::GroupParticipantsResponse* release_group_participants();
  inline void set_allocated_group_participants(::app::terminal::GroupParticipantsResponse* group_participants);

  // optional .app.terminal.MediaMessageResponse group_message = 7;
  inline bool has_group_message() const;
  inline void clear_group_message();
  static const int kGroupMessageFieldNumber = 7;
  inline const ::app::terminal::MediaMessageResponse& group_message() const;
  inline ::app::terminal::MediaMessageResponse* mutable_group_message();
  inline ::app::terminal::MediaMessageResponse* release_group_message();
  inline void set_allocated_group_message(::app::terminal::MediaMessageResponse* group_message);

  // optional .app.terminal.SubscribeLocationResponse subscribe_location = 8;
  inline bool has_subscribe_location() const;
  inline void clear_subscribe_location();
  static const int kSubscribeLocationFieldNumber = 8;
  inline const ::app::terminal::SubscribeLocationResponse& subscribe_location() const;
  inline ::app::terminal::SubscribeLocationResponse* mutable_subscribe_location();
  inline ::app::terminal::SubscribeLocationResponse* release_subscribe_location();
  inline void set_allocated_subscribe_location(::app::terminal::SubscribeLocationResponse* subscribe_location);

  // optional .app.terminal.AlertsResponse alerts = 9;
  inline bool has_alerts() const;
  inline void clear_alerts();
  static const int kAlertsFieldNumber = 9;
  inline const ::app::terminal::AlertsResponse& alerts() const;
  inline ::app::terminal::AlertsResponse* mutable_alerts();
  inline ::app::terminal::AlertsResponse* release_alerts();
  inline void set_allocated_alerts(::app::terminal::AlertsResponse* alerts);

  // optional .app.terminal.AlertResponse alert = 10;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 10;
  inline const ::app::terminal::AlertResponse& alert() const;
  inline ::app::terminal::AlertResponse* mutable_alert();
  inline ::app::terminal::AlertResponse* release_alert();
  inline void set_allocated_alert(::app::terminal::AlertResponse* alert);

  // optional .app.terminal.HistoryAlertsResponse history_alerts = 11;
  inline bool has_history_alerts() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 11;
  inline const ::app::terminal::HistoryAlertsResponse& history_alerts() const;
  inline ::app::terminal::HistoryAlertsResponse* mutable_history_alerts();
  inline ::app::terminal::HistoryAlertsResponse* release_history_alerts();
  inline void set_allocated_history_alerts(::app::terminal::HistoryAlertsResponse* history_alerts);

  // optional .app.terminal.HistoryAlertResponse history_alert = 12;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 12;
  inline const ::app::terminal::HistoryAlertResponse& history_alert() const;
  inline ::app::terminal::HistoryAlertResponse* mutable_history_alert();
  inline ::app::terminal::HistoryAlertResponse* release_history_alert();
  inline void set_allocated_history_alert(::app::terminal::HistoryAlertResponse* history_alert);

  // optional .app.terminal.HistoryAlertMesageResponse history_alert_message = 13;
  inline bool has_history_alert_message() const;
  inline void clear_history_alert_message();
  static const int kHistoryAlertMessageFieldNumber = 13;
  inline const ::app::terminal::HistoryAlertMesageResponse& history_alert_message() const;
  inline ::app::terminal::HistoryAlertMesageResponse* mutable_history_alert_message();
  inline ::app::terminal::HistoryAlertMesageResponse* release_history_alert_message();
  inline void set_allocated_history_alert_message(::app::terminal::HistoryAlertMesageResponse* history_alert_message);

  // @@protoc_insertion_point(class_scope:app.terminal.Response)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_last_response();
  inline void clear_has_last_response();
  inline void set_has_error_describe();
  inline void clear_has_error_describe();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_groups();
  inline void clear_has_groups();
  inline void set_has_group_participants();
  inline void clear_has_group_participants();
  inline void set_has_group_message();
  inline void clear_has_group_message();
  inline void set_has_subscribe_location();
  inline void clear_has_subscribe_location();
  inline void set_has_alerts();
  inline void clear_has_alerts();
  inline void set_has_alert();
  inline void clear_has_alert();
  inline void set_has_history_alerts();
  inline void clear_has_history_alerts();
  inline void set_has_history_alert();
  inline void clear_has_history_alert();
  inline void set_has_history_alert_message();
  inline void clear_has_history_alert_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_describe_;
  ::app::terminal::LoginResponse* login_;
  ::app::terminal::GroupsResponse* groups_;
  ::app::terminal::GroupParticipantsResponse* group_participants_;
  ::app::terminal::MediaMessageResponse* group_message_;
  ::app::terminal::SubscribeLocationResponse* subscribe_location_;
  ::app::terminal::AlertsResponse* alerts_;
  ::app::terminal::AlertResponse* alert_;
  ::app::terminal::HistoryAlertsResponse* history_alerts_;
  ::app::terminal::HistoryAlertResponse* history_alert_;
  ::app::terminal::HistoryAlertMesageResponse* history_alert_message_;
  bool result_;
  bool last_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Indication : public ::google::protobuf::Message {
 public:
  Indication();
  virtual ~Indication();

  Indication(const Indication& from);

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Indication& default_instance();

  void Swap(Indication* other);

  // implements Message ----------------------------------------------

  Indication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Indication& from);
  void MergeFrom(const Indication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.terminal.RegisterStatusNotification register_status = 1;
  inline bool has_register_status() const;
  inline void clear_register_status();
  static const int kRegisterStatusFieldNumber = 1;
  inline const ::app::terminal::RegisterStatusNotification& register_status() const;
  inline ::app::terminal::RegisterStatusNotification* mutable_register_status();
  inline ::app::terminal::RegisterStatusNotification* release_register_status();
  inline void set_allocated_register_status(::app::terminal::RegisterStatusNotification* register_status);

  // optional .app.terminal.JoinedGroupNotification joined_group = 2;
  inline bool has_joined_group() const;
  inline void clear_joined_group();
  static const int kJoinedGroupFieldNumber = 2;
  inline const ::app::terminal::JoinedGroupNotification& joined_group() const;
  inline ::app::terminal::JoinedGroupNotification* mutable_joined_group();
  inline ::app::terminal::JoinedGroupNotification* release_joined_group();
  inline void set_allocated_joined_group(::app::terminal::JoinedGroupNotification* joined_group);

  // optional .app.terminal.LeaveGroupNotification leave_group = 3;
  inline bool has_leave_group() const;
  inline void clear_leave_group();
  static const int kLeaveGroupFieldNumber = 3;
  inline const ::app::terminal::LeaveGroupNotification& leave_group() const;
  inline ::app::terminal::LeaveGroupNotification* mutable_leave_group();
  inline ::app::terminal::LeaveGroupNotification* release_leave_group();
  inline void set_allocated_leave_group(::app::terminal::LeaveGroupNotification* leave_group);

  // optional .app.terminal.OthersJoinedGroupNotification others_joined_group = 4;
  inline bool has_others_joined_group() const;
  inline void clear_others_joined_group();
  static const int kOthersJoinedGroupFieldNumber = 4;
  inline const ::app::terminal::OthersJoinedGroupNotification& others_joined_group() const;
  inline ::app::terminal::OthersJoinedGroupNotification* mutable_others_joined_group();
  inline ::app::terminal::OthersJoinedGroupNotification* release_others_joined_group();
  inline void set_allocated_others_joined_group(::app::terminal::OthersJoinedGroupNotification* others_joined_group);

  // optional .app.terminal.OthersLeaveGroupNotification others_leave_group = 5;
  inline bool has_others_leave_group() const;
  inline void clear_others_leave_group();
  static const int kOthersLeaveGroupFieldNumber = 5;
  inline const ::app::terminal::OthersLeaveGroupNotification& others_leave_group() const;
  inline ::app::terminal::OthersLeaveGroupNotification* mutable_others_leave_group();
  inline ::app::terminal::OthersLeaveGroupNotification* release_others_leave_group();
  inline void set_allocated_others_leave_group(::app::terminal::OthersLeaveGroupNotification* others_leave_group);

  // optional .app.terminal.MediaMessageNotification group_message = 6;
  inline bool has_group_message() const;
  inline void clear_group_message();
  static const int kGroupMessageFieldNumber = 6;
  inline const ::app::terminal::MediaMessageNotification& group_message() const;
  inline ::app::terminal::MediaMessageNotification* mutable_group_message();
  inline ::app::terminal::MediaMessageNotification* release_group_message();
  inline void set_allocated_group_message(::app::terminal::MediaMessageNotification* group_message);

  // optional .app.terminal.SessionStatusNotification session_status = 7;
  inline bool has_session_status() const;
  inline void clear_session_status();
  static const int kSessionStatusFieldNumber = 7;
  inline const ::app::terminal::SessionStatusNotification& session_status() const;
  inline ::app::terminal::SessionStatusNotification* mutable_session_status();
  inline ::app::terminal::SessionStatusNotification* release_session_status();
  inline void set_allocated_session_status(::app::terminal::SessionStatusNotification* session_status);

  // optional .app.terminal.LocationNotification location = 8;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 8;
  inline const ::app::terminal::LocationNotification& location() const;
  inline ::app::terminal::LocationNotification* mutable_location();
  inline ::app::terminal::LocationNotification* release_location();
  inline void set_allocated_location(::app::terminal::LocationNotification* location);

  // optional .app.terminal.AlertCreateNotification alert_create = 9;
  inline bool has_alert_create() const;
  inline void clear_alert_create();
  static const int kAlertCreateFieldNumber = 9;
  inline const ::app::terminal::AlertCreateNotification& alert_create() const;
  inline ::app::terminal::AlertCreateNotification* mutable_alert_create();
  inline ::app::terminal::AlertCreateNotification* release_alert_create();
  inline void set_allocated_alert_create(::app::terminal::AlertCreateNotification* alert_create);

  // optional .app.terminal.AlertModifyNotification alert_modify = 10;
  inline bool has_alert_modify() const;
  inline void clear_alert_modify();
  static const int kAlertModifyFieldNumber = 10;
  inline const ::app::terminal::AlertModifyNotification& alert_modify() const;
  inline ::app::terminal::AlertModifyNotification* mutable_alert_modify();
  inline ::app::terminal::AlertModifyNotification* release_alert_modify();
  inline void set_allocated_alert_modify(::app::terminal::AlertModifyNotification* alert_modify);

  // optional .app.terminal.AlertOveredNotification alert_overed = 11;
  inline bool has_alert_overed() const;
  inline void clear_alert_overed();
  static const int kAlertOveredFieldNumber = 11;
  inline const ::app::terminal::AlertOveredNotification& alert_overed() const;
  inline ::app::terminal::AlertOveredNotification* mutable_alert_overed();
  inline ::app::terminal::AlertOveredNotification* release_alert_overed();
  inline void set_allocated_alert_overed(::app::terminal::AlertOveredNotification* alert_overed);

  // @@protoc_insertion_point(class_scope:app.terminal.Indication)
 private:
  inline void set_has_register_status();
  inline void clear_has_register_status();
  inline void set_has_joined_group();
  inline void clear_has_joined_group();
  inline void set_has_leave_group();
  inline void clear_has_leave_group();
  inline void set_has_others_joined_group();
  inline void clear_has_others_joined_group();
  inline void set_has_others_leave_group();
  inline void clear_has_others_leave_group();
  inline void set_has_group_message();
  inline void clear_has_group_message();
  inline void set_has_session_status();
  inline void clear_has_session_status();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_alert_create();
  inline void clear_has_alert_create();
  inline void set_has_alert_modify();
  inline void clear_has_alert_modify();
  inline void set_has_alert_overed();
  inline void clear_has_alert_overed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::terminal::RegisterStatusNotification* register_status_;
  ::app::terminal::JoinedGroupNotification* joined_group_;
  ::app::terminal::LeaveGroupNotification* leave_group_;
  ::app::terminal::OthersJoinedGroupNotification* others_joined_group_;
  ::app::terminal::OthersLeaveGroupNotification* others_leave_group_;
  ::app::terminal::MediaMessageNotification* group_message_;
  ::app::terminal::SessionStatusNotification* session_status_;
  ::app::terminal::LocationNotification* location_;
  ::app::terminal::AlertCreateNotification* alert_create_;
  ::app::terminal::AlertModifyNotification* alert_modify_;
  ::app::terminal::AlertOveredNotification* alert_overed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Indication* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.terminal.MSG msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::app::terminal::MSG msg_type() const;
  inline void set_msg_type(::app::terminal::MSG value);

  // required fixed32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional fixed32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional .app.terminal.Request request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::app::terminal::Request& request() const;
  inline ::app::terminal::Request* mutable_request();
  inline ::app::terminal::Request* release_request();
  inline void set_allocated_request(::app::terminal::Request* request);

  // optional .app.terminal.Response response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline const ::app::terminal::Response& response() const;
  inline ::app::terminal::Response* mutable_response();
  inline ::app::terminal::Response* release_response();
  inline void set_allocated_response(::app::terminal::Response* response);

  // optional .app.terminal.Indication indication = 6;
  inline bool has_indication() const;
  inline void clear_indication();
  static const int kIndicationFieldNumber = 6;
  inline const ::app::terminal::Indication& indication() const;
  inline ::app::terminal::Indication* mutable_indication();
  inline ::app::terminal::Indication* release_indication();
  inline void set_allocated_indication(::app::terminal::Indication* indication);

  // @@protoc_insertion_point(class_scope:app.terminal.Message)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_indication();
  inline void clear_has_indication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int msg_type_;
  ::google::protobuf::uint32 sequence_;
  ::app::terminal::Request* request_;
  ::app::terminal::Response* response_;
  ::app::terminal::Indication* indication_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eterminal_2eproto();
  friend void protobuf_AssignDesc_app_2eterminal_2eproto();
  friend void protobuf_ShutdownFile_app_2eterminal_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string number = 1;
inline bool LoginRequest::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& LoginRequest::number() const {
  return *number_;
}
inline void LoginRequest::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void LoginRequest::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void LoginRequest::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* LoginRequest::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required string sip_uri = 1;
inline bool LoginResponse::has_sip_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_sip_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_sip_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_sip_uri() {
  if (sip_uri_ != &::google::protobuf::internal::kEmptyString) {
    sip_uri_->clear();
  }
  clear_has_sip_uri();
}
inline const ::std::string& LoginResponse::sip_uri() const {
  return *sip_uri_;
}
inline void LoginResponse::set_sip_uri(const ::std::string& value) {
  set_has_sip_uri();
  if (sip_uri_ == &::google::protobuf::internal::kEmptyString) {
    sip_uri_ = new ::std::string;
  }
  sip_uri_->assign(value);
}
inline void LoginResponse::set_sip_uri(const char* value) {
  set_has_sip_uri();
  if (sip_uri_ == &::google::protobuf::internal::kEmptyString) {
    sip_uri_ = new ::std::string;
  }
  sip_uri_->assign(value);
}
inline void LoginResponse::set_sip_uri(const char* value, size_t size) {
  set_has_sip_uri();
  if (sip_uri_ == &::google::protobuf::internal::kEmptyString) {
    sip_uri_ = new ::std::string;
  }
  sip_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sip_uri() {
  set_has_sip_uri();
  if (sip_uri_ == &::google::protobuf::internal::kEmptyString) {
    sip_uri_ = new ::std::string;
  }
  return sip_uri_;
}
inline ::std::string* LoginResponse::release_sip_uri() {
  clear_has_sip_uri();
  if (sip_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sip_uri_;
    sip_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_sip_uri(::std::string* sip_uri) {
  if (sip_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete sip_uri_;
  }
  if (sip_uri) {
    set_has_sip_uri();
    sip_uri_ = sip_uri;
  } else {
    clear_has_sip_uri();
    sip_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 your_id = 2;
inline bool LoginResponse::has_your_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_your_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_your_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_your_id() {
  your_id_ = 0u;
  clear_has_your_id();
}
inline ::google::protobuf::uint32 LoginResponse::your_id() const {
  return your_id_;
}
inline void LoginResponse::set_your_id(::google::protobuf::uint32 value) {
  set_has_your_id();
  your_id_ = value;
}

// optional bytes display_name = 3;
inline bool LoginResponse::has_display_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_display_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& LoginResponse::display_name() const {
  return *display_name_;
}
inline void LoginResponse::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void LoginResponse::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void LoginResponse::set_display_name(const void* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* LoginResponse::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 talk_priority = 4;
inline bool LoginResponse::has_talk_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_talk_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_talk_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_talk_priority() {
  talk_priority_ = 0u;
  clear_has_talk_priority();
}
inline ::google::protobuf::uint32 LoginResponse::talk_priority() const {
  return talk_priority_;
}
inline void LoginResponse::set_talk_priority(::google::protobuf::uint32 value) {
  set_has_talk_priority();
  talk_priority_ = value;
}

// required .app.terminal.CallPrivilege call_privilege = 5;
inline bool LoginResponse::has_call_privilege() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_call_privilege() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_call_privilege() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_call_privilege() {
  call_privilege_ = 0;
  clear_has_call_privilege();
}
inline ::app::terminal::CallPrivilege LoginResponse::call_privilege() const {
  return static_cast< ::app::terminal::CallPrivilege >(call_privilege_);
}
inline void LoginResponse::set_call_privilege(::app::terminal::CallPrivilege value) {
  assert(::app::terminal::CallPrivilege_IsValid(value));
  set_has_call_privilege();
  call_privilege_ = value;
}

// required .app.terminal.TokenPrivilege token_privilege = 6;
inline bool LoginResponse::has_token_privilege() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_token_privilege() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_token_privilege() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_token_privilege() {
  token_privilege_ = 0;
  clear_has_token_privilege();
}
inline ::app::terminal::TokenPrivilege LoginResponse::token_privilege() const {
  return static_cast< ::app::terminal::TokenPrivilege >(token_privilege_);
}
inline void LoginResponse::set_token_privilege(::app::terminal::TokenPrivilege value) {
  assert(::app::terminal::TokenPrivilege_IsValid(value));
  set_has_token_privilege();
  token_privilege_ = value;
}

// required string number = 7;
inline bool LoginResponse::has_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponse::set_has_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResponse::clear_has_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResponse::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& LoginResponse::number() const {
  return *number_;
}
inline void LoginResponse::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void LoginResponse::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void LoginResponse::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* LoginResponse::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ttl = 8;
inline bool LoginResponse::has_ttl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginResponse::set_has_ttl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginResponse::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginResponse::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 LoginResponse::ttl() const {
  return ttl_;
}
inline void LoginResponse::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// required .app.terminal.GpsReportMode gps_report_mode = 9;
inline bool LoginResponse::has_gps_report_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginResponse::set_has_gps_report_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginResponse::clear_has_gps_report_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginResponse::clear_gps_report_mode() {
  gps_report_mode_ = 0;
  clear_has_gps_report_mode();
}
inline ::app::terminal::GpsReportMode LoginResponse::gps_report_mode() const {
  return static_cast< ::app::terminal::GpsReportMode >(gps_report_mode_);
}
inline void LoginResponse::set_gps_report_mode(::app::terminal::GpsReportMode value) {
  assert(::app::terminal::GpsReportMode_IsValid(value));
  set_has_gps_report_mode();
  gps_report_mode_ = value;
}

// required string upload_address = 10;
inline bool LoginResponse::has_upload_address() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginResponse::set_has_upload_address() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginResponse::clear_has_upload_address() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginResponse::clear_upload_address() {
  if (upload_address_ != &::google::protobuf::internal::kEmptyString) {
    upload_address_->clear();
  }
  clear_has_upload_address();
}
inline const ::std::string& LoginResponse::upload_address() const {
  return *upload_address_;
}
inline void LoginResponse::set_upload_address(const ::std::string& value) {
  set_has_upload_address();
  if (upload_address_ == &::google::protobuf::internal::kEmptyString) {
    upload_address_ = new ::std::string;
  }
  upload_address_->assign(value);
}
inline void LoginResponse::set_upload_address(const char* value) {
  set_has_upload_address();
  if (upload_address_ == &::google::protobuf::internal::kEmptyString) {
    upload_address_ = new ::std::string;
  }
  upload_address_->assign(value);
}
inline void LoginResponse::set_upload_address(const char* value, size_t size) {
  set_has_upload_address();
  if (upload_address_ == &::google::protobuf::internal::kEmptyString) {
    upload_address_ = new ::std::string;
  }
  upload_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_upload_address() {
  set_has_upload_address();
  if (upload_address_ == &::google::protobuf::internal::kEmptyString) {
    upload_address_ = new ::std::string;
  }
  return upload_address_;
}
inline ::std::string* LoginResponse::release_upload_address() {
  clear_has_upload_address();
  if (upload_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = upload_address_;
    upload_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_upload_address(::std::string* upload_address) {
  if (upload_address_ != &::google::protobuf::internal::kEmptyString) {
    delete upload_address_;
  }
  if (upload_address) {
    set_has_upload_address();
    upload_address_ = upload_address;
  } else {
    clear_has_upload_address();
    upload_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterStatusNotification

// required .app.terminal.RegisterStatus status = 1;
inline bool RegisterStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterStatusNotification::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::app::terminal::RegisterStatus RegisterStatusNotification::status() const {
  return static_cast< ::app::terminal::RegisterStatus >(status_);
}
inline void RegisterStatusNotification::set_status(::app::terminal::RegisterStatus value) {
  assert(::app::terminal::RegisterStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Group

// required fixed32 id = 1;
inline bool Group::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Group::id() const {
  return id_;
}
inline void Group::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required bytes name = 2;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  return *name_;
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Group::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Group::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Group::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string number = 3;
inline bool Group::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& Group::number() const {
  return *number_;
}
inline void Group::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Group::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Group::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Group::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* Group::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Group::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupsResponse

// repeated .app.terminal.Group joined_groups = 1;
inline int GroupsResponse::joined_groups_size() const {
  return joined_groups_.size();
}
inline void GroupsResponse::clear_joined_groups() {
  joined_groups_.Clear();
}
inline const ::app::terminal::Group& GroupsResponse::joined_groups(int index) const {
  return joined_groups_.Get(index);
}
inline ::app::terminal::Group* GroupsResponse::mutable_joined_groups(int index) {
  return joined_groups_.Mutable(index);
}
inline ::app::terminal::Group* GroupsResponse::add_joined_groups() {
  return joined_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >&
GroupsResponse::joined_groups() const {
  return joined_groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >*
GroupsResponse::mutable_joined_groups() {
  return &joined_groups_;
}

// repeated .app.terminal.Group unjoin_groups = 2;
inline int GroupsResponse::unjoin_groups_size() const {
  return unjoin_groups_.size();
}
inline void GroupsResponse::clear_unjoin_groups() {
  unjoin_groups_.Clear();
}
inline const ::app::terminal::Group& GroupsResponse::unjoin_groups(int index) const {
  return unjoin_groups_.Get(index);
}
inline ::app::terminal::Group* GroupsResponse::mutable_unjoin_groups(int index) {
  return unjoin_groups_.Mutable(index);
}
inline ::app::terminal::Group* GroupsResponse::add_unjoin_groups() {
  return unjoin_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >&
GroupsResponse::unjoin_groups() const {
  return unjoin_groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Group >*
GroupsResponse::mutable_unjoin_groups() {
  return &unjoin_groups_;
}

// -------------------------------------------------------------------

// Participant

// required fixed32 account_id = 1;
inline bool Participant::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Participant::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Participant::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Participant::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 Participant::account_id() const {
  return account_id_;
}
inline void Participant::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
}

// required bytes account_name = 2;
inline bool Participant::has_account_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Participant::set_has_account_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Participant::clear_has_account_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Participant::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& Participant::account_name() const {
  return *account_name_;
}
inline void Participant::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void Participant::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void Participant::set_account_name(const void* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Participant::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* Participant::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Participant::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 talk_priority = 3;
inline bool Participant::has_talk_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Participant::set_has_talk_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Participant::clear_has_talk_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Participant::clear_talk_priority() {
  talk_priority_ = 0u;
  clear_has_talk_priority();
}
inline ::google::protobuf::uint32 Participant::talk_priority() const {
  return talk_priority_;
}
inline void Participant::set_talk_priority(::google::protobuf::uint32 value) {
  set_has_talk_priority();
  talk_priority_ = value;
}

// optional .app.terminal.CallPrivilege call_privilege = 4;
inline bool Participant::has_call_privilege() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Participant::set_has_call_privilege() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Participant::clear_has_call_privilege() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Participant::clear_call_privilege() {
  call_privilege_ = 0;
  clear_has_call_privilege();
}
inline ::app::terminal::CallPrivilege Participant::call_privilege() const {
  return static_cast< ::app::terminal::CallPrivilege >(call_privilege_);
}
inline void Participant::set_call_privilege(::app::terminal::CallPrivilege value) {
  assert(::app::terminal::CallPrivilege_IsValid(value));
  set_has_call_privilege();
  call_privilege_ = value;
}

// optional .app.terminal.TokenPrivilege token_privilege = 5;
inline bool Participant::has_token_privilege() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Participant::set_has_token_privilege() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Participant::clear_has_token_privilege() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Participant::clear_token_privilege() {
  token_privilege_ = 0;
  clear_has_token_privilege();
}
inline ::app::terminal::TokenPrivilege Participant::token_privilege() const {
  return static_cast< ::app::terminal::TokenPrivilege >(token_privilege_);
}
inline void Participant::set_token_privilege(::app::terminal::TokenPrivilege value) {
  assert(::app::terminal::TokenPrivilege_IsValid(value));
  set_has_token_privilege();
  token_privilege_ = value;
}

// required .app.terminal.SessionStatus status = 6;
inline bool Participant::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Participant::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Participant::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Participant::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::app::terminal::SessionStatus Participant::status() const {
  return static_cast< ::app::terminal::SessionStatus >(status_);
}
inline void Participant::set_status(::app::terminal::SessionStatus value) {
  assert(::app::terminal::SessionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// GroupParticipantsRequest

// required fixed32 group_id = 1;
inline bool GroupParticipantsRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupParticipantsRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupParticipantsRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupParticipantsRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupParticipantsRequest::group_id() const {
  return group_id_;
}
inline void GroupParticipantsRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// GroupParticipantsResponse

// required fixed32 group_id = 1;
inline bool GroupParticipantsResponse::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupParticipantsResponse::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupParticipantsResponse::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupParticipantsResponse::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupParticipantsResponse::group_id() const {
  return group_id_;
}
inline void GroupParticipantsResponse::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated .app.terminal.Participant participants = 2;
inline int GroupParticipantsResponse::participants_size() const {
  return participants_.size();
}
inline void GroupParticipantsResponse::clear_participants() {
  participants_.Clear();
}
inline const ::app::terminal::Participant& GroupParticipantsResponse::participants(int index) const {
  return participants_.Get(index);
}
inline ::app::terminal::Participant* GroupParticipantsResponse::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline ::app::terminal::Participant* GroupParticipantsResponse::add_participants() {
  return participants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >&
GroupParticipantsResponse::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >*
GroupParticipantsResponse::mutable_participants() {
  return &participants_;
}

// -------------------------------------------------------------------

// MediaMessageRequest

// required fixed32 id = 1;
inline bool MediaMessageRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MediaMessageRequest::id() const {
  return id_;
}
inline void MediaMessageRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string from_timestamp = 2;
inline bool MediaMessageRequest::has_from_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMessageRequest::set_has_from_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMessageRequest::clear_has_from_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMessageRequest::clear_from_timestamp() {
  if (from_timestamp_ != &::google::protobuf::internal::kEmptyString) {
    from_timestamp_->clear();
  }
  clear_has_from_timestamp();
}
inline const ::std::string& MediaMessageRequest::from_timestamp() const {
  return *from_timestamp_;
}
inline void MediaMessageRequest::set_from_timestamp(const ::std::string& value) {
  set_has_from_timestamp();
  if (from_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    from_timestamp_ = new ::std::string;
  }
  from_timestamp_->assign(value);
}
inline void MediaMessageRequest::set_from_timestamp(const char* value) {
  set_has_from_timestamp();
  if (from_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    from_timestamp_ = new ::std::string;
  }
  from_timestamp_->assign(value);
}
inline void MediaMessageRequest::set_from_timestamp(const char* value, size_t size) {
  set_has_from_timestamp();
  if (from_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    from_timestamp_ = new ::std::string;
  }
  from_timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessageRequest::mutable_from_timestamp() {
  set_has_from_timestamp();
  if (from_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    from_timestamp_ = new ::std::string;
  }
  return from_timestamp_;
}
inline ::std::string* MediaMessageRequest::release_from_timestamp() {
  clear_has_from_timestamp();
  if (from_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_timestamp_;
    from_timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessageRequest::set_allocated_from_timestamp(::std::string* from_timestamp) {
  if (from_timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete from_timestamp_;
  }
  if (from_timestamp) {
    set_has_from_timestamp();
    from_timestamp_ = from_timestamp;
  } else {
    clear_has_from_timestamp();
    from_timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 from_message_id = 3;
inline bool MediaMessageRequest::has_from_message_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMessageRequest::set_has_from_message_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMessageRequest::clear_has_from_message_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMessageRequest::clear_from_message_id() {
  from_message_id_ = 0u;
  clear_has_from_message_id();
}
inline ::google::protobuf::uint32 MediaMessageRequest::from_message_id() const {
  return from_message_id_;
}
inline void MediaMessageRequest::set_from_message_id(::google::protobuf::uint32 value) {
  set_has_from_message_id();
  from_message_id_ = value;
}

// required fixed32 max_message_count = 4;
inline bool MediaMessageRequest::has_max_message_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaMessageRequest::set_has_max_message_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaMessageRequest::clear_has_max_message_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaMessageRequest::clear_max_message_count() {
  max_message_count_ = 0u;
  clear_has_max_message_count();
}
inline ::google::protobuf::uint32 MediaMessageRequest::max_message_count() const {
  return max_message_count_;
}
inline void MediaMessageRequest::set_max_message_count(::google::protobuf::uint32 value) {
  set_has_max_message_count();
  max_message_count_ = value;
}

// -------------------------------------------------------------------

// MediaMessage

// required fixed32 id = 1;
inline bool MediaMessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessage::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MediaMessage::id() const {
  return id_;
}
inline void MediaMessage::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required bytes sender = 2;
inline bool MediaMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMessage::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& MediaMessage::sender() const {
  return *sender_;
}
inline void MediaMessage::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void MediaMessage::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void MediaMessage::set_sender(const void* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* MediaMessage::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes text = 3;
inline bool MediaMessage::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMessage::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMessage::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMessage::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& MediaMessage::text() const {
  return *text_;
}
inline void MediaMessage::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void MediaMessage::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void MediaMessage::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* MediaMessage::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string picture_uri = 4;
inline bool MediaMessage::has_picture_uri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaMessage::set_has_picture_uri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaMessage::clear_has_picture_uri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaMessage::clear_picture_uri() {
  if (picture_uri_ != &::google::protobuf::internal::kEmptyString) {
    picture_uri_->clear();
  }
  clear_has_picture_uri();
}
inline const ::std::string& MediaMessage::picture_uri() const {
  return *picture_uri_;
}
inline void MediaMessage::set_picture_uri(const ::std::string& value) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(value);
}
inline void MediaMessage::set_picture_uri(const char* value) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(value);
}
inline void MediaMessage::set_picture_uri(const char* value, size_t size) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_picture_uri() {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  return picture_uri_;
}
inline ::std::string* MediaMessage::release_picture_uri() {
  clear_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picture_uri_;
    picture_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_picture_uri(::std::string* picture_uri) {
  if (picture_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete picture_uri_;
  }
  if (picture_uri) {
    set_has_picture_uri();
    picture_uri_ = picture_uri;
  } else {
    clear_has_picture_uri();
    picture_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string audio_uri = 5;
inline bool MediaMessage::has_audio_uri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MediaMessage::set_has_audio_uri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MediaMessage::clear_has_audio_uri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MediaMessage::clear_audio_uri() {
  if (audio_uri_ != &::google::protobuf::internal::kEmptyString) {
    audio_uri_->clear();
  }
  clear_has_audio_uri();
}
inline const ::std::string& MediaMessage::audio_uri() const {
  return *audio_uri_;
}
inline void MediaMessage::set_audio_uri(const ::std::string& value) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(value);
}
inline void MediaMessage::set_audio_uri(const char* value) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(value);
}
inline void MediaMessage::set_audio_uri(const char* value, size_t size) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_audio_uri() {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  return audio_uri_;
}
inline ::std::string* MediaMessage::release_audio_uri() {
  clear_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audio_uri_;
    audio_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_audio_uri(::std::string* audio_uri) {
  if (audio_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete audio_uri_;
  }
  if (audio_uri) {
    set_has_audio_uri();
    audio_uri_ = audio_uri;
  } else {
    clear_has_audio_uri();
    audio_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 audio_length = 6;
inline bool MediaMessage::has_audio_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MediaMessage::set_has_audio_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MediaMessage::clear_has_audio_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MediaMessage::clear_audio_length() {
  audio_length_ = 0u;
  clear_has_audio_length();
}
inline ::google::protobuf::uint32 MediaMessage::audio_length() const {
  return audio_length_;
}
inline void MediaMessage::set_audio_length(::google::protobuf::uint32 value) {
  set_has_audio_length();
  audio_length_ = value;
}

// optional string video_uri = 7;
inline bool MediaMessage::has_video_uri() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MediaMessage::set_has_video_uri() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MediaMessage::clear_has_video_uri() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MediaMessage::clear_video_uri() {
  if (video_uri_ != &::google::protobuf::internal::kEmptyString) {
    video_uri_->clear();
  }
  clear_has_video_uri();
}
inline const ::std::string& MediaMessage::video_uri() const {
  return *video_uri_;
}
inline void MediaMessage::set_video_uri(const ::std::string& value) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(value);
}
inline void MediaMessage::set_video_uri(const char* value) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(value);
}
inline void MediaMessage::set_video_uri(const char* value, size_t size) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_video_uri() {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  return video_uri_;
}
inline ::std::string* MediaMessage::release_video_uri() {
  clear_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_uri_;
    video_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_video_uri(::std::string* video_uri) {
  if (video_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete video_uri_;
  }
  if (video_uri) {
    set_has_video_uri();
    video_uri_ = video_uri;
  } else {
    clear_has_video_uri();
    video_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 video_length = 8;
inline bool MediaMessage::has_video_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MediaMessage::set_has_video_length() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MediaMessage::clear_has_video_length() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MediaMessage::clear_video_length() {
  video_length_ = 0u;
  clear_has_video_length();
}
inline ::google::protobuf::uint32 MediaMessage::video_length() const {
  return video_length_;
}
inline void MediaMessage::set_video_length(::google::protobuf::uint32 value) {
  set_has_video_length();
  video_length_ = value;
}

// optional string timestamp = 9;
inline bool MediaMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MediaMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MediaMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MediaMessage::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& MediaMessage::timestamp() const {
  return *timestamp_;
}
inline void MediaMessage::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void MediaMessage::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void MediaMessage::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessage::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* MediaMessage::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessage::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MediaMessageResponse

// required fixed32 group_id = 1;
inline bool MediaMessageResponse::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageResponse::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageResponse::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageResponse::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 MediaMessageResponse::group_id() const {
  return group_id_;
}
inline void MediaMessageResponse::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated .app.terminal.MediaMessage messages = 2;
inline int MediaMessageResponse::messages_size() const {
  return messages_.size();
}
inline void MediaMessageResponse::clear_messages() {
  messages_.Clear();
}
inline const ::app::terminal::MediaMessage& MediaMessageResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::app::terminal::MediaMessage* MediaMessageResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::app::terminal::MediaMessage* MediaMessageResponse::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >&
MediaMessageResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >*
MediaMessageResponse::mutable_messages() {
  return &messages_;
}

// required fixed32 leave_message_count = 3;
inline bool MediaMessageResponse::has_leave_message_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMessageResponse::set_has_leave_message_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMessageResponse::clear_has_leave_message_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMessageResponse::clear_leave_message_count() {
  leave_message_count_ = 0u;
  clear_has_leave_message_count();
}
inline ::google::protobuf::uint32 MediaMessageResponse::leave_message_count() const {
  return leave_message_count_;
}
inline void MediaMessageResponse::set_leave_message_count(::google::protobuf::uint32 value) {
  set_has_leave_message_count();
  leave_message_count_ = value;
}

// -------------------------------------------------------------------

// JoinedGroupNotification

// required fixed32 group_id = 1;
inline bool JoinedGroupNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinedGroupNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinedGroupNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinedGroupNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 JoinedGroupNotification::group_id() const {
  return group_id_;
}
inline void JoinedGroupNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required bytes group_name = 2;
inline bool JoinedGroupNotification::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinedGroupNotification::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinedGroupNotification::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinedGroupNotification::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& JoinedGroupNotification::group_name() const {
  return *group_name_;
}
inline void JoinedGroupNotification::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void JoinedGroupNotification::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void JoinedGroupNotification::set_group_name(const void* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinedGroupNotification::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* JoinedGroupNotification::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinedGroupNotification::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string group_number = 3;
inline bool JoinedGroupNotification::has_group_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinedGroupNotification::set_has_group_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinedGroupNotification::clear_has_group_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinedGroupNotification::clear_group_number() {
  if (group_number_ != &::google::protobuf::internal::kEmptyString) {
    group_number_->clear();
  }
  clear_has_group_number();
}
inline const ::std::string& JoinedGroupNotification::group_number() const {
  return *group_number_;
}
inline void JoinedGroupNotification::set_group_number(const ::std::string& value) {
  set_has_group_number();
  if (group_number_ == &::google::protobuf::internal::kEmptyString) {
    group_number_ = new ::std::string;
  }
  group_number_->assign(value);
}
inline void JoinedGroupNotification::set_group_number(const char* value) {
  set_has_group_number();
  if (group_number_ == &::google::protobuf::internal::kEmptyString) {
    group_number_ = new ::std::string;
  }
  group_number_->assign(value);
}
inline void JoinedGroupNotification::set_group_number(const char* value, size_t size) {
  set_has_group_number();
  if (group_number_ == &::google::protobuf::internal::kEmptyString) {
    group_number_ = new ::std::string;
  }
  group_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinedGroupNotification::mutable_group_number() {
  set_has_group_number();
  if (group_number_ == &::google::protobuf::internal::kEmptyString) {
    group_number_ = new ::std::string;
  }
  return group_number_;
}
inline ::std::string* JoinedGroupNotification::release_group_number() {
  clear_has_group_number();
  if (group_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_number_;
    group_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinedGroupNotification::set_allocated_group_number(::std::string* group_number) {
  if (group_number_ != &::google::protobuf::internal::kEmptyString) {
    delete group_number_;
  }
  if (group_number) {
    set_has_group_number();
    group_number_ = group_number;
  } else {
    clear_has_group_number();
    group_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 talk_priority = 4;
inline bool JoinedGroupNotification::has_talk_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinedGroupNotification::set_has_talk_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinedGroupNotification::clear_has_talk_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinedGroupNotification::clear_talk_priority() {
  talk_priority_ = 0u;
  clear_has_talk_priority();
}
inline ::google::protobuf::uint32 JoinedGroupNotification::talk_priority() const {
  return talk_priority_;
}
inline void JoinedGroupNotification::set_talk_priority(::google::protobuf::uint32 value) {
  set_has_talk_priority();
  talk_priority_ = value;
}

// required .app.terminal.CallPrivilege call_privilege = 5;
inline bool JoinedGroupNotification::has_call_privilege() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JoinedGroupNotification::set_has_call_privilege() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JoinedGroupNotification::clear_has_call_privilege() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JoinedGroupNotification::clear_call_privilege() {
  call_privilege_ = 0;
  clear_has_call_privilege();
}
inline ::app::terminal::CallPrivilege JoinedGroupNotification::call_privilege() const {
  return static_cast< ::app::terminal::CallPrivilege >(call_privilege_);
}
inline void JoinedGroupNotification::set_call_privilege(::app::terminal::CallPrivilege value) {
  assert(::app::terminal::CallPrivilege_IsValid(value));
  set_has_call_privilege();
  call_privilege_ = value;
}

// required .app.terminal.TokenPrivilege token_privilege = 6;
inline bool JoinedGroupNotification::has_token_privilege() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JoinedGroupNotification::set_has_token_privilege() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JoinedGroupNotification::clear_has_token_privilege() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JoinedGroupNotification::clear_token_privilege() {
  token_privilege_ = 0;
  clear_has_token_privilege();
}
inline ::app::terminal::TokenPrivilege JoinedGroupNotification::token_privilege() const {
  return static_cast< ::app::terminal::TokenPrivilege >(token_privilege_);
}
inline void JoinedGroupNotification::set_token_privilege(::app::terminal::TokenPrivilege value) {
  assert(::app::terminal::TokenPrivilege_IsValid(value));
  set_has_token_privilege();
  token_privilege_ = value;
}

// -------------------------------------------------------------------

// LeaveGroupNotification

// required fixed32 group_id = 1;
inline bool LeaveGroupNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroupNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroupNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroupNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 LeaveGroupNotification::group_id() const {
  return group_id_;
}
inline void LeaveGroupNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// OthersJoinedGroupNotification

// required fixed32 group_id = 1;
inline bool OthersJoinedGroupNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OthersJoinedGroupNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OthersJoinedGroupNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OthersJoinedGroupNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 OthersJoinedGroupNotification::group_id() const {
  return group_id_;
}
inline void OthersJoinedGroupNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated .app.terminal.Participant participants = 2;
inline int OthersJoinedGroupNotification::participants_size() const {
  return participants_.size();
}
inline void OthersJoinedGroupNotification::clear_participants() {
  participants_.Clear();
}
inline const ::app::terminal::Participant& OthersJoinedGroupNotification::participants(int index) const {
  return participants_.Get(index);
}
inline ::app::terminal::Participant* OthersJoinedGroupNotification::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline ::app::terminal::Participant* OthersJoinedGroupNotification::add_participants() {
  return participants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >&
OthersJoinedGroupNotification::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Participant >*
OthersJoinedGroupNotification::mutable_participants() {
  return &participants_;
}

// -------------------------------------------------------------------

// OthersLeaveGroupNotification

// required fixed32 group_id = 1;
inline bool OthersLeaveGroupNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OthersLeaveGroupNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OthersLeaveGroupNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OthersLeaveGroupNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 OthersLeaveGroupNotification::group_id() const {
  return group_id_;
}
inline void OthersLeaveGroupNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// repeated fixed32 account_ids = 2;
inline int OthersLeaveGroupNotification::account_ids_size() const {
  return account_ids_.size();
}
inline void OthersLeaveGroupNotification::clear_account_ids() {
  account_ids_.Clear();
}
inline ::google::protobuf::uint32 OthersLeaveGroupNotification::account_ids(int index) const {
  return account_ids_.Get(index);
}
inline void OthersLeaveGroupNotification::set_account_ids(int index, ::google::protobuf::uint32 value) {
  account_ids_.Set(index, value);
}
inline void OthersLeaveGroupNotification::add_account_ids(::google::protobuf::uint32 value) {
  account_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OthersLeaveGroupNotification::account_ids() const {
  return account_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OthersLeaveGroupNotification::mutable_account_ids() {
  return &account_ids_;
}

// -------------------------------------------------------------------

// MediaMessageNotification

// required fixed32 group_id = 1;
inline bool MediaMessageNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 MediaMessageNotification::group_id() const {
  return group_id_;
}
inline void MediaMessageNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required .app.terminal.MediaMessage msg = 2;
inline bool MediaMessageNotification::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMessageNotification::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMessageNotification::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMessageNotification::clear_msg() {
  if (msg_ != NULL) msg_->::app::terminal::MediaMessage::Clear();
  clear_has_msg();
}
inline const ::app::terminal::MediaMessage& MediaMessageNotification::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::app::terminal::MediaMessage* MediaMessageNotification::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::app::terminal::MediaMessage;
  return msg_;
}
inline ::app::terminal::MediaMessage* MediaMessageNotification::release_msg() {
  clear_has_msg();
  ::app::terminal::MediaMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void MediaMessageNotification::set_allocated_msg(::app::terminal::MediaMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// JoinGroupRequest

// required fixed32 group_id = 1;
inline bool JoinGroupRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroupRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroupRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroupRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 JoinGroupRequest::group_id() const {
  return group_id_;
}
inline void JoinGroupRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// ConnectGroupRequest

// required fixed32 group_id = 1;
inline bool ConnectGroupRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectGroupRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectGroupRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectGroupRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ConnectGroupRequest::group_id() const {
  return group_id_;
}
inline void ConnectGroupRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// SessionStatusNotification

// required fixed32 group_id = 1;
inline bool SessionStatusNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStatusNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStatusNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStatusNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 SessionStatusNotification::group_id() const {
  return group_id_;
}
inline void SessionStatusNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// required fixed32 account_id = 2;
inline bool SessionStatusNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStatusNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStatusNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStatusNotification::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 SessionStatusNotification::account_id() const {
  return account_id_;
}
inline void SessionStatusNotification::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
}

// required .app.terminal.MediaMessage status = 3;
inline bool SessionStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionStatusNotification::clear_status() {
  if (status_ != NULL) status_->::app::terminal::MediaMessage::Clear();
  clear_has_status();
}
inline const ::app::terminal::MediaMessage& SessionStatusNotification::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::app::terminal::MediaMessage* SessionStatusNotification::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::app::terminal::MediaMessage;
  return status_;
}
inline ::app::terminal::MediaMessage* SessionStatusNotification::release_status() {
  clear_has_status();
  ::app::terminal::MediaMessage* temp = status_;
  status_ = NULL;
  return temp;
}
inline void SessionStatusNotification::set_allocated_status(::app::terminal::MediaMessage* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// SpeakRequest

// required fixed32 group_id = 1;
inline bool SpeakRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeakRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeakRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeakRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 SpeakRequest::group_id() const {
  return group_id_;
}
inline void SpeakRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// JoinSessionRequest

// required fixed32 group_id = 1;
inline bool JoinSessionRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 JoinSessionRequest::group_id() const {
  return group_id_;
}
inline void JoinSessionRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// LeaveSessionRequest

// required fixed32 group_id = 1;
inline bool LeaveSessionRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveSessionRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveSessionRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveSessionRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 LeaveSessionRequest::group_id() const {
  return group_id_;
}
inline void LeaveSessionRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// ReleaseTokenRequest

// required fixed32 group_id = 1;
inline bool ReleaseTokenRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseTokenRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseTokenRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseTokenRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ReleaseTokenRequest::group_id() const {
  return group_id_;
}
inline void ReleaseTokenRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// AppointSpeakRequest

// required fixed32 group_id = 1;
inline bool AppointSpeakRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppointSpeakRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppointSpeakRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppointSpeakRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 AppointSpeakRequest::group_id() const {
  return group_id_;
}
inline void AppointSpeakRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// SendMessageRequest

// required fixed32 group_id = 1;
inline bool SendMessageRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMessageRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMessageRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMessageRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 SendMessageRequest::group_id() const {
  return group_id_;
}
inline void SendMessageRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional bytes text = 2;
inline bool SendMessageRequest::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendMessageRequest::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendMessageRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendMessageRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SendMessageRequest::text() const {
  return *text_;
}
inline void SendMessageRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SendMessageRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SendMessageRequest::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SendMessageRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessageRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string picture_uri = 3;
inline bool SendMessageRequest::has_picture_uri() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendMessageRequest::set_has_picture_uri() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendMessageRequest::clear_has_picture_uri() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendMessageRequest::clear_picture_uri() {
  if (picture_uri_ != &::google::protobuf::internal::kEmptyString) {
    picture_uri_->clear();
  }
  clear_has_picture_uri();
}
inline const ::std::string& SendMessageRequest::picture_uri() const {
  return *picture_uri_;
}
inline void SendMessageRequest::set_picture_uri(const ::std::string& value) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(value);
}
inline void SendMessageRequest::set_picture_uri(const char* value) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(value);
}
inline void SendMessageRequest::set_picture_uri(const char* value, size_t size) {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  picture_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageRequest::mutable_picture_uri() {
  set_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    picture_uri_ = new ::std::string;
  }
  return picture_uri_;
}
inline ::std::string* SendMessageRequest::release_picture_uri() {
  clear_has_picture_uri();
  if (picture_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picture_uri_;
    picture_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessageRequest::set_allocated_picture_uri(::std::string* picture_uri) {
  if (picture_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete picture_uri_;
  }
  if (picture_uri) {
    set_has_picture_uri();
    picture_uri_ = picture_uri;
  } else {
    clear_has_picture_uri();
    picture_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string audio_uri = 4;
inline bool SendMessageRequest::has_audio_uri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendMessageRequest::set_has_audio_uri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendMessageRequest::clear_has_audio_uri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendMessageRequest::clear_audio_uri() {
  if (audio_uri_ != &::google::protobuf::internal::kEmptyString) {
    audio_uri_->clear();
  }
  clear_has_audio_uri();
}
inline const ::std::string& SendMessageRequest::audio_uri() const {
  return *audio_uri_;
}
inline void SendMessageRequest::set_audio_uri(const ::std::string& value) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(value);
}
inline void SendMessageRequest::set_audio_uri(const char* value) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(value);
}
inline void SendMessageRequest::set_audio_uri(const char* value, size_t size) {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  audio_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageRequest::mutable_audio_uri() {
  set_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    audio_uri_ = new ::std::string;
  }
  return audio_uri_;
}
inline ::std::string* SendMessageRequest::release_audio_uri() {
  clear_has_audio_uri();
  if (audio_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audio_uri_;
    audio_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessageRequest::set_allocated_audio_uri(::std::string* audio_uri) {
  if (audio_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete audio_uri_;
  }
  if (audio_uri) {
    set_has_audio_uri();
    audio_uri_ = audio_uri;
  } else {
    clear_has_audio_uri();
    audio_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 audio_length = 5;
inline bool SendMessageRequest::has_audio_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendMessageRequest::set_has_audio_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendMessageRequest::clear_has_audio_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendMessageRequest::clear_audio_length() {
  audio_length_ = 0u;
  clear_has_audio_length();
}
inline ::google::protobuf::uint32 SendMessageRequest::audio_length() const {
  return audio_length_;
}
inline void SendMessageRequest::set_audio_length(::google::protobuf::uint32 value) {
  set_has_audio_length();
  audio_length_ = value;
}

// optional string video_uri = 6;
inline bool SendMessageRequest::has_video_uri() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendMessageRequest::set_has_video_uri() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendMessageRequest::clear_has_video_uri() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendMessageRequest::clear_video_uri() {
  if (video_uri_ != &::google::protobuf::internal::kEmptyString) {
    video_uri_->clear();
  }
  clear_has_video_uri();
}
inline const ::std::string& SendMessageRequest::video_uri() const {
  return *video_uri_;
}
inline void SendMessageRequest::set_video_uri(const ::std::string& value) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(value);
}
inline void SendMessageRequest::set_video_uri(const char* value) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(value);
}
inline void SendMessageRequest::set_video_uri(const char* value, size_t size) {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  video_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendMessageRequest::mutable_video_uri() {
  set_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    video_uri_ = new ::std::string;
  }
  return video_uri_;
}
inline ::std::string* SendMessageRequest::release_video_uri() {
  clear_has_video_uri();
  if (video_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_uri_;
    video_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendMessageRequest::set_allocated_video_uri(::std::string* video_uri) {
  if (video_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete video_uri_;
  }
  if (video_uri) {
    set_has_video_uri();
    video_uri_ = video_uri;
  } else {
    clear_has_video_uri();
    video_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 video_length = 7;
inline bool SendMessageRequest::has_video_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendMessageRequest::set_has_video_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendMessageRequest::clear_has_video_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendMessageRequest::clear_video_length() {
  video_length_ = 0u;
  clear_has_video_length();
}
inline ::google::protobuf::uint32 SendMessageRequest::video_length() const {
  return video_length_;
}
inline void SendMessageRequest::set_video_length(::google::protobuf::uint32 value) {
  set_has_video_length();
  video_length_ = value;
}

// -------------------------------------------------------------------

// SubscribeLocationRequest

// required bool subscribing = 1;
inline bool SubscribeLocationRequest::has_subscribing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeLocationRequest::set_has_subscribing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeLocationRequest::clear_has_subscribing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeLocationRequest::clear_subscribing() {
  subscribing_ = false;
  clear_has_subscribing();
}
inline bool SubscribeLocationRequest::subscribing() const {
  return subscribing_;
}
inline void SubscribeLocationRequest::set_subscribing(bool value) {
  set_has_subscribing();
  subscribing_ = value;
}

// required fixed32 ttl = 2;
inline bool SubscribeLocationRequest::has_ttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeLocationRequest::set_has_ttl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeLocationRequest::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeLocationRequest::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 SubscribeLocationRequest::ttl() const {
  return ttl_;
}
inline void SubscribeLocationRequest::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// SubscribeLocationResponse

// required double longtitude = 1;
inline bool SubscribeLocationResponse::has_longtitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeLocationResponse::set_has_longtitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeLocationResponse::clear_has_longtitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeLocationResponse::clear_longtitude() {
  longtitude_ = 0;
  clear_has_longtitude();
}
inline double SubscribeLocationResponse::longtitude() const {
  return longtitude_;
}
inline void SubscribeLocationResponse::set_longtitude(double value) {
  set_has_longtitude();
  longtitude_ = value;
}

// required double latitude = 2;
inline bool SubscribeLocationResponse::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeLocationResponse::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeLocationResponse::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeLocationResponse::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double SubscribeLocationResponse::latitude() const {
  return latitude_;
}
inline void SubscribeLocationResponse::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// required fixed32 acquire_location_time = 3;
inline bool SubscribeLocationResponse::has_acquire_location_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeLocationResponse::set_has_acquire_location_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeLocationResponse::clear_has_acquire_location_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeLocationResponse::clear_acquire_location_time() {
  acquire_location_time_ = 0u;
  clear_has_acquire_location_time();
}
inline ::google::protobuf::uint32 SubscribeLocationResponse::acquire_location_time() const {
  return acquire_location_time_;
}
inline void SubscribeLocationResponse::set_acquire_location_time(::google::protobuf::uint32 value) {
  set_has_acquire_location_time();
  acquire_location_time_ = value;
}

// -------------------------------------------------------------------

// LocationNotification

// required double longtitude = 1;
inline bool LocationNotification::has_longtitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationNotification::set_has_longtitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationNotification::clear_has_longtitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationNotification::clear_longtitude() {
  longtitude_ = 0;
  clear_has_longtitude();
}
inline double LocationNotification::longtitude() const {
  return longtitude_;
}
inline void LocationNotification::set_longtitude(double value) {
  set_has_longtitude();
  longtitude_ = value;
}

// required double latitude = 2;
inline bool LocationNotification::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationNotification::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationNotification::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationNotification::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double LocationNotification::latitude() const {
  return latitude_;
}
inline void LocationNotification::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional fixed32 acquire_location_time = 3;
inline bool LocationNotification::has_acquire_location_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationNotification::set_has_acquire_location_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationNotification::clear_has_acquire_location_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationNotification::clear_acquire_location_time() {
  acquire_location_time_ = 0u;
  clear_has_acquire_location_time();
}
inline ::google::protobuf::uint32 LocationNotification::acquire_location_time() const {
  return acquire_location_time_;
}
inline void LocationNotification::set_acquire_location_time(::google::protobuf::uint32 value) {
  set_has_acquire_location_time();
  acquire_location_time_ = value;
}

// -------------------------------------------------------------------

// Alert

// required fixed32 id = 1;
inline bool Alert::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Alert::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Alert::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Alert::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Alert::id() const {
  return id_;
}
inline void Alert::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required bytes name = 2;
inline bool Alert::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Alert::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Alert::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Alert::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Alert::name() const {
  return *name_;
}
inline void Alert::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Alert::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Alert::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Alert::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 group_id = 3;
inline bool Alert::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alert::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alert::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alert::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 Alert::group_id() const {
  return group_id_;
}
inline void Alert::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional .app.terminal.AlertLevel level = 4;
inline bool Alert::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alert::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alert::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alert::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::app::terminal::AlertLevel Alert::level() const {
  return static_cast< ::app::terminal::AlertLevel >(level_);
}
inline void Alert::set_level(::app::terminal::AlertLevel value) {
  assert(::app::terminal::AlertLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// optional bytes describe = 5;
inline bool Alert::has_describe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alert::set_has_describe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alert::clear_has_describe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alert::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& Alert::describe() const {
  return *describe_;
}
inline void Alert::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void Alert::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void Alert::set_describe(const void* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* Alert::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alarm_time = 6;
inline bool Alert::has_alarm_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alert::set_has_alarm_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alert::clear_has_alarm_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alert::clear_alarm_time() {
  if (alarm_time_ != &::google::protobuf::internal::kEmptyString) {
    alarm_time_->clear();
  }
  clear_has_alarm_time();
}
inline const ::std::string& Alert::alarm_time() const {
  return *alarm_time_;
}
inline void Alert::set_alarm_time(const ::std::string& value) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(value);
}
inline void Alert::set_alarm_time(const char* value) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(value);
}
inline void Alert::set_alarm_time(const char* value, size_t size) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_alarm_time() {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  return alarm_time_;
}
inline ::std::string* Alert::release_alarm_time() {
  clear_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarm_time_;
    alarm_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_alarm_time(::std::string* alarm_time) {
  if (alarm_time_ != &::google::protobuf::internal::kEmptyString) {
    delete alarm_time_;
  }
  if (alarm_time) {
    set_has_alarm_time();
    alarm_time_ = alarm_time;
  } else {
    clear_has_alarm_time();
    alarm_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 use_cars = 7;
inline bool Alert::has_use_cars() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Alert::set_has_use_cars() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Alert::clear_has_use_cars() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Alert::clear_use_cars() {
  use_cars_ = 0u;
  clear_has_use_cars();
}
inline ::google::protobuf::uint32 Alert::use_cars() const {
  return use_cars_;
}
inline void Alert::set_use_cars(::google::protobuf::uint32 value) {
  set_has_use_cars();
  use_cars_ = value;
}

// optional string create_time = 8;
inline bool Alert::has_create_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Alert::set_has_create_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Alert::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Alert::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& Alert::create_time() const {
  return *create_time_;
}
inline void Alert::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void Alert::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void Alert::set_create_time(const char* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* Alert::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AlertsResponse

// repeated .app.terminal.Alert alerts = 4;
inline int AlertsResponse::alerts_size() const {
  return alerts_.size();
}
inline void AlertsResponse::clear_alerts() {
  alerts_.Clear();
}
inline const ::app::terminal::Alert& AlertsResponse::alerts(int index) const {
  return alerts_.Get(index);
}
inline ::app::terminal::Alert* AlertsResponse::mutable_alerts(int index) {
  return alerts_.Mutable(index);
}
inline ::app::terminal::Alert* AlertsResponse::add_alerts() {
  return alerts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::Alert >&
AlertsResponse::alerts() const {
  return alerts_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::Alert >*
AlertsResponse::mutable_alerts() {
  return &alerts_;
}

// -------------------------------------------------------------------

// AlertRequest

// required fixed32 alert_id = 1;
inline bool AlertRequest::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertRequest::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertRequest::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertRequest::clear_alert_id() {
  alert_id_ = 0u;
  clear_has_alert_id();
}
inline ::google::protobuf::uint32 AlertRequest::alert_id() const {
  return alert_id_;
}
inline void AlertRequest::set_alert_id(::google::protobuf::uint32 value) {
  set_has_alert_id();
  alert_id_ = value;
}

// -------------------------------------------------------------------

// AlertResponse

// required .app.terminal.Alert alert = 1;
inline bool AlertResponse::has_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertResponse::set_has_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertResponse::clear_has_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertResponse::clear_alert() {
  if (alert_ != NULL) alert_->::app::terminal::Alert::Clear();
  clear_has_alert();
}
inline const ::app::terminal::Alert& AlertResponse::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::app::terminal::Alert* AlertResponse::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::app::terminal::Alert;
  return alert_;
}
inline ::app::terminal::Alert* AlertResponse::release_alert() {
  clear_has_alert();
  ::app::terminal::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void AlertResponse::set_allocated_alert(::app::terminal::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// -------------------------------------------------------------------

// AlertCreateNotification

// required fixed32 alert_id = 1;
inline bool AlertCreateNotification::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertCreateNotification::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertCreateNotification::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertCreateNotification::clear_alert_id() {
  alert_id_ = 0u;
  clear_has_alert_id();
}
inline ::google::protobuf::uint32 AlertCreateNotification::alert_id() const {
  return alert_id_;
}
inline void AlertCreateNotification::set_alert_id(::google::protobuf::uint32 value) {
  set_has_alert_id();
  alert_id_ = value;
}

// required bytes name = 2;
inline bool AlertCreateNotification::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertCreateNotification::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertCreateNotification::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertCreateNotification::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AlertCreateNotification::name() const {
  return *name_;
}
inline void AlertCreateNotification::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AlertCreateNotification::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AlertCreateNotification::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlertCreateNotification::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AlertCreateNotification::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlertCreateNotification::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 group_id = 3;
inline bool AlertCreateNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlertCreateNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlertCreateNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlertCreateNotification::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 AlertCreateNotification::group_id() const {
  return group_id_;
}
inline void AlertCreateNotification::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
}

// -------------------------------------------------------------------

// AlertModifyNotification

// required .app.terminal.Alert alert = 1;
inline bool AlertModifyNotification::has_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertModifyNotification::set_has_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertModifyNotification::clear_has_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertModifyNotification::clear_alert() {
  if (alert_ != NULL) alert_->::app::terminal::Alert::Clear();
  clear_has_alert();
}
inline const ::app::terminal::Alert& AlertModifyNotification::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::app::terminal::Alert* AlertModifyNotification::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::app::terminal::Alert;
  return alert_;
}
inline ::app::terminal::Alert* AlertModifyNotification::release_alert() {
  clear_has_alert();
  ::app::terminal::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void AlertModifyNotification::set_allocated_alert(::app::terminal::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// -------------------------------------------------------------------

// AlertOveredNotification

// required fixed32 alert_id = 1;
inline bool AlertOveredNotification::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertOveredNotification::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertOveredNotification::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertOveredNotification::clear_alert_id() {
  alert_id_ = 0u;
  clear_has_alert_id();
}
inline ::google::protobuf::uint32 AlertOveredNotification::alert_id() const {
  return alert_id_;
}
inline void AlertOveredNotification::set_alert_id(::google::protobuf::uint32 value) {
  set_has_alert_id();
  alert_id_ = value;
}

// -------------------------------------------------------------------

// HistoryAlertsRequest

// optional bytes name = 1;
inline bool HistoryAlertsRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertsRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertsRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertsRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HistoryAlertsRequest::name() const {
  return *name_;
}
inline void HistoryAlertsRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlertsRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlertsRequest::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HistoryAlertsRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time_from = 2;
inline bool HistoryAlertsRequest::has_create_time_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryAlertsRequest::set_has_create_time_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryAlertsRequest::clear_has_create_time_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryAlertsRequest::clear_create_time_from() {
  if (create_time_from_ != &::google::protobuf::internal::kEmptyString) {
    create_time_from_->clear();
  }
  clear_has_create_time_from();
}
inline const ::std::string& HistoryAlertsRequest::create_time_from() const {
  return *create_time_from_;
}
inline void HistoryAlertsRequest::set_create_time_from(const ::std::string& value) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_from(const char* value) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_from(const char* value, size_t size) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_create_time_from() {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  return create_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_create_time_from() {
  clear_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_from_;
    create_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_create_time_from(::std::string* create_time_from) {
  if (create_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_from_;
  }
  if (create_time_from) {
    set_has_create_time_from();
    create_time_from_ = create_time_from;
  } else {
    clear_has_create_time_from();
    create_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time_to = 3;
inline bool HistoryAlertsRequest::has_create_time_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertsRequest::set_has_create_time_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertsRequest::clear_has_create_time_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertsRequest::clear_create_time_to() {
  if (create_time_to_ != &::google::protobuf::internal::kEmptyString) {
    create_time_to_->clear();
  }
  clear_has_create_time_to();
}
inline const ::std::string& HistoryAlertsRequest::create_time_to() const {
  return *create_time_to_;
}
inline void HistoryAlertsRequest::set_create_time_to(const ::std::string& value) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_to(const char* value) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_to(const char* value, size_t size) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_create_time_to() {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  return create_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_create_time_to() {
  clear_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_to_;
    create_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_create_time_to(::std::string* create_time_to) {
  if (create_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_to_;
  }
  if (create_time_to) {
    set_has_create_time_to();
    create_time_to_ = create_time_to;
  } else {
    clear_has_create_time_to();
    create_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alram_time_from = 4;
inline bool HistoryAlertsRequest::has_alram_time_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryAlertsRequest::set_has_alram_time_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryAlertsRequest::clear_has_alram_time_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryAlertsRequest::clear_alram_time_from() {
  if (alram_time_from_ != &::google::protobuf::internal::kEmptyString) {
    alram_time_from_->clear();
  }
  clear_has_alram_time_from();
}
inline const ::std::string& HistoryAlertsRequest::alram_time_from() const {
  return *alram_time_from_;
}
inline void HistoryAlertsRequest::set_alram_time_from(const ::std::string& value) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_from(const char* value) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_from(const char* value, size_t size) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_alram_time_from() {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  return alram_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_alram_time_from() {
  clear_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alram_time_from_;
    alram_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_alram_time_from(::std::string* alram_time_from) {
  if (alram_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete alram_time_from_;
  }
  if (alram_time_from) {
    set_has_alram_time_from();
    alram_time_from_ = alram_time_from;
  } else {
    clear_has_alram_time_from();
    alram_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alram_time_to = 5;
inline bool HistoryAlertsRequest::has_alram_time_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryAlertsRequest::set_has_alram_time_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryAlertsRequest::clear_has_alram_time_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryAlertsRequest::clear_alram_time_to() {
  if (alram_time_to_ != &::google::protobuf::internal::kEmptyString) {
    alram_time_to_->clear();
  }
  clear_has_alram_time_to();
}
inline const ::std::string& HistoryAlertsRequest::alram_time_to() const {
  return *alram_time_to_;
}
inline void HistoryAlertsRequest::set_alram_time_to(const ::std::string& value) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_to(const char* value) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_to(const char* value, size_t size) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_alram_time_to() {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  return alram_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_alram_time_to() {
  clear_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alram_time_to_;
    alram_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_alram_time_to(::std::string* alram_time_to) {
  if (alram_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete alram_time_to_;
  }
  if (alram_time_to) {
    set_has_alram_time_to();
    alram_time_to_ = alram_time_to;
  } else {
    clear_has_alram_time_to();
    alram_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string over_time_from = 6;
inline bool HistoryAlertsRequest::has_over_time_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoryAlertsRequest::set_has_over_time_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoryAlertsRequest::clear_has_over_time_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoryAlertsRequest::clear_over_time_from() {
  if (over_time_from_ != &::google::protobuf::internal::kEmptyString) {
    over_time_from_->clear();
  }
  clear_has_over_time_from();
}
inline const ::std::string& HistoryAlertsRequest::over_time_from() const {
  return *over_time_from_;
}
inline void HistoryAlertsRequest::set_over_time_from(const ::std::string& value) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_from(const char* value) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_from(const char* value, size_t size) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_over_time_from() {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  return over_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_over_time_from() {
  clear_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = over_time_from_;
    over_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_over_time_from(::std::string* over_time_from) {
  if (over_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete over_time_from_;
  }
  if (over_time_from) {
    set_has_over_time_from();
    over_time_from_ = over_time_from;
  } else {
    clear_has_over_time_from();
    over_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string over_time_to = 7;
inline bool HistoryAlertsRequest::has_over_time_to() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoryAlertsRequest::set_has_over_time_to() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoryAlertsRequest::clear_has_over_time_to() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoryAlertsRequest::clear_over_time_to() {
  if (over_time_to_ != &::google::protobuf::internal::kEmptyString) {
    over_time_to_->clear();
  }
  clear_has_over_time_to();
}
inline const ::std::string& HistoryAlertsRequest::over_time_to() const {
  return *over_time_to_;
}
inline void HistoryAlertsRequest::set_over_time_to(const ::std::string& value) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_to(const char* value) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_to(const char* value, size_t size) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_over_time_to() {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  return over_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_over_time_to() {
  clear_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = over_time_to_;
    over_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_over_time_to(::std::string* over_time_to) {
  if (over_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete over_time_to_;
  }
  if (over_time_to) {
    set_has_over_time_to();
    over_time_to_ = over_time_to;
  } else {
    clear_has_over_time_to();
    over_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HistoryAlert

// required fixed32 id = 1;
inline bool HistoryAlert::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlert::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlert::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlert::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HistoryAlert::id() const {
  return id_;
}
inline void HistoryAlert::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required bytes name = 2;
inline bool HistoryAlert::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryAlert::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryAlert::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryAlert::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HistoryAlert::name() const {
  return *name_;
}
inline void HistoryAlert::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlert::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlert::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlert::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HistoryAlert::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlert::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .app.terminal.AlertLevel level = 3;
inline bool HistoryAlert::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlert::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlert::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlert::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::app::terminal::AlertLevel HistoryAlert::level() const {
  return static_cast< ::app::terminal::AlertLevel >(level_);
}
inline void HistoryAlert::set_level(::app::terminal::AlertLevel value) {
  assert(::app::terminal::AlertLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// optional bytes describe = 4;
inline bool HistoryAlert::has_describe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryAlert::set_has_describe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryAlert::clear_has_describe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryAlert::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& HistoryAlert::describe() const {
  return *describe_;
}
inline void HistoryAlert::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void HistoryAlert::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void HistoryAlert::set_describe(const void* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlert::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* HistoryAlert::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlert::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alarm_time = 5;
inline bool HistoryAlert::has_alarm_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryAlert::set_has_alarm_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryAlert::clear_has_alarm_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryAlert::clear_alarm_time() {
  if (alarm_time_ != &::google::protobuf::internal::kEmptyString) {
    alarm_time_->clear();
  }
  clear_has_alarm_time();
}
inline const ::std::string& HistoryAlert::alarm_time() const {
  return *alarm_time_;
}
inline void HistoryAlert::set_alarm_time(const ::std::string& value) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(value);
}
inline void HistoryAlert::set_alarm_time(const char* value) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(value);
}
inline void HistoryAlert::set_alarm_time(const char* value, size_t size) {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  alarm_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlert::mutable_alarm_time() {
  set_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    alarm_time_ = new ::std::string;
  }
  return alarm_time_;
}
inline ::std::string* HistoryAlert::release_alarm_time() {
  clear_has_alarm_time();
  if (alarm_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alarm_time_;
    alarm_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlert::set_allocated_alarm_time(::std::string* alarm_time) {
  if (alarm_time_ != &::google::protobuf::internal::kEmptyString) {
    delete alarm_time_;
  }
  if (alarm_time) {
    set_has_alarm_time();
    alarm_time_ = alarm_time;
  } else {
    clear_has_alarm_time();
    alarm_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 use_cars = 6;
inline bool HistoryAlert::has_use_cars() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoryAlert::set_has_use_cars() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoryAlert::clear_has_use_cars() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoryAlert::clear_use_cars() {
  use_cars_ = 0u;
  clear_has_use_cars();
}
inline ::google::protobuf::uint32 HistoryAlert::use_cars() const {
  return use_cars_;
}
inline void HistoryAlert::set_use_cars(::google::protobuf::uint32 value) {
  set_has_use_cars();
  use_cars_ = value;
}

// optional string create_time = 7;
inline bool HistoryAlert::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoryAlert::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoryAlert::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoryAlert::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& HistoryAlert::create_time() const {
  return *create_time_;
}
inline void HistoryAlert::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void HistoryAlert::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void HistoryAlert::set_create_time(const char* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlert::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* HistoryAlert::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlert::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string over_time = 8;
inline bool HistoryAlert::has_over_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoryAlert::set_has_over_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoryAlert::clear_has_over_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoryAlert::clear_over_time() {
  if (over_time_ != &::google::protobuf::internal::kEmptyString) {
    over_time_->clear();
  }
  clear_has_over_time();
}
inline const ::std::string& HistoryAlert::over_time() const {
  return *over_time_;
}
inline void HistoryAlert::set_over_time(const ::std::string& value) {
  set_has_over_time();
  if (over_time_ == &::google::protobuf::internal::kEmptyString) {
    over_time_ = new ::std::string;
  }
  over_time_->assign(value);
}
inline void HistoryAlert::set_over_time(const char* value) {
  set_has_over_time();
  if (over_time_ == &::google::protobuf::internal::kEmptyString) {
    over_time_ = new ::std::string;
  }
  over_time_->assign(value);
}
inline void HistoryAlert::set_over_time(const char* value, size_t size) {
  set_has_over_time();
  if (over_time_ == &::google::protobuf::internal::kEmptyString) {
    over_time_ = new ::std::string;
  }
  over_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlert::mutable_over_time() {
  set_has_over_time();
  if (over_time_ == &::google::protobuf::internal::kEmptyString) {
    over_time_ = new ::std::string;
  }
  return over_time_;
}
inline ::std::string* HistoryAlert::release_over_time() {
  clear_has_over_time();
  if (over_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = over_time_;
    over_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlert::set_allocated_over_time(::std::string* over_time) {
  if (over_time_ != &::google::protobuf::internal::kEmptyString) {
    delete over_time_;
  }
  if (over_time) {
    set_has_over_time();
    over_time_ = over_time;
  } else {
    clear_has_over_time();
    over_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HistoryAlertsResponse

// repeated .app.terminal.HistoryAlert history_alerts = 1;
inline int HistoryAlertsResponse::history_alerts_size() const {
  return history_alerts_.size();
}
inline void HistoryAlertsResponse::clear_history_alerts() {
  history_alerts_.Clear();
}
inline const ::app::terminal::HistoryAlert& HistoryAlertsResponse::history_alerts(int index) const {
  return history_alerts_.Get(index);
}
inline ::app::terminal::HistoryAlert* HistoryAlertsResponse::mutable_history_alerts(int index) {
  return history_alerts_.Mutable(index);
}
inline ::app::terminal::HistoryAlert* HistoryAlertsResponse::add_history_alerts() {
  return history_alerts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::HistoryAlert >&
HistoryAlertsResponse::history_alerts() const {
  return history_alerts_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::HistoryAlert >*
HistoryAlertsResponse::mutable_history_alerts() {
  return &history_alerts_;
}

// -------------------------------------------------------------------

// HistoryAlertRequest

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertRequest::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertRequest::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertRequest::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertRequest::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertRequest::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertRequest::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// -------------------------------------------------------------------

// HistoryAlertResponse

// required .app.terminal.HistoryAlert history_alert = 1;
inline bool HistoryAlertResponse::has_history_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertResponse::set_has_history_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertResponse::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertResponse::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::app::terminal::HistoryAlert::Clear();
  clear_has_history_alert();
}
inline const ::app::terminal::HistoryAlert& HistoryAlertResponse::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::app::terminal::HistoryAlert* HistoryAlertResponse::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::app::terminal::HistoryAlert;
  return history_alert_;
}
inline ::app::terminal::HistoryAlert* HistoryAlertResponse::release_history_alert() {
  clear_has_history_alert();
  ::app::terminal::HistoryAlert* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void HistoryAlertResponse::set_allocated_history_alert(::app::terminal::HistoryAlert* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// -------------------------------------------------------------------

// HistoryAlertMesageRequest

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertMesageRequest::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertMesageRequest::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertMesageRequest::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertMesageRequest::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertMesageRequest::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertMesageRequest::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// optional fixed32 from_message_id = 2;
inline bool HistoryAlertMesageRequest::has_from_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryAlertMesageRequest::set_has_from_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryAlertMesageRequest::clear_has_from_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryAlertMesageRequest::clear_from_message_id() {
  from_message_id_ = 0u;
  clear_has_from_message_id();
}
inline ::google::protobuf::uint32 HistoryAlertMesageRequest::from_message_id() const {
  return from_message_id_;
}
inline void HistoryAlertMesageRequest::set_from_message_id(::google::protobuf::uint32 value) {
  set_has_from_message_id();
  from_message_id_ = value;
}

// optional string from_time = 3;
inline bool HistoryAlertMesageRequest::has_from_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertMesageRequest::set_has_from_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertMesageRequest::clear_has_from_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertMesageRequest::clear_from_time() {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    from_time_->clear();
  }
  clear_has_from_time();
}
inline const ::std::string& HistoryAlertMesageRequest::from_time() const {
  return *from_time_;
}
inline void HistoryAlertMesageRequest::set_from_time(const ::std::string& value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void HistoryAlertMesageRequest::set_from_time(const char* value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void HistoryAlertMesageRequest::set_from_time(const char* value, size_t size) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertMesageRequest::mutable_from_time() {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  return from_time_;
}
inline ::std::string* HistoryAlertMesageRequest::release_from_time() {
  clear_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_time_;
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertMesageRequest::set_allocated_from_time(::std::string* from_time) {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    delete from_time_;
  }
  if (from_time) {
    set_has_from_time();
    from_time_ = from_time;
  } else {
    clear_has_from_time();
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 max_message_count = 4;
inline bool HistoryAlertMesageRequest::has_max_message_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryAlertMesageRequest::set_has_max_message_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryAlertMesageRequest::clear_has_max_message_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryAlertMesageRequest::clear_max_message_count() {
  max_message_count_ = 0u;
  clear_has_max_message_count();
}
inline ::google::protobuf::uint32 HistoryAlertMesageRequest::max_message_count() const {
  return max_message_count_;
}
inline void HistoryAlertMesageRequest::set_max_message_count(::google::protobuf::uint32 value) {
  set_has_max_message_count();
  max_message_count_ = value;
}

// -------------------------------------------------------------------

// HistoryAlertMesageResponse

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertMesageResponse::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertMesageResponse::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertMesageResponse::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertMesageResponse::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertMesageResponse::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertMesageResponse::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// repeated .app.terminal.MediaMessage messages = 2;
inline int HistoryAlertMesageResponse::messages_size() const {
  return messages_.size();
}
inline void HistoryAlertMesageResponse::clear_messages() {
  messages_.Clear();
}
inline const ::app::terminal::MediaMessage& HistoryAlertMesageResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::app::terminal::MediaMessage* HistoryAlertMesageResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::app::terminal::MediaMessage* HistoryAlertMesageResponse::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >&
HistoryAlertMesageResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::app::terminal::MediaMessage >*
HistoryAlertMesageResponse::mutable_messages() {
  return &messages_;
}

// required fixed32 leave_message_count = 3;
inline bool HistoryAlertMesageResponse::has_leave_message_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertMesageResponse::set_has_leave_message_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertMesageResponse::clear_has_leave_message_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertMesageResponse::clear_leave_message_count() {
  leave_message_count_ = 0u;
  clear_has_leave_message_count();
}
inline ::google::protobuf::uint32 HistoryAlertMesageResponse::leave_message_count() const {
  return leave_message_count_;
}
inline void HistoryAlertMesageResponse::set_leave_message_count(::google::protobuf::uint32 value) {
  set_has_leave_message_count();
  leave_message_count_ = value;
}

// -------------------------------------------------------------------

// Request

// optional .app.terminal.LoginRequest login = 1;
inline bool Request::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_login() {
  if (login_ != NULL) login_->::app::terminal::LoginRequest::Clear();
  clear_has_login();
}
inline const ::app::terminal::LoginRequest& Request::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::terminal::LoginRequest* Request::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::terminal::LoginRequest;
  return login_;
}
inline ::app::terminal::LoginRequest* Request::release_login() {
  clear_has_login();
  ::app::terminal::LoginRequest* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Request::set_allocated_login(::app::terminal::LoginRequest* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.terminal.GroupParticipantsRequest gourp_participants = 2;
inline bool Request::has_gourp_participants() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_gourp_participants() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_gourp_participants() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_gourp_participants() {
  if (gourp_participants_ != NULL) gourp_participants_->::app::terminal::GroupParticipantsRequest::Clear();
  clear_has_gourp_participants();
}
inline const ::app::terminal::GroupParticipantsRequest& Request::gourp_participants() const {
  return gourp_participants_ != NULL ? *gourp_participants_ : *default_instance_->gourp_participants_;
}
inline ::app::terminal::GroupParticipantsRequest* Request::mutable_gourp_participants() {
  set_has_gourp_participants();
  if (gourp_participants_ == NULL) gourp_participants_ = new ::app::terminal::GroupParticipantsRequest;
  return gourp_participants_;
}
inline ::app::terminal::GroupParticipantsRequest* Request::release_gourp_participants() {
  clear_has_gourp_participants();
  ::app::terminal::GroupParticipantsRequest* temp = gourp_participants_;
  gourp_participants_ = NULL;
  return temp;
}
inline void Request::set_allocated_gourp_participants(::app::terminal::GroupParticipantsRequest* gourp_participants) {
  delete gourp_participants_;
  gourp_participants_ = gourp_participants;
  if (gourp_participants) {
    set_has_gourp_participants();
  } else {
    clear_has_gourp_participants();
  }
}

// optional .app.terminal.MediaMessageRequest group_message = 3;
inline bool Request::has_group_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_group_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_group_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_group_message() {
  if (group_message_ != NULL) group_message_->::app::terminal::MediaMessageRequest::Clear();
  clear_has_group_message();
}
inline const ::app::terminal::MediaMessageRequest& Request::group_message() const {
  return group_message_ != NULL ? *group_message_ : *default_instance_->group_message_;
}
inline ::app::terminal::MediaMessageRequest* Request::mutable_group_message() {
  set_has_group_message();
  if (group_message_ == NULL) group_message_ = new ::app::terminal::MediaMessageRequest;
  return group_message_;
}
inline ::app::terminal::MediaMessageRequest* Request::release_group_message() {
  clear_has_group_message();
  ::app::terminal::MediaMessageRequest* temp = group_message_;
  group_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_group_message(::app::terminal::MediaMessageRequest* group_message) {
  delete group_message_;
  group_message_ = group_message;
  if (group_message) {
    set_has_group_message();
  } else {
    clear_has_group_message();
  }
}

// optional .app.terminal.JoinGroupRequest join_group = 4;
inline bool Request::has_join_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_join_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_join_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_join_group() {
  if (join_group_ != NULL) join_group_->::app::terminal::JoinGroupRequest::Clear();
  clear_has_join_group();
}
inline const ::app::terminal::JoinGroupRequest& Request::join_group() const {
  return join_group_ != NULL ? *join_group_ : *default_instance_->join_group_;
}
inline ::app::terminal::JoinGroupRequest* Request::mutable_join_group() {
  set_has_join_group();
  if (join_group_ == NULL) join_group_ = new ::app::terminal::JoinGroupRequest;
  return join_group_;
}
inline ::app::terminal::JoinGroupRequest* Request::release_join_group() {
  clear_has_join_group();
  ::app::terminal::JoinGroupRequest* temp = join_group_;
  join_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_join_group(::app::terminal::JoinGroupRequest* join_group) {
  delete join_group_;
  join_group_ = join_group;
  if (join_group) {
    set_has_join_group();
  } else {
    clear_has_join_group();
  }
}

// optional .app.terminal.ConnectGroupRequest connect_group = 5;
inline bool Request::has_connect_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_connect_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_connect_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_connect_group() {
  if (connect_group_ != NULL) connect_group_->::app::terminal::ConnectGroupRequest::Clear();
  clear_has_connect_group();
}
inline const ::app::terminal::ConnectGroupRequest& Request::connect_group() const {
  return connect_group_ != NULL ? *connect_group_ : *default_instance_->connect_group_;
}
inline ::app::terminal::ConnectGroupRequest* Request::mutable_connect_group() {
  set_has_connect_group();
  if (connect_group_ == NULL) connect_group_ = new ::app::terminal::ConnectGroupRequest;
  return connect_group_;
}
inline ::app::terminal::ConnectGroupRequest* Request::release_connect_group() {
  clear_has_connect_group();
  ::app::terminal::ConnectGroupRequest* temp = connect_group_;
  connect_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_connect_group(::app::terminal::ConnectGroupRequest* connect_group) {
  delete connect_group_;
  connect_group_ = connect_group;
  if (connect_group) {
    set_has_connect_group();
  } else {
    clear_has_connect_group();
  }
}

// optional .app.terminal.SpeakRequest speak = 6;
inline bool Request::has_speak() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_speak() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_speak() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_speak() {
  if (speak_ != NULL) speak_->::app::terminal::SpeakRequest::Clear();
  clear_has_speak();
}
inline const ::app::terminal::SpeakRequest& Request::speak() const {
  return speak_ != NULL ? *speak_ : *default_instance_->speak_;
}
inline ::app::terminal::SpeakRequest* Request::mutable_speak() {
  set_has_speak();
  if (speak_ == NULL) speak_ = new ::app::terminal::SpeakRequest;
  return speak_;
}
inline ::app::terminal::SpeakRequest* Request::release_speak() {
  clear_has_speak();
  ::app::terminal::SpeakRequest* temp = speak_;
  speak_ = NULL;
  return temp;
}
inline void Request::set_allocated_speak(::app::terminal::SpeakRequest* speak) {
  delete speak_;
  speak_ = speak;
  if (speak) {
    set_has_speak();
  } else {
    clear_has_speak();
  }
}

// optional .app.terminal.JoinSessionRequest jone_session = 7;
inline bool Request::has_jone_session() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_jone_session() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_jone_session() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_jone_session() {
  if (jone_session_ != NULL) jone_session_->::app::terminal::JoinSessionRequest::Clear();
  clear_has_jone_session();
}
inline const ::app::terminal::JoinSessionRequest& Request::jone_session() const {
  return jone_session_ != NULL ? *jone_session_ : *default_instance_->jone_session_;
}
inline ::app::terminal::JoinSessionRequest* Request::mutable_jone_session() {
  set_has_jone_session();
  if (jone_session_ == NULL) jone_session_ = new ::app::terminal::JoinSessionRequest;
  return jone_session_;
}
inline ::app::terminal::JoinSessionRequest* Request::release_jone_session() {
  clear_has_jone_session();
  ::app::terminal::JoinSessionRequest* temp = jone_session_;
  jone_session_ = NULL;
  return temp;
}
inline void Request::set_allocated_jone_session(::app::terminal::JoinSessionRequest* jone_session) {
  delete jone_session_;
  jone_session_ = jone_session;
  if (jone_session) {
    set_has_jone_session();
  } else {
    clear_has_jone_session();
  }
}

// optional .app.terminal.LeaveSessionRequest leave_session = 8;
inline bool Request::has_leave_session() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_leave_session() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_leave_session() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_leave_session() {
  if (leave_session_ != NULL) leave_session_->::app::terminal::LeaveSessionRequest::Clear();
  clear_has_leave_session();
}
inline const ::app::terminal::LeaveSessionRequest& Request::leave_session() const {
  return leave_session_ != NULL ? *leave_session_ : *default_instance_->leave_session_;
}
inline ::app::terminal::LeaveSessionRequest* Request::mutable_leave_session() {
  set_has_leave_session();
  if (leave_session_ == NULL) leave_session_ = new ::app::terminal::LeaveSessionRequest;
  return leave_session_;
}
inline ::app::terminal::LeaveSessionRequest* Request::release_leave_session() {
  clear_has_leave_session();
  ::app::terminal::LeaveSessionRequest* temp = leave_session_;
  leave_session_ = NULL;
  return temp;
}
inline void Request::set_allocated_leave_session(::app::terminal::LeaveSessionRequest* leave_session) {
  delete leave_session_;
  leave_session_ = leave_session;
  if (leave_session) {
    set_has_leave_session();
  } else {
    clear_has_leave_session();
  }
}

// optional .app.terminal.ReleaseTokenRequest release_token = 9;
inline bool Request::has_release_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_release_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_release_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_release_token() {
  if (release_token_ != NULL) release_token_->::app::terminal::ReleaseTokenRequest::Clear();
  clear_has_release_token();
}
inline const ::app::terminal::ReleaseTokenRequest& Request::release_token() const {
  return release_token_ != NULL ? *release_token_ : *default_instance_->release_token_;
}
inline ::app::terminal::ReleaseTokenRequest* Request::mutable_release_token() {
  set_has_release_token();
  if (release_token_ == NULL) release_token_ = new ::app::terminal::ReleaseTokenRequest;
  return release_token_;
}
inline ::app::terminal::ReleaseTokenRequest* Request::release_release_token() {
  clear_has_release_token();
  ::app::terminal::ReleaseTokenRequest* temp = release_token_;
  release_token_ = NULL;
  return temp;
}
inline void Request::set_allocated_release_token(::app::terminal::ReleaseTokenRequest* release_token) {
  delete release_token_;
  release_token_ = release_token;
  if (release_token) {
    set_has_release_token();
  } else {
    clear_has_release_token();
  }
}

// optional .app.terminal.AppointSpeakRequest appoint_speak = 10;
inline bool Request::has_appoint_speak() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_appoint_speak() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_appoint_speak() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_appoint_speak() {
  if (appoint_speak_ != NULL) appoint_speak_->::app::terminal::AppointSpeakRequest::Clear();
  clear_has_appoint_speak();
}
inline const ::app::terminal::AppointSpeakRequest& Request::appoint_speak() const {
  return appoint_speak_ != NULL ? *appoint_speak_ : *default_instance_->appoint_speak_;
}
inline ::app::terminal::AppointSpeakRequest* Request::mutable_appoint_speak() {
  set_has_appoint_speak();
  if (appoint_speak_ == NULL) appoint_speak_ = new ::app::terminal::AppointSpeakRequest;
  return appoint_speak_;
}
inline ::app::terminal::AppointSpeakRequest* Request::release_appoint_speak() {
  clear_has_appoint_speak();
  ::app::terminal::AppointSpeakRequest* temp = appoint_speak_;
  appoint_speak_ = NULL;
  return temp;
}
inline void Request::set_allocated_appoint_speak(::app::terminal::AppointSpeakRequest* appoint_speak) {
  delete appoint_speak_;
  appoint_speak_ = appoint_speak;
  if (appoint_speak) {
    set_has_appoint_speak();
  } else {
    clear_has_appoint_speak();
  }
}

// optional .app.terminal.SendMessageRequest send_message = 11;
inline bool Request::has_send_message() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_send_message() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_send_message() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_send_message() {
  if (send_message_ != NULL) send_message_->::app::terminal::SendMessageRequest::Clear();
  clear_has_send_message();
}
inline const ::app::terminal::SendMessageRequest& Request::send_message() const {
  return send_message_ != NULL ? *send_message_ : *default_instance_->send_message_;
}
inline ::app::terminal::SendMessageRequest* Request::mutable_send_message() {
  set_has_send_message();
  if (send_message_ == NULL) send_message_ = new ::app::terminal::SendMessageRequest;
  return send_message_;
}
inline ::app::terminal::SendMessageRequest* Request::release_send_message() {
  clear_has_send_message();
  ::app::terminal::SendMessageRequest* temp = send_message_;
  send_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_send_message(::app::terminal::SendMessageRequest* send_message) {
  delete send_message_;
  send_message_ = send_message;
  if (send_message) {
    set_has_send_message();
  } else {
    clear_has_send_message();
  }
}

// optional .app.terminal.SubscribeLocationRequest subscribe_location = 12;
inline bool Request::has_subscribe_location() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_subscribe_location() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_subscribe_location() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_subscribe_location() {
  if (subscribe_location_ != NULL) subscribe_location_->::app::terminal::SubscribeLocationRequest::Clear();
  clear_has_subscribe_location();
}
inline const ::app::terminal::SubscribeLocationRequest& Request::subscribe_location() const {
  return subscribe_location_ != NULL ? *subscribe_location_ : *default_instance_->subscribe_location_;
}
inline ::app::terminal::SubscribeLocationRequest* Request::mutable_subscribe_location() {
  set_has_subscribe_location();
  if (subscribe_location_ == NULL) subscribe_location_ = new ::app::terminal::SubscribeLocationRequest;
  return subscribe_location_;
}
inline ::app::terminal::SubscribeLocationRequest* Request::release_subscribe_location() {
  clear_has_subscribe_location();
  ::app::terminal::SubscribeLocationRequest* temp = subscribe_location_;
  subscribe_location_ = NULL;
  return temp;
}
inline void Request::set_allocated_subscribe_location(::app::terminal::SubscribeLocationRequest* subscribe_location) {
  delete subscribe_location_;
  subscribe_location_ = subscribe_location;
  if (subscribe_location) {
    set_has_subscribe_location();
  } else {
    clear_has_subscribe_location();
  }
}

// optional .app.terminal.AlertRequest alert = 13;
inline bool Request::has_alert() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_alert() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_alert() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_alert() {
  if (alert_ != NULL) alert_->::app::terminal::AlertRequest::Clear();
  clear_has_alert();
}
inline const ::app::terminal::AlertRequest& Request::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::app::terminal::AlertRequest* Request::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::app::terminal::AlertRequest;
  return alert_;
}
inline ::app::terminal::AlertRequest* Request::release_alert() {
  clear_has_alert();
  ::app::terminal::AlertRequest* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_alert(::app::terminal::AlertRequest* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// optional .app.terminal.HistoryAlertsRequest history_alerts = 14;
inline bool Request::has_history_alerts() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_history_alerts() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_history_alerts() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_history_alerts() {
  if (history_alerts_ != NULL) history_alerts_->::app::terminal::HistoryAlertsRequest::Clear();
  clear_has_history_alerts();
}
inline const ::app::terminal::HistoryAlertsRequest& Request::history_alerts() const {
  return history_alerts_ != NULL ? *history_alerts_ : *default_instance_->history_alerts_;
}
inline ::app::terminal::HistoryAlertsRequest* Request::mutable_history_alerts() {
  set_has_history_alerts();
  if (history_alerts_ == NULL) history_alerts_ = new ::app::terminal::HistoryAlertsRequest;
  return history_alerts_;
}
inline ::app::terminal::HistoryAlertsRequest* Request::release_history_alerts() {
  clear_has_history_alerts();
  ::app::terminal::HistoryAlertsRequest* temp = history_alerts_;
  history_alerts_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alerts(::app::terminal::HistoryAlertsRequest* history_alerts) {
  delete history_alerts_;
  history_alerts_ = history_alerts;
  if (history_alerts) {
    set_has_history_alerts();
  } else {
    clear_has_history_alerts();
  }
}

// optional .app.terminal.HistoryAlertRequest history_alert = 15;
inline bool Request::has_history_alert() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_history_alert() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::app::terminal::HistoryAlertRequest::Clear();
  clear_has_history_alert();
}
inline const ::app::terminal::HistoryAlertRequest& Request::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::app::terminal::HistoryAlertRequest* Request::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::app::terminal::HistoryAlertRequest;
  return history_alert_;
}
inline ::app::terminal::HistoryAlertRequest* Request::release_history_alert() {
  clear_has_history_alert();
  ::app::terminal::HistoryAlertRequest* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alert(::app::terminal::HistoryAlertRequest* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// optional .app.terminal.HistoryAlertMesageRequest history_alert_message = 16;
inline bool Request::has_history_alert_message() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Request::set_has_history_alert_message() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Request::clear_has_history_alert_message() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Request::clear_history_alert_message() {
  if (history_alert_message_ != NULL) history_alert_message_->::app::terminal::HistoryAlertMesageRequest::Clear();
  clear_has_history_alert_message();
}
inline const ::app::terminal::HistoryAlertMesageRequest& Request::history_alert_message() const {
  return history_alert_message_ != NULL ? *history_alert_message_ : *default_instance_->history_alert_message_;
}
inline ::app::terminal::HistoryAlertMesageRequest* Request::mutable_history_alert_message() {
  set_has_history_alert_message();
  if (history_alert_message_ == NULL) history_alert_message_ = new ::app::terminal::HistoryAlertMesageRequest;
  return history_alert_message_;
}
inline ::app::terminal::HistoryAlertMesageRequest* Request::release_history_alert_message() {
  clear_has_history_alert_message();
  ::app::terminal::HistoryAlertMesageRequest* temp = history_alert_message_;
  history_alert_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alert_message(::app::terminal::HistoryAlertMesageRequest* history_alert_message) {
  delete history_alert_message_;
  history_alert_message_ = history_alert_message;
  if (history_alert_message) {
    set_has_history_alert_message();
  } else {
    clear_has_history_alert_message();
  }
}

// -------------------------------------------------------------------

// Response

// required bool result = 1;
inline bool Response::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool Response::result() const {
  return result_;
}
inline void Response::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required bool last_response = 2;
inline bool Response::has_last_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_last_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_last_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_last_response() {
  last_response_ = false;
  clear_has_last_response();
}
inline bool Response::last_response() const {
  return last_response_;
}
inline void Response::set_last_response(bool value) {
  set_has_last_response();
  last_response_ = value;
}

// optional bytes error_describe = 3;
inline bool Response::has_error_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_error_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_error_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_error_describe() {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    error_describe_->clear();
  }
  clear_has_error_describe();
}
inline const ::std::string& Response::error_describe() const {
  return *error_describe_;
}
inline void Response::set_error_describe(const ::std::string& value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const char* value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const void* value, size_t size) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_error_describe() {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  return error_describe_;
}
inline ::std::string* Response::release_error_describe() {
  clear_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_describe_;
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_error_describe(::std::string* error_describe) {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    delete error_describe_;
  }
  if (error_describe) {
    set_has_error_describe();
    error_describe_ = error_describe;
  } else {
    clear_has_error_describe();
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .app.terminal.LoginResponse login = 4;
inline bool Response::has_login() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_login() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_login() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_login() {
  if (login_ != NULL) login_->::app::terminal::LoginResponse::Clear();
  clear_has_login();
}
inline const ::app::terminal::LoginResponse& Response::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::terminal::LoginResponse* Response::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::terminal::LoginResponse;
  return login_;
}
inline ::app::terminal::LoginResponse* Response::release_login() {
  clear_has_login();
  ::app::terminal::LoginResponse* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Response::set_allocated_login(::app::terminal::LoginResponse* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.terminal.GroupsResponse groups = 5;
inline bool Response::has_groups() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_groups() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_groups() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_groups() {
  if (groups_ != NULL) groups_->::app::terminal::GroupsResponse::Clear();
  clear_has_groups();
}
inline const ::app::terminal::GroupsResponse& Response::groups() const {
  return groups_ != NULL ? *groups_ : *default_instance_->groups_;
}
inline ::app::terminal::GroupsResponse* Response::mutable_groups() {
  set_has_groups();
  if (groups_ == NULL) groups_ = new ::app::terminal::GroupsResponse;
  return groups_;
}
inline ::app::terminal::GroupsResponse* Response::release_groups() {
  clear_has_groups();
  ::app::terminal::GroupsResponse* temp = groups_;
  groups_ = NULL;
  return temp;
}
inline void Response::set_allocated_groups(::app::terminal::GroupsResponse* groups) {
  delete groups_;
  groups_ = groups;
  if (groups) {
    set_has_groups();
  } else {
    clear_has_groups();
  }
}

// optional .app.terminal.GroupParticipantsResponse group_participants = 6;
inline bool Response::has_group_participants() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_group_participants() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_group_participants() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_group_participants() {
  if (group_participants_ != NULL) group_participants_->::app::terminal::GroupParticipantsResponse::Clear();
  clear_has_group_participants();
}
inline const ::app::terminal::GroupParticipantsResponse& Response::group_participants() const {
  return group_participants_ != NULL ? *group_participants_ : *default_instance_->group_participants_;
}
inline ::app::terminal::GroupParticipantsResponse* Response::mutable_group_participants() {
  set_has_group_participants();
  if (group_participants_ == NULL) group_participants_ = new ::app::terminal::GroupParticipantsResponse;
  return group_participants_;
}
inline ::app::terminal::GroupParticipantsResponse* Response::release_group_participants() {
  clear_has_group_participants();
  ::app::terminal::GroupParticipantsResponse* temp = group_participants_;
  group_participants_ = NULL;
  return temp;
}
inline void Response::set_allocated_group_participants(::app::terminal::GroupParticipantsResponse* group_participants) {
  delete group_participants_;
  group_participants_ = group_participants;
  if (group_participants) {
    set_has_group_participants();
  } else {
    clear_has_group_participants();
  }
}

// optional .app.terminal.MediaMessageResponse group_message = 7;
inline bool Response::has_group_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_group_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_group_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_group_message() {
  if (group_message_ != NULL) group_message_->::app::terminal::MediaMessageResponse::Clear();
  clear_has_group_message();
}
inline const ::app::terminal::MediaMessageResponse& Response::group_message() const {
  return group_message_ != NULL ? *group_message_ : *default_instance_->group_message_;
}
inline ::app::terminal::MediaMessageResponse* Response::mutable_group_message() {
  set_has_group_message();
  if (group_message_ == NULL) group_message_ = new ::app::terminal::MediaMessageResponse;
  return group_message_;
}
inline ::app::terminal::MediaMessageResponse* Response::release_group_message() {
  clear_has_group_message();
  ::app::terminal::MediaMessageResponse* temp = group_message_;
  group_message_ = NULL;
  return temp;
}
inline void Response::set_allocated_group_message(::app::terminal::MediaMessageResponse* group_message) {
  delete group_message_;
  group_message_ = group_message;
  if (group_message) {
    set_has_group_message();
  } else {
    clear_has_group_message();
  }
}

// optional .app.terminal.SubscribeLocationResponse subscribe_location = 8;
inline bool Response::has_subscribe_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_subscribe_location() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_subscribe_location() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_subscribe_location() {
  if (subscribe_location_ != NULL) subscribe_location_->::app::terminal::SubscribeLocationResponse::Clear();
  clear_has_subscribe_location();
}
inline const ::app::terminal::SubscribeLocationResponse& Response::subscribe_location() const {
  return subscribe_location_ != NULL ? *subscribe_location_ : *default_instance_->subscribe_location_;
}
inline ::app::terminal::SubscribeLocationResponse* Response::mutable_subscribe_location() {
  set_has_subscribe_location();
  if (subscribe_location_ == NULL) subscribe_location_ = new ::app::terminal::SubscribeLocationResponse;
  return subscribe_location_;
}
inline ::app::terminal::SubscribeLocationResponse* Response::release_subscribe_location() {
  clear_has_subscribe_location();
  ::app::terminal::SubscribeLocationResponse* temp = subscribe_location_;
  subscribe_location_ = NULL;
  return temp;
}
inline void Response::set_allocated_subscribe_location(::app::terminal::SubscribeLocationResponse* subscribe_location) {
  delete subscribe_location_;
  subscribe_location_ = subscribe_location;
  if (subscribe_location) {
    set_has_subscribe_location();
  } else {
    clear_has_subscribe_location();
  }
}

// optional .app.terminal.AlertsResponse alerts = 9;
inline bool Response::has_alerts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_alerts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_alerts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_alerts() {
  if (alerts_ != NULL) alerts_->::app::terminal::AlertsResponse::Clear();
  clear_has_alerts();
}
inline const ::app::terminal::AlertsResponse& Response::alerts() const {
  return alerts_ != NULL ? *alerts_ : *default_instance_->alerts_;
}
inline ::app::terminal::AlertsResponse* Response::mutable_alerts() {
  set_has_alerts();
  if (alerts_ == NULL) alerts_ = new ::app::terminal::AlertsResponse;
  return alerts_;
}
inline ::app::terminal::AlertsResponse* Response::release_alerts() {
  clear_has_alerts();
  ::app::terminal::AlertsResponse* temp = alerts_;
  alerts_ = NULL;
  return temp;
}
inline void Response::set_allocated_alerts(::app::terminal::AlertsResponse* alerts) {
  delete alerts_;
  alerts_ = alerts;
  if (alerts) {
    set_has_alerts();
  } else {
    clear_has_alerts();
  }
}

// optional .app.terminal.AlertResponse alert = 10;
inline bool Response::has_alert() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_alert() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_alert() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_alert() {
  if (alert_ != NULL) alert_->::app::terminal::AlertResponse::Clear();
  clear_has_alert();
}
inline const ::app::terminal::AlertResponse& Response::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::app::terminal::AlertResponse* Response::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::app::terminal::AlertResponse;
  return alert_;
}
inline ::app::terminal::AlertResponse* Response::release_alert() {
  clear_has_alert();
  ::app::terminal::AlertResponse* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void Response::set_allocated_alert(::app::terminal::AlertResponse* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// optional .app.terminal.HistoryAlertsResponse history_alerts = 11;
inline bool Response::has_history_alerts() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_history_alerts() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_history_alerts() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_history_alerts() {
  if (history_alerts_ != NULL) history_alerts_->::app::terminal::HistoryAlertsResponse::Clear();
  clear_has_history_alerts();
}
inline const ::app::terminal::HistoryAlertsResponse& Response::history_alerts() const {
  return history_alerts_ != NULL ? *history_alerts_ : *default_instance_->history_alerts_;
}
inline ::app::terminal::HistoryAlertsResponse* Response::mutable_history_alerts() {
  set_has_history_alerts();
  if (history_alerts_ == NULL) history_alerts_ = new ::app::terminal::HistoryAlertsResponse;
  return history_alerts_;
}
inline ::app::terminal::HistoryAlertsResponse* Response::release_history_alerts() {
  clear_has_history_alerts();
  ::app::terminal::HistoryAlertsResponse* temp = history_alerts_;
  history_alerts_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alerts(::app::terminal::HistoryAlertsResponse* history_alerts) {
  delete history_alerts_;
  history_alerts_ = history_alerts;
  if (history_alerts) {
    set_has_history_alerts();
  } else {
    clear_has_history_alerts();
  }
}

// optional .app.terminal.HistoryAlertResponse history_alert = 12;
inline bool Response::has_history_alert() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_history_alert() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::app::terminal::HistoryAlertResponse::Clear();
  clear_has_history_alert();
}
inline const ::app::terminal::HistoryAlertResponse& Response::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::app::terminal::HistoryAlertResponse* Response::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::app::terminal::HistoryAlertResponse;
  return history_alert_;
}
inline ::app::terminal::HistoryAlertResponse* Response::release_history_alert() {
  clear_has_history_alert();
  ::app::terminal::HistoryAlertResponse* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alert(::app::terminal::HistoryAlertResponse* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// optional .app.terminal.HistoryAlertMesageResponse history_alert_message = 13;
inline bool Response::has_history_alert_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_history_alert_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_history_alert_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_history_alert_message() {
  if (history_alert_message_ != NULL) history_alert_message_->::app::terminal::HistoryAlertMesageResponse::Clear();
  clear_has_history_alert_message();
}
inline const ::app::terminal::HistoryAlertMesageResponse& Response::history_alert_message() const {
  return history_alert_message_ != NULL ? *history_alert_message_ : *default_instance_->history_alert_message_;
}
inline ::app::terminal::HistoryAlertMesageResponse* Response::mutable_history_alert_message() {
  set_has_history_alert_message();
  if (history_alert_message_ == NULL) history_alert_message_ = new ::app::terminal::HistoryAlertMesageResponse;
  return history_alert_message_;
}
inline ::app::terminal::HistoryAlertMesageResponse* Response::release_history_alert_message() {
  clear_has_history_alert_message();
  ::app::terminal::HistoryAlertMesageResponse* temp = history_alert_message_;
  history_alert_message_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alert_message(::app::terminal::HistoryAlertMesageResponse* history_alert_message) {
  delete history_alert_message_;
  history_alert_message_ = history_alert_message;
  if (history_alert_message) {
    set_has_history_alert_message();
  } else {
    clear_has_history_alert_message();
  }
}

// -------------------------------------------------------------------

// Indication

// optional .app.terminal.RegisterStatusNotification register_status = 1;
inline bool Indication::has_register_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Indication::set_has_register_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Indication::clear_has_register_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Indication::clear_register_status() {
  if (register_status_ != NULL) register_status_->::app::terminal::RegisterStatusNotification::Clear();
  clear_has_register_status();
}
inline const ::app::terminal::RegisterStatusNotification& Indication::register_status() const {
  return register_status_ != NULL ? *register_status_ : *default_instance_->register_status_;
}
inline ::app::terminal::RegisterStatusNotification* Indication::mutable_register_status() {
  set_has_register_status();
  if (register_status_ == NULL) register_status_ = new ::app::terminal::RegisterStatusNotification;
  return register_status_;
}
inline ::app::terminal::RegisterStatusNotification* Indication::release_register_status() {
  clear_has_register_status();
  ::app::terminal::RegisterStatusNotification* temp = register_status_;
  register_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_register_status(::app::terminal::RegisterStatusNotification* register_status) {
  delete register_status_;
  register_status_ = register_status;
  if (register_status) {
    set_has_register_status();
  } else {
    clear_has_register_status();
  }
}

// optional .app.terminal.JoinedGroupNotification joined_group = 2;
inline bool Indication::has_joined_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Indication::set_has_joined_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Indication::clear_has_joined_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Indication::clear_joined_group() {
  if (joined_group_ != NULL) joined_group_->::app::terminal::JoinedGroupNotification::Clear();
  clear_has_joined_group();
}
inline const ::app::terminal::JoinedGroupNotification& Indication::joined_group() const {
  return joined_group_ != NULL ? *joined_group_ : *default_instance_->joined_group_;
}
inline ::app::terminal::JoinedGroupNotification* Indication::mutable_joined_group() {
  set_has_joined_group();
  if (joined_group_ == NULL) joined_group_ = new ::app::terminal::JoinedGroupNotification;
  return joined_group_;
}
inline ::app::terminal::JoinedGroupNotification* Indication::release_joined_group() {
  clear_has_joined_group();
  ::app::terminal::JoinedGroupNotification* temp = joined_group_;
  joined_group_ = NULL;
  return temp;
}
inline void Indication::set_allocated_joined_group(::app::terminal::JoinedGroupNotification* joined_group) {
  delete joined_group_;
  joined_group_ = joined_group;
  if (joined_group) {
    set_has_joined_group();
  } else {
    clear_has_joined_group();
  }
}

// optional .app.terminal.LeaveGroupNotification leave_group = 3;
inline bool Indication::has_leave_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Indication::set_has_leave_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Indication::clear_has_leave_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Indication::clear_leave_group() {
  if (leave_group_ != NULL) leave_group_->::app::terminal::LeaveGroupNotification::Clear();
  clear_has_leave_group();
}
inline const ::app::terminal::LeaveGroupNotification& Indication::leave_group() const {
  return leave_group_ != NULL ? *leave_group_ : *default_instance_->leave_group_;
}
inline ::app::terminal::LeaveGroupNotification* Indication::mutable_leave_group() {
  set_has_leave_group();
  if (leave_group_ == NULL) leave_group_ = new ::app::terminal::LeaveGroupNotification;
  return leave_group_;
}
inline ::app::terminal::LeaveGroupNotification* Indication::release_leave_group() {
  clear_has_leave_group();
  ::app::terminal::LeaveGroupNotification* temp = leave_group_;
  leave_group_ = NULL;
  return temp;
}
inline void Indication::set_allocated_leave_group(::app::terminal::LeaveGroupNotification* leave_group) {
  delete leave_group_;
  leave_group_ = leave_group;
  if (leave_group) {
    set_has_leave_group();
  } else {
    clear_has_leave_group();
  }
}

// optional .app.terminal.OthersJoinedGroupNotification others_joined_group = 4;
inline bool Indication::has_others_joined_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Indication::set_has_others_joined_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Indication::clear_has_others_joined_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Indication::clear_others_joined_group() {
  if (others_joined_group_ != NULL) others_joined_group_->::app::terminal::OthersJoinedGroupNotification::Clear();
  clear_has_others_joined_group();
}
inline const ::app::terminal::OthersJoinedGroupNotification& Indication::others_joined_group() const {
  return others_joined_group_ != NULL ? *others_joined_group_ : *default_instance_->others_joined_group_;
}
inline ::app::terminal::OthersJoinedGroupNotification* Indication::mutable_others_joined_group() {
  set_has_others_joined_group();
  if (others_joined_group_ == NULL) others_joined_group_ = new ::app::terminal::OthersJoinedGroupNotification;
  return others_joined_group_;
}
inline ::app::terminal::OthersJoinedGroupNotification* Indication::release_others_joined_group() {
  clear_has_others_joined_group();
  ::app::terminal::OthersJoinedGroupNotification* temp = others_joined_group_;
  others_joined_group_ = NULL;
  return temp;
}
inline void Indication::set_allocated_others_joined_group(::app::terminal::OthersJoinedGroupNotification* others_joined_group) {
  delete others_joined_group_;
  others_joined_group_ = others_joined_group;
  if (others_joined_group) {
    set_has_others_joined_group();
  } else {
    clear_has_others_joined_group();
  }
}

// optional .app.terminal.OthersLeaveGroupNotification others_leave_group = 5;
inline bool Indication::has_others_leave_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Indication::set_has_others_leave_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Indication::clear_has_others_leave_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Indication::clear_others_leave_group() {
  if (others_leave_group_ != NULL) others_leave_group_->::app::terminal::OthersLeaveGroupNotification::Clear();
  clear_has_others_leave_group();
}
inline const ::app::terminal::OthersLeaveGroupNotification& Indication::others_leave_group() const {
  return others_leave_group_ != NULL ? *others_leave_group_ : *default_instance_->others_leave_group_;
}
inline ::app::terminal::OthersLeaveGroupNotification* Indication::mutable_others_leave_group() {
  set_has_others_leave_group();
  if (others_leave_group_ == NULL) others_leave_group_ = new ::app::terminal::OthersLeaveGroupNotification;
  return others_leave_group_;
}
inline ::app::terminal::OthersLeaveGroupNotification* Indication::release_others_leave_group() {
  clear_has_others_leave_group();
  ::app::terminal::OthersLeaveGroupNotification* temp = others_leave_group_;
  others_leave_group_ = NULL;
  return temp;
}
inline void Indication::set_allocated_others_leave_group(::app::terminal::OthersLeaveGroupNotification* others_leave_group) {
  delete others_leave_group_;
  others_leave_group_ = others_leave_group;
  if (others_leave_group) {
    set_has_others_leave_group();
  } else {
    clear_has_others_leave_group();
  }
}

// optional .app.terminal.MediaMessageNotification group_message = 6;
inline bool Indication::has_group_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Indication::set_has_group_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Indication::clear_has_group_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Indication::clear_group_message() {
  if (group_message_ != NULL) group_message_->::app::terminal::MediaMessageNotification::Clear();
  clear_has_group_message();
}
inline const ::app::terminal::MediaMessageNotification& Indication::group_message() const {
  return group_message_ != NULL ? *group_message_ : *default_instance_->group_message_;
}
inline ::app::terminal::MediaMessageNotification* Indication::mutable_group_message() {
  set_has_group_message();
  if (group_message_ == NULL) group_message_ = new ::app::terminal::MediaMessageNotification;
  return group_message_;
}
inline ::app::terminal::MediaMessageNotification* Indication::release_group_message() {
  clear_has_group_message();
  ::app::terminal::MediaMessageNotification* temp = group_message_;
  group_message_ = NULL;
  return temp;
}
inline void Indication::set_allocated_group_message(::app::terminal::MediaMessageNotification* group_message) {
  delete group_message_;
  group_message_ = group_message;
  if (group_message) {
    set_has_group_message();
  } else {
    clear_has_group_message();
  }
}

// optional .app.terminal.SessionStatusNotification session_status = 7;
inline bool Indication::has_session_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Indication::set_has_session_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Indication::clear_has_session_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Indication::clear_session_status() {
  if (session_status_ != NULL) session_status_->::app::terminal::SessionStatusNotification::Clear();
  clear_has_session_status();
}
inline const ::app::terminal::SessionStatusNotification& Indication::session_status() const {
  return session_status_ != NULL ? *session_status_ : *default_instance_->session_status_;
}
inline ::app::terminal::SessionStatusNotification* Indication::mutable_session_status() {
  set_has_session_status();
  if (session_status_ == NULL) session_status_ = new ::app::terminal::SessionStatusNotification;
  return session_status_;
}
inline ::app::terminal::SessionStatusNotification* Indication::release_session_status() {
  clear_has_session_status();
  ::app::terminal::SessionStatusNotification* temp = session_status_;
  session_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_session_status(::app::terminal::SessionStatusNotification* session_status) {
  delete session_status_;
  session_status_ = session_status;
  if (session_status) {
    set_has_session_status();
  } else {
    clear_has_session_status();
  }
}

// optional .app.terminal.LocationNotification location = 8;
inline bool Indication::has_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Indication::set_has_location() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Indication::clear_has_location() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Indication::clear_location() {
  if (location_ != NULL) location_->::app::terminal::LocationNotification::Clear();
  clear_has_location();
}
inline const ::app::terminal::LocationNotification& Indication::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::app::terminal::LocationNotification* Indication::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::app::terminal::LocationNotification;
  return location_;
}
inline ::app::terminal::LocationNotification* Indication::release_location() {
  clear_has_location();
  ::app::terminal::LocationNotification* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Indication::set_allocated_location(::app::terminal::LocationNotification* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
}

// optional .app.terminal.AlertCreateNotification alert_create = 9;
inline bool Indication::has_alert_create() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Indication::set_has_alert_create() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Indication::clear_has_alert_create() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Indication::clear_alert_create() {
  if (alert_create_ != NULL) alert_create_->::app::terminal::AlertCreateNotification::Clear();
  clear_has_alert_create();
}
inline const ::app::terminal::AlertCreateNotification& Indication::alert_create() const {
  return alert_create_ != NULL ? *alert_create_ : *default_instance_->alert_create_;
}
inline ::app::terminal::AlertCreateNotification* Indication::mutable_alert_create() {
  set_has_alert_create();
  if (alert_create_ == NULL) alert_create_ = new ::app::terminal::AlertCreateNotification;
  return alert_create_;
}
inline ::app::terminal::AlertCreateNotification* Indication::release_alert_create() {
  clear_has_alert_create();
  ::app::terminal::AlertCreateNotification* temp = alert_create_;
  alert_create_ = NULL;
  return temp;
}
inline void Indication::set_allocated_alert_create(::app::terminal::AlertCreateNotification* alert_create) {
  delete alert_create_;
  alert_create_ = alert_create;
  if (alert_create) {
    set_has_alert_create();
  } else {
    clear_has_alert_create();
  }
}

// optional .app.terminal.AlertModifyNotification alert_modify = 10;
inline bool Indication::has_alert_modify() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Indication::set_has_alert_modify() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Indication::clear_has_alert_modify() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Indication::clear_alert_modify() {
  if (alert_modify_ != NULL) alert_modify_->::app::terminal::AlertModifyNotification::Clear();
  clear_has_alert_modify();
}
inline const ::app::terminal::AlertModifyNotification& Indication::alert_modify() const {
  return alert_modify_ != NULL ? *alert_modify_ : *default_instance_->alert_modify_;
}
inline ::app::terminal::AlertModifyNotification* Indication::mutable_alert_modify() {
  set_has_alert_modify();
  if (alert_modify_ == NULL) alert_modify_ = new ::app::terminal::AlertModifyNotification;
  return alert_modify_;
}
inline ::app::terminal::AlertModifyNotification* Indication::release_alert_modify() {
  clear_has_alert_modify();
  ::app::terminal::AlertModifyNotification* temp = alert_modify_;
  alert_modify_ = NULL;
  return temp;
}
inline void Indication::set_allocated_alert_modify(::app::terminal::AlertModifyNotification* alert_modify) {
  delete alert_modify_;
  alert_modify_ = alert_modify;
  if (alert_modify) {
    set_has_alert_modify();
  } else {
    clear_has_alert_modify();
  }
}

// optional .app.terminal.AlertOveredNotification alert_overed = 11;
inline bool Indication::has_alert_overed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Indication::set_has_alert_overed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Indication::clear_has_alert_overed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Indication::clear_alert_overed() {
  if (alert_overed_ != NULL) alert_overed_->::app::terminal::AlertOveredNotification::Clear();
  clear_has_alert_overed();
}
inline const ::app::terminal::AlertOveredNotification& Indication::alert_overed() const {
  return alert_overed_ != NULL ? *alert_overed_ : *default_instance_->alert_overed_;
}
inline ::app::terminal::AlertOveredNotification* Indication::mutable_alert_overed() {
  set_has_alert_overed();
  if (alert_overed_ == NULL) alert_overed_ = new ::app::terminal::AlertOveredNotification;
  return alert_overed_;
}
inline ::app::terminal::AlertOveredNotification* Indication::release_alert_overed() {
  clear_has_alert_overed();
  ::app::terminal::AlertOveredNotification* temp = alert_overed_;
  alert_overed_ = NULL;
  return temp;
}
inline void Indication::set_allocated_alert_overed(::app::terminal::AlertOveredNotification* alert_overed) {
  delete alert_overed_;
  alert_overed_ = alert_overed;
  if (alert_overed) {
    set_has_alert_overed();
  } else {
    clear_has_alert_overed();
  }
}

// -------------------------------------------------------------------

// Message

// required .app.terminal.MSG msg_type = 1;
inline bool Message::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msg_type() {
  msg_type_ = 300001;
  clear_has_msg_type();
}
inline ::app::terminal::MSG Message::msg_type() const {
  return static_cast< ::app::terminal::MSG >(msg_type_);
}
inline void Message::set_msg_type(::app::terminal::MSG value) {
  assert(::app::terminal::MSG_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// required fixed32 sequence = 2;
inline bool Message::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Message::sequence() const {
  return sequence_;
}
inline void Message::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional fixed32 session_id = 3;
inline bool Message::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Message::session_id() const {
  return session_id_;
}
inline void Message::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .app.terminal.Request request = 4;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::app::terminal::Request::Clear();
  clear_has_request();
}
inline const ::app::terminal::Request& Message::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::app::terminal::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::app::terminal::Request;
  return request_;
}
inline ::app::terminal::Request* Message::release_request() {
  clear_has_request();
  ::app::terminal::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Message::set_allocated_request(::app::terminal::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .app.terminal.Response response = 5;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::app::terminal::Response::Clear();
  clear_has_response();
}
inline const ::app::terminal::Response& Message::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::app::terminal::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::app::terminal::Response;
  return response_;
}
inline ::app::terminal::Response* Message::release_response() {
  clear_has_response();
  ::app::terminal::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::app::terminal::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .app.terminal.Indication indication = 6;
inline bool Message::has_indication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_indication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_indication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_indication() {
  if (indication_ != NULL) indication_->::app::terminal::Indication::Clear();
  clear_has_indication();
}
inline const ::app::terminal::Indication& Message::indication() const {
  return indication_ != NULL ? *indication_ : *default_instance_->indication_;
}
inline ::app::terminal::Indication* Message::mutable_indication() {
  set_has_indication();
  if (indication_ == NULL) indication_ = new ::app::terminal::Indication;
  return indication_;
}
inline ::app::terminal::Indication* Message::release_indication() {
  clear_has_indication();
  ::app::terminal::Indication* temp = indication_;
  indication_ = NULL;
  return temp;
}
inline void Message::set_allocated_indication(::app::terminal::Indication* indication) {
  delete indication_;
  indication_ = indication;
  if (indication) {
    set_has_indication();
  } else {
    clear_has_indication();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace terminal
}  // namespace app

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::MSG>() {
  return ::app::terminal::MSG_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::CallPrivilege>() {
  return ::app::terminal::CallPrivilege_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::TokenPrivilege>() {
  return ::app::terminal::TokenPrivilege_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::GpsReportMode>() {
  return ::app::terminal::GpsReportMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::RegisterStatus>() {
  return ::app::terminal::RegisterStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::SessionStatus>() {
  return ::app::terminal::SessionStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::terminal::AlertLevel>() {
  return ::app::terminal::AlertLevel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_app_2eterminal_2eproto__INCLUDED
