// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app.dispatch.proto

#ifndef PROTOBUF_app_2edispatch_2eproto__INCLUDED
#define PROTOBUF_app_2edispatch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AppData.pb.h"
#include "EntityData.pb.h"
#include "MediaMessage.pb.h"
#include "HistoryAlert.pb.h"
// @@protoc_insertion_point(includes)

namespace app {
namespace dispatch {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_app_2edispatch_2eproto();
void protobuf_AssignDesc_app_2edispatch_2eproto();
void protobuf_ShutdownFile_app_2edispatch_2eproto();

class LoginRequest;
class LoginResponse;
class EntityRequest;
class EntityResponse;
class EntityNotification;
class EntityStatusNotification;
class AppendGroupRequest;
class AppendGroupResponse;
class ModifyGroupRequest;
class ModifyGroupResponse;
class ModifyParticipantsRequest;
class ModifyParticipantsResponse;
class ParticipantsNotification;
class JoinGroupRequestNotification;
class ParticipantStatusNotification;
class MediaMessageRequest;
class MediaMessageResponse;
class MediaMessageNotification;
class ParticipantConnectRequestNotification;
class ParticipantSpeakRequestNotification;
class InviteParticipantRequest;
class DropParticipantRequest;
class ReleaseParticipantTokenRequest;
class AppointParticipantSpeakRequest;
class JionGroupRequest;
class LeaveGroupRequest;
class SessionStatusNotification;
class SendMessageRequest;
class KickParticipantRequest;
class StartRecordRequest;
class StopRecordRequest;
class RecordStatusNotification;
class SubscribeAccountLocationRequest;
class AccountLocationNotification;
class AppendAlertRequest;
class AppendAlertResponse;
class ModifyAlertRequest;
class StopAlertRequest;
class AlertOveredNotification;
class HistoryAlertsRequest;
class HistoryAlertsResponse;
class HistoryAlertRequest;
class HistoryAlertResponse;
class HistoryAlertMessageRequest;
class HistoryAlertMessageResponse;
class DeleteHistoryAlertRequest;
class DeleteGroupRequest;
class Request;
class Response;
class Indication;
class Message;

enum MSG {
  Login_Request = 200001,
  Login_Response = 200002,
  Logout_Request = 200003,
  Logout_Response = 200004,
  Keepalive_Request = 200005,
  Keepalive_Response = 200006,
  Entity_Request = 200007,
  Entity_Response = 200008,
  Append_Group_Request = 200009,
  Append_Group_Response = 200010,
  Modify_Group_Request = 200011,
  Modify_Group_Response = 200012,
  Modify_Participants_Request = 200013,
  Modify_Participants_Response = 200014,
  Media_Message_Request = 200015,
  Media_Message_Response = 200016,
  Invite_Participant_Request = 200017,
  Invite_Participant_Response = 200018,
  Drop_Participant_Request = 200019,
  Drop_Participant_Response = 200020,
  Release_Participant_Token_Request = 200021,
  Release_Participant_Token_Response = 200022,
  Appoint_Participant_Speak_Request = 200023,
  Appoint_Participant_Speak_Response = 200024,
  Jion_Group_Request = 200025,
  Jion_Group_Response = 200026,
  Leave_Group_Request = 200027,
  Leave_Group_Response = 200028,
  Send_Message_Request = 200029,
  Send_Message_Response = 200030,
  Kick_Participant_Request = 200031,
  Kick_Participant_Response = 200032,
  Start_Record_Request = 200033,
  Start_Record_Response = 200034,
  Stop_Record_Request = 200035,
  Stop_Record_Response = 200036,
  Subscribe_Account_Location_Request = 200037,
  Subscribe_Account_Location_Response = 200038,
  Append_Alert_Request = 200039,
  Append_Alert_Response = 200040,
  Modify_Alert_Request = 200041,
  Modify_Alert_Response = 200042,
  Stop_Alert_Request = 200043,
  Stop_Alert_Response = 200044,
  History_Alerts_Request = 200045,
  History_Alerts_Response = 200046,
  History_Alert_Request = 200047,
  History_Alert_Response = 200048,
  History_Alert_Message_Request = 200049,
  History_Alert_Message_Response = 200050,
  Delete_History_Alert_Request = 200051,
  Delete_History_Alert_Response = 200052,
  Delete_Group_Request = 200053,
  Delete_Group_Response = 200054,
  Entity_Notification = 210001,
  Entity_Status_Notification = 210002,
  Participants_Notification = 210003,
  Join_Group_Request_Notification = 210004,
  Participant_Status_Notification = 210005,
  Media_Message_Notification = 210006,
  Participant_Connect_Request_Notification = 210007,
  Participant_Speak_Request_Notification = 210008,
  Session_Status_Notification = 210009,
  Record_Status_Notification = 210010,
  Account_Location_Notification = 210011,
  Alert_Overed_Notification = 210012
};
bool MSG_IsValid(int value);
const MSG MSG_MIN = Login_Request;
const MSG MSG_MAX = Alert_Overed_Notification;
const int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_descriptor();
inline const ::std::string& MSG_Name(MSG value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_descriptor(), value);
}
inline bool MSG_Parse(
    const ::std::string& name, MSG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:app.dispatch.LoginRequest)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .pbmsg.User self = 2;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 2;
  inline const ::pbmsg::User& self() const;
  inline ::pbmsg::User* mutable_self();
  inline ::pbmsg::User* release_self();
  inline void set_allocated_self(::pbmsg::User* self);

  // required fixed32 ttl = 3;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 3;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.LoginResponse)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::User* self_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 ttl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class EntityRequest : public ::google::protobuf::Message {
 public:
  EntityRequest();
  virtual ~EntityRequest();

  EntityRequest(const EntityRequest& from);

  inline EntityRequest& operator=(const EntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityRequest& default_instance();

  void Swap(EntityRequest* other);

  // implements Message ----------------------------------------------

  EntityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityRequest& from);
  void MergeFrom(const EntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // @@protoc_insertion_point(class_scope:app.dispatch.EntityRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static EntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntityResponse : public ::google::protobuf::Message {
 public:
  EntityResponse();
  virtual ~EntityResponse();

  EntityResponse(const EntityResponse& from);

  inline EntityResponse& operator=(const EntityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityResponse& default_instance();

  void Swap(EntityResponse* other);

  // implements Message ----------------------------------------------

  EntityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityResponse& from);
  void MergeFrom(const EntityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.dispatch.EntityResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static EntityResponse* default_instance_;
};
// -------------------------------------------------------------------

class EntityNotification : public ::google::protobuf::Message {
 public:
  EntityNotification();
  virtual ~EntityNotification();

  EntityNotification(const EntityNotification& from);

  inline EntityNotification& operator=(const EntityNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityNotification& default_instance();

  void Swap(EntityNotification* other);

  // implements Message ----------------------------------------------

  EntityNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityNotification& from);
  void MergeFrom(const EntityNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityNotifyType notify_type = 1;
  inline bool has_notify_type() const;
  inline void clear_notify_type();
  static const int kNotifyTypeFieldNumber = 1;
  inline ::pbmsg::EntityNotifyType notify_type() const;
  inline void set_notify_type(::pbmsg::EntityNotifyType value);

  // required .pbmsg.EntityData data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.dispatch.EntityNotification)
 private:
  inline void set_has_notify_type();
  inline void clear_has_notify_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;
  int notify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static EntityNotification* default_instance_;
};
// -------------------------------------------------------------------

class EntityStatusNotification : public ::google::protobuf::Message {
 public:
  EntityStatusNotification();
  virtual ~EntityStatusNotification();

  EntityStatusNotification(const EntityStatusNotification& from);

  inline EntityStatusNotification& operator=(const EntityStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityStatusNotification& default_instance();

  void Swap(EntityStatusNotification* other);

  // implements Message ----------------------------------------------

  EntityStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityStatusNotification& from);
  void MergeFrom(const EntityStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // required .pbmsg.RegisterStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::pbmsg::RegisterStatus status() const;
  inline void set_status(::pbmsg::RegisterStatus value);

  // optional .pbmsg.RegisterStatus sip_status = 3;
  inline bool has_sip_status() const;
  inline void clear_sip_status();
  static const int kSipStatusFieldNumber = 3;
  inline ::pbmsg::RegisterStatus sip_status() const;
  inline void set_sip_status(::pbmsg::RegisterStatus value);

  // @@protoc_insertion_point(class_scope:app.dispatch.EntityStatusNotification)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sip_status();
  inline void clear_has_sip_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;
  int status_;
  int sip_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static EntityStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class AppendGroupRequest : public ::google::protobuf::Message {
 public:
  AppendGroupRequest();
  virtual ~AppendGroupRequest();

  AppendGroupRequest(const AppendGroupRequest& from);

  inline AppendGroupRequest& operator=(const AppendGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendGroupRequest& default_instance();

  void Swap(AppendGroupRequest* other);

  // implements Message ----------------------------------------------

  AppendGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendGroupRequest& from);
  void MergeFrom(const AppendGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Group group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::pbmsg::Group& group() const;
  inline ::pbmsg::Group* mutable_group();
  inline ::pbmsg::Group* release_group();
  inline void set_allocated_group(::pbmsg::Group* group);

  // @@protoc_insertion_point(class_scope:app.dispatch.AppendGroupRequest)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Group* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AppendGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppendGroupResponse : public ::google::protobuf::Message {
 public:
  AppendGroupResponse();
  virtual ~AppendGroupResponse();

  AppendGroupResponse(const AppendGroupResponse& from);

  inline AppendGroupResponse& operator=(const AppendGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendGroupResponse& default_instance();

  void Swap(AppendGroupResponse* other);

  // implements Message ----------------------------------------------

  AppendGroupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendGroupResponse& from);
  void MergeFrom(const AppendGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Group group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::pbmsg::Group& group() const;
  inline ::pbmsg::Group* mutable_group();
  inline ::pbmsg::Group* release_group();
  inline void set_allocated_group(::pbmsg::Group* group);

  // @@protoc_insertion_point(class_scope:app.dispatch.AppendGroupResponse)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Group* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AppendGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupRequest : public ::google::protobuf::Message {
 public:
  ModifyGroupRequest();
  virtual ~ModifyGroupRequest();

  ModifyGroupRequest(const ModifyGroupRequest& from);

  inline ModifyGroupRequest& operator=(const ModifyGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupRequest& default_instance();

  void Swap(ModifyGroupRequest* other);

  // implements Message ----------------------------------------------

  ModifyGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyGroupRequest& from);
  void MergeFrom(const ModifyGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Group group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::pbmsg::Group& group() const;
  inline ::pbmsg::Group* mutable_group();
  inline ::pbmsg::Group* release_group();
  inline void set_allocated_group(::pbmsg::Group* group);

  // @@protoc_insertion_point(class_scope:app.dispatch.ModifyGroupRequest)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Group* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupResponse : public ::google::protobuf::Message {
 public:
  ModifyGroupResponse();
  virtual ~ModifyGroupResponse();

  ModifyGroupResponse(const ModifyGroupResponse& from);

  inline ModifyGroupResponse& operator=(const ModifyGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupResponse& default_instance();

  void Swap(ModifyGroupResponse* other);

  // implements Message ----------------------------------------------

  ModifyGroupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyGroupResponse& from);
  void MergeFrom(const ModifyGroupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Group group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::pbmsg::Group& group() const;
  inline ::pbmsg::Group* mutable_group();
  inline ::pbmsg::Group* release_group();
  inline void set_allocated_group(::pbmsg::Group* group);

  // @@protoc_insertion_point(class_scope:app.dispatch.ModifyGroupResponse)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Group* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyParticipantsRequest : public ::google::protobuf::Message {
 public:
  ModifyParticipantsRequest();
  virtual ~ModifyParticipantsRequest();

  ModifyParticipantsRequest(const ModifyParticipantsRequest& from);

  inline ModifyParticipantsRequest& operator=(const ModifyParticipantsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyParticipantsRequest& default_instance();

  void Swap(ModifyParticipantsRequest* other);

  // implements Message ----------------------------------------------

  ModifyParticipantsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyParticipantsRequest& from);
  void MergeFrom(const ModifyParticipantsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.ListModifyType modify_type = 2;
  inline bool has_modify_type() const;
  inline void clear_modify_type();
  static const int kModifyTypeFieldNumber = 2;
  inline ::pbmsg::ListModifyType modify_type() const;
  inline void set_modify_type(::pbmsg::ListModifyType value);

  // repeated .pbmsg.Participant particiapnts = 3;
  inline int particiapnts_size() const;
  inline void clear_particiapnts();
  static const int kParticiapntsFieldNumber = 3;
  inline const ::pbmsg::Participant& particiapnts(int index) const;
  inline ::pbmsg::Participant* mutable_particiapnts(int index);
  inline ::pbmsg::Participant* add_particiapnts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
      particiapnts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
      mutable_particiapnts();

  // @@protoc_insertion_point(class_scope:app.dispatch.ModifyParticipantsRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_modify_type();
  inline void clear_has_modify_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant > particiapnts_;
  int modify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ModifyParticipantsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModifyParticipantsResponse : public ::google::protobuf::Message {
 public:
  ModifyParticipantsResponse();
  virtual ~ModifyParticipantsResponse();

  ModifyParticipantsResponse(const ModifyParticipantsResponse& from);

  inline ModifyParticipantsResponse& operator=(const ModifyParticipantsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyParticipantsResponse& default_instance();

  void Swap(ModifyParticipantsResponse* other);

  // implements Message ----------------------------------------------

  ModifyParticipantsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyParticipantsResponse& from);
  void MergeFrom(const ModifyParticipantsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.ListModifyType modify_type = 2;
  inline bool has_modify_type() const;
  inline void clear_modify_type();
  static const int kModifyTypeFieldNumber = 2;
  inline ::pbmsg::ListModifyType modify_type() const;
  inline void set_modify_type(::pbmsg::ListModifyType value);

  // repeated .pbmsg.Participant particiapnts = 3;
  inline int particiapnts_size() const;
  inline void clear_particiapnts();
  static const int kParticiapntsFieldNumber = 3;
  inline const ::pbmsg::Participant& particiapnts(int index) const;
  inline ::pbmsg::Participant* mutable_particiapnts(int index);
  inline ::pbmsg::Participant* add_particiapnts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
      particiapnts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
      mutable_particiapnts();

  // @@protoc_insertion_point(class_scope:app.dispatch.ModifyParticipantsResponse)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_modify_type();
  inline void clear_has_modify_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant > particiapnts_;
  int modify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ModifyParticipantsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ParticipantsNotification : public ::google::protobuf::Message {
 public:
  ParticipantsNotification();
  virtual ~ParticipantsNotification();

  ParticipantsNotification(const ParticipantsNotification& from);

  inline ParticipantsNotification& operator=(const ParticipantsNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticipantsNotification& default_instance();

  void Swap(ParticipantsNotification* other);

  // implements Message ----------------------------------------------

  ParticipantsNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticipantsNotification& from);
  void MergeFrom(const ParticipantsNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.ListModifyType modify_type = 2;
  inline bool has_modify_type() const;
  inline void clear_modify_type();
  static const int kModifyTypeFieldNumber = 2;
  inline ::pbmsg::ListModifyType modify_type() const;
  inline void set_modify_type(::pbmsg::ListModifyType value);

  // repeated .pbmsg.Participant particiapnts = 3;
  inline int particiapnts_size() const;
  inline void clear_particiapnts();
  static const int kParticiapntsFieldNumber = 3;
  inline const ::pbmsg::Participant& particiapnts(int index) const;
  inline ::pbmsg::Participant* mutable_particiapnts(int index);
  inline ::pbmsg::Participant* add_particiapnts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
      particiapnts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
      mutable_particiapnts();

  // @@protoc_insertion_point(class_scope:app.dispatch.ParticipantsNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_modify_type();
  inline void clear_has_modify_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant > particiapnts_;
  int modify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ParticipantsNotification* default_instance_;
};
// -------------------------------------------------------------------

class JoinGroupRequestNotification : public ::google::protobuf::Message {
 public:
  JoinGroupRequestNotification();
  virtual ~JoinGroupRequestNotification();

  JoinGroupRequestNotification(const JoinGroupRequestNotification& from);

  inline JoinGroupRequestNotification& operator=(const JoinGroupRequestNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGroupRequestNotification& default_instance();

  void Swap(JoinGroupRequestNotification* other);

  // implements Message ----------------------------------------------

  JoinGroupRequestNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinGroupRequestNotification& from);
  void MergeFrom(const JoinGroupRequestNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.JoinGroupRequestNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static JoinGroupRequestNotification* default_instance_;
};
// -------------------------------------------------------------------

class ParticipantStatusNotification : public ::google::protobuf::Message {
 public:
  ParticipantStatusNotification();
  virtual ~ParticipantStatusNotification();

  ParticipantStatusNotification(const ParticipantStatusNotification& from);

  inline ParticipantStatusNotification& operator=(const ParticipantStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticipantStatusNotification& default_instance();

  void Swap(ParticipantStatusNotification* other);

  // implements Message ----------------------------------------------

  ParticipantStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticipantStatusNotification& from);
  void MergeFrom(const ParticipantStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // required .pbmsg.SessionStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::pbmsg::SessionStatus status() const;
  inline void set_status(::pbmsg::SessionStatus value);

  // @@protoc_insertion_point(class_scope:app.dispatch.ParticipantStatusNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ParticipantStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageRequest : public ::google::protobuf::Message {
 public:
  MediaMessageRequest();
  virtual ~MediaMessageRequest();

  MediaMessageRequest(const MediaMessageRequest& from);

  inline MediaMessageRequest& operator=(const MediaMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageRequest& default_instance();

  void Swap(MediaMessageRequest* other);

  // implements Message ----------------------------------------------

  MediaMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageRequest& from);
  void MergeFrom(const MediaMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // optional fixed32 from_message_id = 2;
  inline bool has_from_message_id() const;
  inline void clear_from_message_id();
  static const int kFromMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_message_id() const;
  inline void set_from_message_id(::google::protobuf::uint32 value);

  // optional string from_time = 3;
  inline bool has_from_time() const;
  inline void clear_from_time();
  static const int kFromTimeFieldNumber = 3;
  inline const ::std::string& from_time() const;
  inline void set_from_time(const ::std::string& value);
  inline void set_from_time(const char* value);
  inline void set_from_time(const char* value, size_t size);
  inline ::std::string* mutable_from_time();
  inline ::std::string* release_from_time();
  inline void set_allocated_from_time(::std::string* from_time);

  // required fixed32 max_message_count = 4;
  inline bool has_max_message_count() const;
  inline void clear_max_message_count();
  static const int kMaxMessageCountFieldNumber = 4;
  inline ::google::protobuf::uint32 max_message_count() const;
  inline void set_max_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.MediaMessageRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_from_message_id();
  inline void clear_has_from_message_id();
  inline void set_has_from_time();
  inline void clear_has_from_time();
  inline void set_has_max_message_count();
  inline void clear_has_max_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;
  ::std::string* from_time_;
  ::google::protobuf::uint32 from_message_id_;
  ::google::protobuf::uint32 max_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageResponse : public ::google::protobuf::Message {
 public:
  MediaMessageResponse();
  virtual ~MediaMessageResponse();

  MediaMessageResponse(const MediaMessageResponse& from);

  inline MediaMessageResponse& operator=(const MediaMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageResponse& default_instance();

  void Swap(MediaMessageResponse* other);

  // implements Message ----------------------------------------------

  MediaMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageResponse& from);
  void MergeFrom(const MediaMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // repeated .pbmsg.MediaMessage messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::pbmsg::MediaMessage& messages(int index) const;
  inline ::pbmsg::MediaMessage* mutable_messages(int index);
  inline ::pbmsg::MediaMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >*
      mutable_messages();

  // required fixed32 leave_message_count = 3;
  inline bool has_leave_message_count() const;
  inline void clear_leave_message_count();
  static const int kLeaveMessageCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leave_message_count() const;
  inline void set_leave_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.MediaMessageResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_leave_message_count();
  inline void clear_has_leave_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage > messages_;
  ::google::protobuf::uint32 leave_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class MediaMessageNotification : public ::google::protobuf::Message {
 public:
  MediaMessageNotification();
  virtual ~MediaMessageNotification();

  MediaMessageNotification(const MediaMessageNotification& from);

  inline MediaMessageNotification& operator=(const MediaMessageNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaMessageNotification& default_instance();

  void Swap(MediaMessageNotification* other);

  // implements Message ----------------------------------------------

  MediaMessageNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaMessageNotification& from);
  void MergeFrom(const MediaMessageNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // required .pbmsg.MediaMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::pbmsg::MediaMessage& msg() const;
  inline ::pbmsg::MediaMessage* mutable_msg();
  inline ::pbmsg::MediaMessage* release_msg();
  inline void set_allocated_msg(::pbmsg::MediaMessage* msg);

  // @@protoc_insertion_point(class_scope:app.dispatch.MediaMessageNotification)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;
  ::pbmsg::MediaMessage* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static MediaMessageNotification* default_instance_;
};
// -------------------------------------------------------------------

class ParticipantConnectRequestNotification : public ::google::protobuf::Message {
 public:
  ParticipantConnectRequestNotification();
  virtual ~ParticipantConnectRequestNotification();

  ParticipantConnectRequestNotification(const ParticipantConnectRequestNotification& from);

  inline ParticipantConnectRequestNotification& operator=(const ParticipantConnectRequestNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticipantConnectRequestNotification& default_instance();

  void Swap(ParticipantConnectRequestNotification* other);

  // implements Message ----------------------------------------------

  ParticipantConnectRequestNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticipantConnectRequestNotification& from);
  void MergeFrom(const ParticipantConnectRequestNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.ParticipantConnectRequestNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ParticipantConnectRequestNotification* default_instance_;
};
// -------------------------------------------------------------------

class ParticipantSpeakRequestNotification : public ::google::protobuf::Message {
 public:
  ParticipantSpeakRequestNotification();
  virtual ~ParticipantSpeakRequestNotification();

  ParticipantSpeakRequestNotification(const ParticipantSpeakRequestNotification& from);

  inline ParticipantSpeakRequestNotification& operator=(const ParticipantSpeakRequestNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParticipantSpeakRequestNotification& default_instance();

  void Swap(ParticipantSpeakRequestNotification* other);

  // implements Message ----------------------------------------------

  ParticipantSpeakRequestNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParticipantSpeakRequestNotification& from);
  void MergeFrom(const ParticipantSpeakRequestNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.ParticipantSpeakRequestNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ParticipantSpeakRequestNotification* default_instance_;
};
// -------------------------------------------------------------------

class InviteParticipantRequest : public ::google::protobuf::Message {
 public:
  InviteParticipantRequest();
  virtual ~InviteParticipantRequest();

  InviteParticipantRequest(const InviteParticipantRequest& from);

  inline InviteParticipantRequest& operator=(const InviteParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InviteParticipantRequest& default_instance();

  void Swap(InviteParticipantRequest* other);

  // implements Message ----------------------------------------------

  InviteParticipantRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InviteParticipantRequest& from);
  void MergeFrom(const InviteParticipantRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.InviteParticipantRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static InviteParticipantRequest* default_instance_;
};
// -------------------------------------------------------------------

class DropParticipantRequest : public ::google::protobuf::Message {
 public:
  DropParticipantRequest();
  virtual ~DropParticipantRequest();

  DropParticipantRequest(const DropParticipantRequest& from);

  inline DropParticipantRequest& operator=(const DropParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropParticipantRequest& default_instance();

  void Swap(DropParticipantRequest* other);

  // implements Message ----------------------------------------------

  DropParticipantRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropParticipantRequest& from);
  void MergeFrom(const DropParticipantRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.DropParticipantRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static DropParticipantRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseParticipantTokenRequest : public ::google::protobuf::Message {
 public:
  ReleaseParticipantTokenRequest();
  virtual ~ReleaseParticipantTokenRequest();

  ReleaseParticipantTokenRequest(const ReleaseParticipantTokenRequest& from);

  inline ReleaseParticipantTokenRequest& operator=(const ReleaseParticipantTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseParticipantTokenRequest& default_instance();

  void Swap(ReleaseParticipantTokenRequest* other);

  // implements Message ----------------------------------------------

  ReleaseParticipantTokenRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseParticipantTokenRequest& from);
  void MergeFrom(const ReleaseParticipantTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.ReleaseParticipantTokenRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ReleaseParticipantTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppointParticipantSpeakRequest : public ::google::protobuf::Message {
 public:
  AppointParticipantSpeakRequest();
  virtual ~AppointParticipantSpeakRequest();

  AppointParticipantSpeakRequest(const AppointParticipantSpeakRequest& from);

  inline AppointParticipantSpeakRequest& operator=(const AppointParticipantSpeakRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppointParticipantSpeakRequest& default_instance();

  void Swap(AppointParticipantSpeakRequest* other);

  // implements Message ----------------------------------------------

  AppointParticipantSpeakRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppointParticipantSpeakRequest& from);
  void MergeFrom(const AppointParticipantSpeakRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.AppointParticipantSpeakRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AppointParticipantSpeakRequest* default_instance_;
};
// -------------------------------------------------------------------

class JionGroupRequest : public ::google::protobuf::Message {
 public:
  JionGroupRequest();
  virtual ~JionGroupRequest();

  JionGroupRequest(const JionGroupRequest& from);

  inline JionGroupRequest& operator=(const JionGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JionGroupRequest& default_instance();

  void Swap(JionGroupRequest* other);

  // implements Message ----------------------------------------------

  JionGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JionGroupRequest& from);
  void MergeFrom(const JionGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.JionGroupRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static JionGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGroupRequest : public ::google::protobuf::Message {
 public:
  LeaveGroupRequest();
  virtual ~LeaveGroupRequest();

  LeaveGroupRequest(const LeaveGroupRequest& from);

  inline LeaveGroupRequest& operator=(const LeaveGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveGroupRequest& default_instance();

  void Swap(LeaveGroupRequest* other);

  // implements Message ----------------------------------------------

  LeaveGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveGroupRequest& from);
  void MergeFrom(const LeaveGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.LeaveGroupRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static LeaveGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class SessionStatusNotification : public ::google::protobuf::Message {
 public:
  SessionStatusNotification();
  virtual ~SessionStatusNotification();

  SessionStatusNotification(const SessionStatusNotification& from);

  inline SessionStatusNotification& operator=(const SessionStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStatusNotification& default_instance();

  void Swap(SessionStatusNotification* other);

  // implements Message ----------------------------------------------

  SessionStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionStatusNotification& from);
  void MergeFrom(const SessionStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.SessionStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::pbmsg::SessionStatus status() const;
  inline void set_status(::pbmsg::SessionStatus value);

  // @@protoc_insertion_point(class_scope:app.dispatch.SessionStatusNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static SessionStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageRequest : public ::google::protobuf::Message {
 public:
  SendMessageRequest();
  virtual ~SendMessageRequest();

  SendMessageRequest(const SendMessageRequest& from);

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageRequest& default_instance();

  void Swap(SendMessageRequest* other);

  // implements Message ----------------------------------------------

  SendMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageRequest& from);
  void MergeFrom(const SendMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // required .pbmsg.MediaMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::pbmsg::MediaMessage& msg() const;
  inline ::pbmsg::MediaMessage* mutable_msg();
  inline ::pbmsg::MediaMessage* release_msg();
  inline void set_allocated_msg(::pbmsg::MediaMessage* msg);

  // @@protoc_insertion_point(class_scope:app.dispatch.SendMessageRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;
  ::pbmsg::MediaMessage* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static SendMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class KickParticipantRequest : public ::google::protobuf::Message {
 public:
  KickParticipantRequest();
  virtual ~KickParticipantRequest();

  KickParticipantRequest(const KickParticipantRequest& from);

  inline KickParticipantRequest& operator=(const KickParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickParticipantRequest& default_instance();

  void Swap(KickParticipantRequest* other);

  // implements Message ----------------------------------------------

  KickParticipantRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickParticipantRequest& from);
  void MergeFrom(const KickParticipantRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.KickParticipantRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  ::pbmsg::Entity* account_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static KickParticipantRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartRecordRequest : public ::google::protobuf::Message {
 public:
  StartRecordRequest();
  virtual ~StartRecordRequest();

  StartRecordRequest(const StartRecordRequest& from);

  inline StartRecordRequest& operator=(const StartRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartRecordRequest& default_instance();

  void Swap(StartRecordRequest* other);

  // implements Message ----------------------------------------------

  StartRecordRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartRecordRequest& from);
  void MergeFrom(const StartRecordRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.StartRecordRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static StartRecordRequest* default_instance_;
};
// -------------------------------------------------------------------

class StopRecordRequest : public ::google::protobuf::Message {
 public:
  StopRecordRequest();
  virtual ~StopRecordRequest();

  StopRecordRequest(const StopRecordRequest& from);

  inline StopRecordRequest& operator=(const StopRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopRecordRequest& default_instance();

  void Swap(StopRecordRequest* other);

  // implements Message ----------------------------------------------

  StopRecordRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopRecordRequest& from);
  void MergeFrom(const StopRecordRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.StopRecordRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static StopRecordRequest* default_instance_;
};
// -------------------------------------------------------------------

class RecordStatusNotification : public ::google::protobuf::Message {
 public:
  RecordStatusNotification();
  virtual ~RecordStatusNotification();

  RecordStatusNotification(const RecordStatusNotification& from);

  inline RecordStatusNotification& operator=(const RecordStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordStatusNotification& default_instance();

  void Swap(RecordStatusNotification* other);

  // implements Message ----------------------------------------------

  RecordStatusNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordStatusNotification& from);
  void MergeFrom(const RecordStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // required bool recording = 2;
  inline bool has_recording() const;
  inline void clear_recording();
  static const int kRecordingFieldNumber = 2;
  inline bool recording() const;
  inline void set_recording(bool value);

  // @@protoc_insertion_point(class_scope:app.dispatch.RecordStatusNotification)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_recording();
  inline void clear_has_recording();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;
  bool recording_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static RecordStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeAccountLocationRequest : public ::google::protobuf::Message {
 public:
  SubscribeAccountLocationRequest();
  virtual ~SubscribeAccountLocationRequest();

  SubscribeAccountLocationRequest(const SubscribeAccountLocationRequest& from);

  inline SubscribeAccountLocationRequest& operator=(const SubscribeAccountLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeAccountLocationRequest& default_instance();

  void Swap(SubscribeAccountLocationRequest* other);

  // implements Message ----------------------------------------------

  SubscribeAccountLocationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeAccountLocationRequest& from);
  void MergeFrom(const SubscribeAccountLocationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool subscribing = 1;
  inline bool has_subscribing() const;
  inline void clear_subscribing();
  static const int kSubscribingFieldNumber = 1;
  inline bool subscribing() const;
  inline void set_subscribing(bool value);

  // required .pbmsg.Entity account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // required fixed32 ttl = 3;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 3;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.SubscribeAccountLocationRequest)
 private:
  inline void set_has_subscribing();
  inline void clear_has_subscribing();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* account_id_;
  bool subscribing_;
  ::google::protobuf::uint32 ttl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static SubscribeAccountLocationRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountLocationNotification : public ::google::protobuf::Message {
 public:
  AccountLocationNotification();
  virtual ~AccountLocationNotification();

  AccountLocationNotification(const AccountLocationNotification& from);

  inline AccountLocationNotification& operator=(const AccountLocationNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLocationNotification& default_instance();

  void Swap(AccountLocationNotification* other);

  // implements Message ----------------------------------------------

  AccountLocationNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLocationNotification& from);
  void MergeFrom(const AccountLocationNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::pbmsg::Entity& account_id() const;
  inline ::pbmsg::Entity* mutable_account_id();
  inline ::pbmsg::Entity* release_account_id();
  inline void set_allocated_account_id(::pbmsg::Entity* account_id);

  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // required double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);

  // required string timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:app.dispatch.AccountLocationNotification)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* account_id_;
  double longitude_;
  double latitude_;
  ::std::string* timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AccountLocationNotification* default_instance_;
};
// -------------------------------------------------------------------

class AppendAlertRequest : public ::google::protobuf::Message {
 public:
  AppendAlertRequest();
  virtual ~AppendAlertRequest();

  AppendAlertRequest(const AppendAlertRequest& from);

  inline AppendAlertRequest& operator=(const AppendAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendAlertRequest& default_instance();

  void Swap(AppendAlertRequest* other);

  // implements Message ----------------------------------------------

  AppendAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendAlertRequest& from);
  void MergeFrom(const AppendAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Alert alert = 1;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 1;
  inline const ::pbmsg::Alert& alert() const;
  inline ::pbmsg::Alert* mutable_alert();
  inline ::pbmsg::Alert* release_alert();
  inline void set_allocated_alert(::pbmsg::Alert* alert);

  // repeated .pbmsg.Entity members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::pbmsg::Entity& members(int index) const;
  inline ::pbmsg::Entity* mutable_members(int index);
  inline ::pbmsg::Entity* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:app.dispatch.AppendAlertRequest)
 private:
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Alert* alert_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AppendAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppendAlertResponse : public ::google::protobuf::Message {
 public:
  AppendAlertResponse();
  virtual ~AppendAlertResponse();

  AppendAlertResponse(const AppendAlertResponse& from);

  inline AppendAlertResponse& operator=(const AppendAlertResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendAlertResponse& default_instance();

  void Swap(AppendAlertResponse* other);

  // implements Message ----------------------------------------------

  AppendAlertResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendAlertResponse& from);
  void MergeFrom(const AppendAlertResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Alert alert = 1;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 1;
  inline const ::pbmsg::Alert& alert() const;
  inline ::pbmsg::Alert* mutable_alert();
  inline ::pbmsg::Alert* release_alert();
  inline void set_allocated_alert(::pbmsg::Alert* alert);

  // @@protoc_insertion_point(class_scope:app.dispatch.AppendAlertResponse)
 private:
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Alert* alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AppendAlertResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyAlertRequest : public ::google::protobuf::Message {
 public:
  ModifyAlertRequest();
  virtual ~ModifyAlertRequest();

  ModifyAlertRequest(const ModifyAlertRequest& from);

  inline ModifyAlertRequest& operator=(const ModifyAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyAlertRequest& default_instance();

  void Swap(ModifyAlertRequest* other);

  // implements Message ----------------------------------------------

  ModifyAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyAlertRequest& from);
  void MergeFrom(const ModifyAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Alert alert = 1;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 1;
  inline const ::pbmsg::Alert& alert() const;
  inline ::pbmsg::Alert* mutable_alert();
  inline ::pbmsg::Alert* release_alert();
  inline void set_allocated_alert(::pbmsg::Alert* alert);

  // @@protoc_insertion_point(class_scope:app.dispatch.ModifyAlertRequest)
 private:
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Alert* alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static ModifyAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class StopAlertRequest : public ::google::protobuf::Message {
 public:
  StopAlertRequest();
  virtual ~StopAlertRequest();

  StopAlertRequest(const StopAlertRequest& from);

  inline StopAlertRequest& operator=(const StopAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopAlertRequest& default_instance();

  void Swap(StopAlertRequest* other);

  // implements Message ----------------------------------------------

  StopAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopAlertRequest& from);
  void MergeFrom(const StopAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline const ::pbmsg::Entity& alert_id() const;
  inline ::pbmsg::Entity* mutable_alert_id();
  inline ::pbmsg::Entity* release_alert_id();
  inline void set_allocated_alert_id(::pbmsg::Entity* alert_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.StopAlertRequest)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static StopAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class AlertOveredNotification : public ::google::protobuf::Message {
 public:
  AlertOveredNotification();
  virtual ~AlertOveredNotification();

  AlertOveredNotification(const AlertOveredNotification& from);

  inline AlertOveredNotification& operator=(const AlertOveredNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertOveredNotification& default_instance();

  void Swap(AlertOveredNotification* other);

  // implements Message ----------------------------------------------

  AlertOveredNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertOveredNotification& from);
  void MergeFrom(const AlertOveredNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity alert_id = 1;
  inline bool has_alert_id() const;
  inline void clear_alert_id();
  static const int kAlertIdFieldNumber = 1;
  inline const ::pbmsg::Entity& alert_id() const;
  inline ::pbmsg::Entity* mutable_alert_id();
  inline ::pbmsg::Entity* release_alert_id();
  inline void set_allocated_alert_id(::pbmsg::Entity* alert_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.AlertOveredNotification)
 private:
  inline void set_has_alert_id();
  inline void clear_has_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static AlertOveredNotification* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertsRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertsRequest();
  virtual ~HistoryAlertsRequest();

  HistoryAlertsRequest(const HistoryAlertsRequest& from);

  inline HistoryAlertsRequest& operator=(const HistoryAlertsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertsRequest& default_instance();

  void Swap(HistoryAlertsRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertsRequest& from);
  void MergeFrom(const HistoryAlertsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string create_time_from = 2;
  inline bool has_create_time_from() const;
  inline void clear_create_time_from();
  static const int kCreateTimeFromFieldNumber = 2;
  inline const ::std::string& create_time_from() const;
  inline void set_create_time_from(const ::std::string& value);
  inline void set_create_time_from(const char* value);
  inline void set_create_time_from(const char* value, size_t size);
  inline ::std::string* mutable_create_time_from();
  inline ::std::string* release_create_time_from();
  inline void set_allocated_create_time_from(::std::string* create_time_from);

  // optional string create_time_to = 3;
  inline bool has_create_time_to() const;
  inline void clear_create_time_to();
  static const int kCreateTimeToFieldNumber = 3;
  inline const ::std::string& create_time_to() const;
  inline void set_create_time_to(const ::std::string& value);
  inline void set_create_time_to(const char* value);
  inline void set_create_time_to(const char* value, size_t size);
  inline ::std::string* mutable_create_time_to();
  inline ::std::string* release_create_time_to();
  inline void set_allocated_create_time_to(::std::string* create_time_to);

  // optional string alram_time_from = 4;
  inline bool has_alram_time_from() const;
  inline void clear_alram_time_from();
  static const int kAlramTimeFromFieldNumber = 4;
  inline const ::std::string& alram_time_from() const;
  inline void set_alram_time_from(const ::std::string& value);
  inline void set_alram_time_from(const char* value);
  inline void set_alram_time_from(const char* value, size_t size);
  inline ::std::string* mutable_alram_time_from();
  inline ::std::string* release_alram_time_from();
  inline void set_allocated_alram_time_from(::std::string* alram_time_from);

  // optional string alram_time_to = 5;
  inline bool has_alram_time_to() const;
  inline void clear_alram_time_to();
  static const int kAlramTimeToFieldNumber = 5;
  inline const ::std::string& alram_time_to() const;
  inline void set_alram_time_to(const ::std::string& value);
  inline void set_alram_time_to(const char* value);
  inline void set_alram_time_to(const char* value, size_t size);
  inline ::std::string* mutable_alram_time_to();
  inline ::std::string* release_alram_time_to();
  inline void set_allocated_alram_time_to(::std::string* alram_time_to);

  // optional string over_time_from = 6;
  inline bool has_over_time_from() const;
  inline void clear_over_time_from();
  static const int kOverTimeFromFieldNumber = 6;
  inline const ::std::string& over_time_from() const;
  inline void set_over_time_from(const ::std::string& value);
  inline void set_over_time_from(const char* value);
  inline void set_over_time_from(const char* value, size_t size);
  inline ::std::string* mutable_over_time_from();
  inline ::std::string* release_over_time_from();
  inline void set_allocated_over_time_from(::std::string* over_time_from);

  // optional string over_time_to = 7;
  inline bool has_over_time_to() const;
  inline void clear_over_time_to();
  static const int kOverTimeToFieldNumber = 7;
  inline const ::std::string& over_time_to() const;
  inline void set_over_time_to(const ::std::string& value);
  inline void set_over_time_to(const char* value);
  inline void set_over_time_to(const char* value, size_t size);
  inline ::std::string* mutable_over_time_to();
  inline ::std::string* release_over_time_to();
  inline void set_allocated_over_time_to(::std::string* over_time_to);

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertsRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_create_time_from();
  inline void clear_has_create_time_from();
  inline void set_has_create_time_to();
  inline void clear_has_create_time_to();
  inline void set_has_alram_time_from();
  inline void clear_has_alram_time_from();
  inline void set_has_alram_time_to();
  inline void clear_has_alram_time_to();
  inline void set_has_over_time_from();
  inline void clear_has_over_time_from();
  inline void set_has_over_time_to();
  inline void clear_has_over_time_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* create_time_from_;
  ::std::string* create_time_to_;
  ::std::string* alram_time_from_;
  ::std::string* alram_time_to_;
  ::std::string* over_time_from_;
  ::std::string* over_time_to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertsRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertsResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertsResponse();
  virtual ~HistoryAlertsResponse();

  HistoryAlertsResponse(const HistoryAlertsResponse& from);

  inline HistoryAlertsResponse& operator=(const HistoryAlertsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertsResponse& default_instance();

  void Swap(HistoryAlertsResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertsResponse& from);
  void MergeFrom(const HistoryAlertsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pbmsg.HistoryAlert history_alerts = 1;
  inline int history_alerts_size() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 1;
  inline const ::pbmsg::HistoryAlert& history_alerts(int index) const;
  inline ::pbmsg::HistoryAlert* mutable_history_alerts(int index);
  inline ::pbmsg::HistoryAlert* add_history_alerts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::HistoryAlert >&
      history_alerts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::HistoryAlert >*
      mutable_history_alerts();

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pbmsg::HistoryAlert > history_alerts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertsResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertRequest();
  virtual ~HistoryAlertRequest();

  HistoryAlertRequest(const HistoryAlertRequest& from);

  inline HistoryAlertRequest& operator=(const HistoryAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertRequest& default_instance();

  void Swap(HistoryAlertRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertRequest& from);
  void MergeFrom(const HistoryAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertRequest)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertResponse();
  virtual ~HistoryAlertResponse();

  HistoryAlertResponse(const HistoryAlertResponse& from);

  inline HistoryAlertResponse& operator=(const HistoryAlertResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertResponse& default_instance();

  void Swap(HistoryAlertResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertResponse& from);
  void MergeFrom(const HistoryAlertResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.HistoryAlert history_alert = 1;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 1;
  inline const ::pbmsg::HistoryAlert& history_alert() const;
  inline ::pbmsg::HistoryAlert* mutable_history_alert();
  inline ::pbmsg::HistoryAlert* release_history_alert();
  inline void set_allocated_history_alert(::pbmsg::HistoryAlert* history_alert);

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertResponse)
 private:
  inline void set_has_history_alert();
  inline void clear_has_history_alert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::HistoryAlert* history_alert_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertMessageRequest : public ::google::protobuf::Message {
 public:
  HistoryAlertMessageRequest();
  virtual ~HistoryAlertMessageRequest();

  HistoryAlertMessageRequest(const HistoryAlertMessageRequest& from);

  inline HistoryAlertMessageRequest& operator=(const HistoryAlertMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertMessageRequest& default_instance();

  void Swap(HistoryAlertMessageRequest* other);

  // implements Message ----------------------------------------------

  HistoryAlertMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertMessageRequest& from);
  void MergeFrom(const HistoryAlertMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // optional fixed32 from_message_id = 2;
  inline bool has_from_message_id() const;
  inline void clear_from_message_id();
  static const int kFromMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_message_id() const;
  inline void set_from_message_id(::google::protobuf::uint32 value);

  // optional string from_time = 3;
  inline bool has_from_time() const;
  inline void clear_from_time();
  static const int kFromTimeFieldNumber = 3;
  inline const ::std::string& from_time() const;
  inline void set_from_time(const ::std::string& value);
  inline void set_from_time(const char* value);
  inline void set_from_time(const char* value, size_t size);
  inline ::std::string* mutable_from_time();
  inline ::std::string* release_from_time();
  inline void set_allocated_from_time(::std::string* from_time);

  // required fixed32 max_message_count = 4;
  inline bool has_max_message_count() const;
  inline void clear_max_message_count();
  static const int kMaxMessageCountFieldNumber = 4;
  inline ::google::protobuf::uint32 max_message_count() const;
  inline void set_max_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertMessageRequest)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();
  inline void set_has_from_message_id();
  inline void clear_has_from_message_id();
  inline void set_has_from_time();
  inline void clear_has_from_time();
  inline void set_has_max_message_count();
  inline void clear_has_max_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_alert_id_;
  ::google::protobuf::uint32 from_message_id_;
  ::std::string* from_time_;
  ::google::protobuf::uint32 max_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoryAlertMessageResponse : public ::google::protobuf::Message {
 public:
  HistoryAlertMessageResponse();
  virtual ~HistoryAlertMessageResponse();

  HistoryAlertMessageResponse(const HistoryAlertMessageResponse& from);

  inline HistoryAlertMessageResponse& operator=(const HistoryAlertMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryAlertMessageResponse& default_instance();

  void Swap(HistoryAlertMessageResponse* other);

  // implements Message ----------------------------------------------

  HistoryAlertMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryAlertMessageResponse& from);
  void MergeFrom(const HistoryAlertMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // repeated .pbmsg.MediaMessage messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::pbmsg::MediaMessage& messages(int index) const;
  inline ::pbmsg::MediaMessage* mutable_messages(int index);
  inline ::pbmsg::MediaMessage* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >*
      mutable_messages();

  // required fixed32 leave_message_count = 3;
  inline bool has_leave_message_count() const;
  inline void clear_leave_message_count();
  static const int kLeaveMessageCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leave_message_count() const;
  inline void set_leave_message_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.HistoryAlertMessageResponse)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();
  inline void set_has_leave_message_count();
  inline void clear_has_leave_message_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage > messages_;
  ::google::protobuf::uint32 history_alert_id_;
  ::google::protobuf::uint32 leave_message_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static HistoryAlertMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteHistoryAlertRequest : public ::google::protobuf::Message {
 public:
  DeleteHistoryAlertRequest();
  virtual ~DeleteHistoryAlertRequest();

  DeleteHistoryAlertRequest(const DeleteHistoryAlertRequest& from);

  inline DeleteHistoryAlertRequest& operator=(const DeleteHistoryAlertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteHistoryAlertRequest& default_instance();

  void Swap(DeleteHistoryAlertRequest* other);

  // implements Message ----------------------------------------------

  DeleteHistoryAlertRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteHistoryAlertRequest& from);
  void MergeFrom(const DeleteHistoryAlertRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 history_alert_id = 1;
  inline bool has_history_alert_id() const;
  inline void clear_history_alert_id();
  static const int kHistoryAlertIdFieldNumber = 1;
  inline ::google::protobuf::uint32 history_alert_id() const;
  inline void set_history_alert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.dispatch.DeleteHistoryAlertRequest)
 private:
  inline void set_has_history_alert_id();
  inline void clear_has_history_alert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 history_alert_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static DeleteHistoryAlertRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteGroupRequest : public ::google::protobuf::Message {
 public:
  DeleteGroupRequest();
  virtual ~DeleteGroupRequest();

  DeleteGroupRequest(const DeleteGroupRequest& from);

  inline DeleteGroupRequest& operator=(const DeleteGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteGroupRequest& default_instance();

  void Swap(DeleteGroupRequest* other);

  // implements Message ----------------------------------------------

  DeleteGroupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteGroupRequest& from);
  void MergeFrom(const DeleteGroupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline const ::pbmsg::Entity& group_id() const;
  inline ::pbmsg::Entity* mutable_group_id();
  inline ::pbmsg::Entity* release_group_id();
  inline void set_allocated_group_id(::pbmsg::Entity* group_id);

  // @@protoc_insertion_point(class_scope:app.dispatch.DeleteGroupRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static DeleteGroupRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.dispatch.LoginRequest login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::app::dispatch::LoginRequest& login() const;
  inline ::app::dispatch::LoginRequest* mutable_login();
  inline ::app::dispatch::LoginRequest* release_login();
  inline void set_allocated_login(::app::dispatch::LoginRequest* login);

  // optional .app.dispatch.EntityRequest entity = 2;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::app::dispatch::EntityRequest& entity() const;
  inline ::app::dispatch::EntityRequest* mutable_entity();
  inline ::app::dispatch::EntityRequest* release_entity();
  inline void set_allocated_entity(::app::dispatch::EntityRequest* entity);

  // optional .app.dispatch.AppendGroupRequest append_group = 3;
  inline bool has_append_group() const;
  inline void clear_append_group();
  static const int kAppendGroupFieldNumber = 3;
  inline const ::app::dispatch::AppendGroupRequest& append_group() const;
  inline ::app::dispatch::AppendGroupRequest* mutable_append_group();
  inline ::app::dispatch::AppendGroupRequest* release_append_group();
  inline void set_allocated_append_group(::app::dispatch::AppendGroupRequest* append_group);

  // optional .app.dispatch.ModifyGroupRequest modify_group = 4;
  inline bool has_modify_group() const;
  inline void clear_modify_group();
  static const int kModifyGroupFieldNumber = 4;
  inline const ::app::dispatch::ModifyGroupRequest& modify_group() const;
  inline ::app::dispatch::ModifyGroupRequest* mutable_modify_group();
  inline ::app::dispatch::ModifyGroupRequest* release_modify_group();
  inline void set_allocated_modify_group(::app::dispatch::ModifyGroupRequest* modify_group);

  // optional .app.dispatch.ModifyParticipantsRequest modify_participants = 5;
  inline bool has_modify_participants() const;
  inline void clear_modify_participants();
  static const int kModifyParticipantsFieldNumber = 5;
  inline const ::app::dispatch::ModifyParticipantsRequest& modify_participants() const;
  inline ::app::dispatch::ModifyParticipantsRequest* mutable_modify_participants();
  inline ::app::dispatch::ModifyParticipantsRequest* release_modify_participants();
  inline void set_allocated_modify_participants(::app::dispatch::ModifyParticipantsRequest* modify_participants);

  // optional .app.dispatch.MediaMessageRequest media_message = 6;
  inline bool has_media_message() const;
  inline void clear_media_message();
  static const int kMediaMessageFieldNumber = 6;
  inline const ::app::dispatch::MediaMessageRequest& media_message() const;
  inline ::app::dispatch::MediaMessageRequest* mutable_media_message();
  inline ::app::dispatch::MediaMessageRequest* release_media_message();
  inline void set_allocated_media_message(::app::dispatch::MediaMessageRequest* media_message);

  // optional .app.dispatch.InviteParticipantRequest invite_participant = 7;
  inline bool has_invite_participant() const;
  inline void clear_invite_participant();
  static const int kInviteParticipantFieldNumber = 7;
  inline const ::app::dispatch::InviteParticipantRequest& invite_participant() const;
  inline ::app::dispatch::InviteParticipantRequest* mutable_invite_participant();
  inline ::app::dispatch::InviteParticipantRequest* release_invite_participant();
  inline void set_allocated_invite_participant(::app::dispatch::InviteParticipantRequest* invite_participant);

  // optional .app.dispatch.DropParticipantRequest drop_participant = 8;
  inline bool has_drop_participant() const;
  inline void clear_drop_participant();
  static const int kDropParticipantFieldNumber = 8;
  inline const ::app::dispatch::DropParticipantRequest& drop_participant() const;
  inline ::app::dispatch::DropParticipantRequest* mutable_drop_participant();
  inline ::app::dispatch::DropParticipantRequest* release_drop_participant();
  inline void set_allocated_drop_participant(::app::dispatch::DropParticipantRequest* drop_participant);

  // optional .app.dispatch.ReleaseParticipantTokenRequest release_participant_token = 9;
  inline bool has_release_participant_token() const;
  inline void clear_release_participant_token();
  static const int kReleaseParticipantTokenFieldNumber = 9;
  inline const ::app::dispatch::ReleaseParticipantTokenRequest& release_participant_token() const;
  inline ::app::dispatch::ReleaseParticipantTokenRequest* mutable_release_participant_token();
  inline ::app::dispatch::ReleaseParticipantTokenRequest* release_release_participant_token();
  inline void set_allocated_release_participant_token(::app::dispatch::ReleaseParticipantTokenRequest* release_participant_token);

  // optional .app.dispatch.AppointParticipantSpeakRequest appoint_participant_speak = 10;
  inline bool has_appoint_participant_speak() const;
  inline void clear_appoint_participant_speak();
  static const int kAppointParticipantSpeakFieldNumber = 10;
  inline const ::app::dispatch::AppointParticipantSpeakRequest& appoint_participant_speak() const;
  inline ::app::dispatch::AppointParticipantSpeakRequest* mutable_appoint_participant_speak();
  inline ::app::dispatch::AppointParticipantSpeakRequest* release_appoint_participant_speak();
  inline void set_allocated_appoint_participant_speak(::app::dispatch::AppointParticipantSpeakRequest* appoint_participant_speak);

  // optional .app.dispatch.JionGroupRequest jion_group = 11;
  inline bool has_jion_group() const;
  inline void clear_jion_group();
  static const int kJionGroupFieldNumber = 11;
  inline const ::app::dispatch::JionGroupRequest& jion_group() const;
  inline ::app::dispatch::JionGroupRequest* mutable_jion_group();
  inline ::app::dispatch::JionGroupRequest* release_jion_group();
  inline void set_allocated_jion_group(::app::dispatch::JionGroupRequest* jion_group);

  // optional .app.dispatch.LeaveGroupRequest leave_group = 12;
  inline bool has_leave_group() const;
  inline void clear_leave_group();
  static const int kLeaveGroupFieldNumber = 12;
  inline const ::app::dispatch::LeaveGroupRequest& leave_group() const;
  inline ::app::dispatch::LeaveGroupRequest* mutable_leave_group();
  inline ::app::dispatch::LeaveGroupRequest* release_leave_group();
  inline void set_allocated_leave_group(::app::dispatch::LeaveGroupRequest* leave_group);

  // optional .app.dispatch.SendMessageRequest send_message = 13;
  inline bool has_send_message() const;
  inline void clear_send_message();
  static const int kSendMessageFieldNumber = 13;
  inline const ::app::dispatch::SendMessageRequest& send_message() const;
  inline ::app::dispatch::SendMessageRequest* mutable_send_message();
  inline ::app::dispatch::SendMessageRequest* release_send_message();
  inline void set_allocated_send_message(::app::dispatch::SendMessageRequest* send_message);

  // optional .app.dispatch.KickParticipantRequest kick_participant = 14;
  inline bool has_kick_participant() const;
  inline void clear_kick_participant();
  static const int kKickParticipantFieldNumber = 14;
  inline const ::app::dispatch::KickParticipantRequest& kick_participant() const;
  inline ::app::dispatch::KickParticipantRequest* mutable_kick_participant();
  inline ::app::dispatch::KickParticipantRequest* release_kick_participant();
  inline void set_allocated_kick_participant(::app::dispatch::KickParticipantRequest* kick_participant);

  // optional .app.dispatch.StartRecordRequest start_record = 15;
  inline bool has_start_record() const;
  inline void clear_start_record();
  static const int kStartRecordFieldNumber = 15;
  inline const ::app::dispatch::StartRecordRequest& start_record() const;
  inline ::app::dispatch::StartRecordRequest* mutable_start_record();
  inline ::app::dispatch::StartRecordRequest* release_start_record();
  inline void set_allocated_start_record(::app::dispatch::StartRecordRequest* start_record);

  // optional .app.dispatch.StopRecordRequest stop_record = 16;
  inline bool has_stop_record() const;
  inline void clear_stop_record();
  static const int kStopRecordFieldNumber = 16;
  inline const ::app::dispatch::StopRecordRequest& stop_record() const;
  inline ::app::dispatch::StopRecordRequest* mutable_stop_record();
  inline ::app::dispatch::StopRecordRequest* release_stop_record();
  inline void set_allocated_stop_record(::app::dispatch::StopRecordRequest* stop_record);

  // optional .app.dispatch.SubscribeAccountLocationRequest subscribe_account_location = 17;
  inline bool has_subscribe_account_location() const;
  inline void clear_subscribe_account_location();
  static const int kSubscribeAccountLocationFieldNumber = 17;
  inline const ::app::dispatch::SubscribeAccountLocationRequest& subscribe_account_location() const;
  inline ::app::dispatch::SubscribeAccountLocationRequest* mutable_subscribe_account_location();
  inline ::app::dispatch::SubscribeAccountLocationRequest* release_subscribe_account_location();
  inline void set_allocated_subscribe_account_location(::app::dispatch::SubscribeAccountLocationRequest* subscribe_account_location);

  // optional .app.dispatch.AppendAlertRequest append_alert = 18;
  inline bool has_append_alert() const;
  inline void clear_append_alert();
  static const int kAppendAlertFieldNumber = 18;
  inline const ::app::dispatch::AppendAlertRequest& append_alert() const;
  inline ::app::dispatch::AppendAlertRequest* mutable_append_alert();
  inline ::app::dispatch::AppendAlertRequest* release_append_alert();
  inline void set_allocated_append_alert(::app::dispatch::AppendAlertRequest* append_alert);

  // optional .app.dispatch.ModifyAlertRequest modify_alert = 19;
  inline bool has_modify_alert() const;
  inline void clear_modify_alert();
  static const int kModifyAlertFieldNumber = 19;
  inline const ::app::dispatch::ModifyAlertRequest& modify_alert() const;
  inline ::app::dispatch::ModifyAlertRequest* mutable_modify_alert();
  inline ::app::dispatch::ModifyAlertRequest* release_modify_alert();
  inline void set_allocated_modify_alert(::app::dispatch::ModifyAlertRequest* modify_alert);

  // optional .app.dispatch.StopAlertRequest stop_alert = 20;
  inline bool has_stop_alert() const;
  inline void clear_stop_alert();
  static const int kStopAlertFieldNumber = 20;
  inline const ::app::dispatch::StopAlertRequest& stop_alert() const;
  inline ::app::dispatch::StopAlertRequest* mutable_stop_alert();
  inline ::app::dispatch::StopAlertRequest* release_stop_alert();
  inline void set_allocated_stop_alert(::app::dispatch::StopAlertRequest* stop_alert);

  // optional .app.dispatch.HistoryAlertsRequest history_alerts = 21;
  inline bool has_history_alerts() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 21;
  inline const ::app::dispatch::HistoryAlertsRequest& history_alerts() const;
  inline ::app::dispatch::HistoryAlertsRequest* mutable_history_alerts();
  inline ::app::dispatch::HistoryAlertsRequest* release_history_alerts();
  inline void set_allocated_history_alerts(::app::dispatch::HistoryAlertsRequest* history_alerts);

  // optional .app.dispatch.HistoryAlertRequest history_alert = 22;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 22;
  inline const ::app::dispatch::HistoryAlertRequest& history_alert() const;
  inline ::app::dispatch::HistoryAlertRequest* mutable_history_alert();
  inline ::app::dispatch::HistoryAlertRequest* release_history_alert();
  inline void set_allocated_history_alert(::app::dispatch::HistoryAlertRequest* history_alert);

  // optional .app.dispatch.DeleteHistoryAlertRequest delete_history_alert = 23;
  inline bool has_delete_history_alert() const;
  inline void clear_delete_history_alert();
  static const int kDeleteHistoryAlertFieldNumber = 23;
  inline const ::app::dispatch::DeleteHistoryAlertRequest& delete_history_alert() const;
  inline ::app::dispatch::DeleteHistoryAlertRequest* mutable_delete_history_alert();
  inline ::app::dispatch::DeleteHistoryAlertRequest* release_delete_history_alert();
  inline void set_allocated_delete_history_alert(::app::dispatch::DeleteHistoryAlertRequest* delete_history_alert);

  // optional .app.dispatch.DeleteGroupRequest delete_group = 24;
  inline bool has_delete_group() const;
  inline void clear_delete_group();
  static const int kDeleteGroupFieldNumber = 24;
  inline const ::app::dispatch::DeleteGroupRequest& delete_group() const;
  inline ::app::dispatch::DeleteGroupRequest* mutable_delete_group();
  inline ::app::dispatch::DeleteGroupRequest* release_delete_group();
  inline void set_allocated_delete_group(::app::dispatch::DeleteGroupRequest* delete_group);

  // optional .app.dispatch.HistoryAlertMessageRequest history_alert_message = 25;
  inline bool has_history_alert_message() const;
  inline void clear_history_alert_message();
  static const int kHistoryAlertMessageFieldNumber = 25;
  inline const ::app::dispatch::HistoryAlertMessageRequest& history_alert_message() const;
  inline ::app::dispatch::HistoryAlertMessageRequest* mutable_history_alert_message();
  inline ::app::dispatch::HistoryAlertMessageRequest* release_history_alert_message();
  inline void set_allocated_history_alert_message(::app::dispatch::HistoryAlertMessageRequest* history_alert_message);

  // @@protoc_insertion_point(class_scope:app.dispatch.Request)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_append_group();
  inline void clear_has_append_group();
  inline void set_has_modify_group();
  inline void clear_has_modify_group();
  inline void set_has_modify_participants();
  inline void clear_has_modify_participants();
  inline void set_has_media_message();
  inline void clear_has_media_message();
  inline void set_has_invite_participant();
  inline void clear_has_invite_participant();
  inline void set_has_drop_participant();
  inline void clear_has_drop_participant();
  inline void set_has_release_participant_token();
  inline void clear_has_release_participant_token();
  inline void set_has_appoint_participant_speak();
  inline void clear_has_appoint_participant_speak();
  inline void set_has_jion_group();
  inline void clear_has_jion_group();
  inline void set_has_leave_group();
  inline void clear_has_leave_group();
  inline void set_has_send_message();
  inline void clear_has_send_message();
  inline void set_has_kick_participant();
  inline void clear_has_kick_participant();
  inline void set_has_start_record();
  inline void clear_has_start_record();
  inline void set_has_stop_record();
  inline void clear_has_stop_record();
  inline void set_has_subscribe_account_location();
  inline void clear_has_subscribe_account_location();
  inline void set_has_append_alert();
  inline void clear_has_append_alert();
  inline void set_has_modify_alert();
  inline void clear_has_modify_alert();
  inline void set_has_stop_alert();
  inline void clear_has_stop_alert();
  inline void set_has_history_alerts();
  inline void clear_has_history_alerts();
  inline void set_has_history_alert();
  inline void clear_has_history_alert();
  inline void set_has_delete_history_alert();
  inline void clear_has_delete_history_alert();
  inline void set_has_delete_group();
  inline void clear_has_delete_group();
  inline void set_has_history_alert_message();
  inline void clear_has_history_alert_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::dispatch::LoginRequest* login_;
  ::app::dispatch::EntityRequest* entity_;
  ::app::dispatch::AppendGroupRequest* append_group_;
  ::app::dispatch::ModifyGroupRequest* modify_group_;
  ::app::dispatch::ModifyParticipantsRequest* modify_participants_;
  ::app::dispatch::MediaMessageRequest* media_message_;
  ::app::dispatch::InviteParticipantRequest* invite_participant_;
  ::app::dispatch::DropParticipantRequest* drop_participant_;
  ::app::dispatch::ReleaseParticipantTokenRequest* release_participant_token_;
  ::app::dispatch::AppointParticipantSpeakRequest* appoint_participant_speak_;
  ::app::dispatch::JionGroupRequest* jion_group_;
  ::app::dispatch::LeaveGroupRequest* leave_group_;
  ::app::dispatch::SendMessageRequest* send_message_;
  ::app::dispatch::KickParticipantRequest* kick_participant_;
  ::app::dispatch::StartRecordRequest* start_record_;
  ::app::dispatch::StopRecordRequest* stop_record_;
  ::app::dispatch::SubscribeAccountLocationRequest* subscribe_account_location_;
  ::app::dispatch::AppendAlertRequest* append_alert_;
  ::app::dispatch::ModifyAlertRequest* modify_alert_;
  ::app::dispatch::StopAlertRequest* stop_alert_;
  ::app::dispatch::HistoryAlertsRequest* history_alerts_;
  ::app::dispatch::HistoryAlertRequest* history_alert_;
  ::app::dispatch::DeleteHistoryAlertRequest* delete_history_alert_;
  ::app::dispatch::DeleteGroupRequest* delete_group_;
  ::app::dispatch::HistoryAlertMessageRequest* history_alert_message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // required bool last_response = 2;
  inline bool has_last_response() const;
  inline void clear_last_response();
  static const int kLastResponseFieldNumber = 2;
  inline bool last_response() const;
  inline void set_last_response(bool value);

  // optional bytes error_describe = 3;
  inline bool has_error_describe() const;
  inline void clear_error_describe();
  static const int kErrorDescribeFieldNumber = 3;
  inline const ::std::string& error_describe() const;
  inline void set_error_describe(const ::std::string& value);
  inline void set_error_describe(const char* value);
  inline void set_error_describe(const void* value, size_t size);
  inline ::std::string* mutable_error_describe();
  inline ::std::string* release_error_describe();
  inline void set_allocated_error_describe(::std::string* error_describe);

  // optional .app.dispatch.LoginResponse login = 4;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 4;
  inline const ::app::dispatch::LoginResponse& login() const;
  inline ::app::dispatch::LoginResponse* mutable_login();
  inline ::app::dispatch::LoginResponse* release_login();
  inline void set_allocated_login(::app::dispatch::LoginResponse* login);

  // optional .app.dispatch.EntityResponse entity = 5;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 5;
  inline const ::app::dispatch::EntityResponse& entity() const;
  inline ::app::dispatch::EntityResponse* mutable_entity();
  inline ::app::dispatch::EntityResponse* release_entity();
  inline void set_allocated_entity(::app::dispatch::EntityResponse* entity);

  // optional .app.dispatch.AppendGroupResponse append_group = 6;
  inline bool has_append_group() const;
  inline void clear_append_group();
  static const int kAppendGroupFieldNumber = 6;
  inline const ::app::dispatch::AppendGroupResponse& append_group() const;
  inline ::app::dispatch::AppendGroupResponse* mutable_append_group();
  inline ::app::dispatch::AppendGroupResponse* release_append_group();
  inline void set_allocated_append_group(::app::dispatch::AppendGroupResponse* append_group);

  // optional .app.dispatch.ModifyGroupResponse modify_group = 7;
  inline bool has_modify_group() const;
  inline void clear_modify_group();
  static const int kModifyGroupFieldNumber = 7;
  inline const ::app::dispatch::ModifyGroupResponse& modify_group() const;
  inline ::app::dispatch::ModifyGroupResponse* mutable_modify_group();
  inline ::app::dispatch::ModifyGroupResponse* release_modify_group();
  inline void set_allocated_modify_group(::app::dispatch::ModifyGroupResponse* modify_group);

  // optional .app.dispatch.ModifyParticipantsResponse modify_participants = 8;
  inline bool has_modify_participants() const;
  inline void clear_modify_participants();
  static const int kModifyParticipantsFieldNumber = 8;
  inline const ::app::dispatch::ModifyParticipantsResponse& modify_participants() const;
  inline ::app::dispatch::ModifyParticipantsResponse* mutable_modify_participants();
  inline ::app::dispatch::ModifyParticipantsResponse* release_modify_participants();
  inline void set_allocated_modify_participants(::app::dispatch::ModifyParticipantsResponse* modify_participants);

  // optional .app.dispatch.MediaMessageResponse media_message = 9;
  inline bool has_media_message() const;
  inline void clear_media_message();
  static const int kMediaMessageFieldNumber = 9;
  inline const ::app::dispatch::MediaMessageResponse& media_message() const;
  inline ::app::dispatch::MediaMessageResponse* mutable_media_message();
  inline ::app::dispatch::MediaMessageResponse* release_media_message();
  inline void set_allocated_media_message(::app::dispatch::MediaMessageResponse* media_message);

  // optional .app.dispatch.AppendAlertResponse append_alert = 10;
  inline bool has_append_alert() const;
  inline void clear_append_alert();
  static const int kAppendAlertFieldNumber = 10;
  inline const ::app::dispatch::AppendAlertResponse& append_alert() const;
  inline ::app::dispatch::AppendAlertResponse* mutable_append_alert();
  inline ::app::dispatch::AppendAlertResponse* release_append_alert();
  inline void set_allocated_append_alert(::app::dispatch::AppendAlertResponse* append_alert);

  // optional .app.dispatch.HistoryAlertsResponse history_alerts = 11;
  inline bool has_history_alerts() const;
  inline void clear_history_alerts();
  static const int kHistoryAlertsFieldNumber = 11;
  inline const ::app::dispatch::HistoryAlertsResponse& history_alerts() const;
  inline ::app::dispatch::HistoryAlertsResponse* mutable_history_alerts();
  inline ::app::dispatch::HistoryAlertsResponse* release_history_alerts();
  inline void set_allocated_history_alerts(::app::dispatch::HistoryAlertsResponse* history_alerts);

  // optional .app.dispatch.HistoryAlertResponse history_alert = 12;
  inline bool has_history_alert() const;
  inline void clear_history_alert();
  static const int kHistoryAlertFieldNumber = 12;
  inline const ::app::dispatch::HistoryAlertResponse& history_alert() const;
  inline ::app::dispatch::HistoryAlertResponse* mutable_history_alert();
  inline ::app::dispatch::HistoryAlertResponse* release_history_alert();
  inline void set_allocated_history_alert(::app::dispatch::HistoryAlertResponse* history_alert);

  // optional .app.dispatch.HistoryAlertMessageResponse history_alert_message = 13;
  inline bool has_history_alert_message() const;
  inline void clear_history_alert_message();
  static const int kHistoryAlertMessageFieldNumber = 13;
  inline const ::app::dispatch::HistoryAlertMessageResponse& history_alert_message() const;
  inline ::app::dispatch::HistoryAlertMessageResponse* mutable_history_alert_message();
  inline ::app::dispatch::HistoryAlertMessageResponse* release_history_alert_message();
  inline void set_allocated_history_alert_message(::app::dispatch::HistoryAlertMessageResponse* history_alert_message);

  // @@protoc_insertion_point(class_scope:app.dispatch.Response)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_last_response();
  inline void clear_has_last_response();
  inline void set_has_error_describe();
  inline void clear_has_error_describe();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_append_group();
  inline void clear_has_append_group();
  inline void set_has_modify_group();
  inline void clear_has_modify_group();
  inline void set_has_modify_participants();
  inline void clear_has_modify_participants();
  inline void set_has_media_message();
  inline void clear_has_media_message();
  inline void set_has_append_alert();
  inline void clear_has_append_alert();
  inline void set_has_history_alerts();
  inline void clear_has_history_alerts();
  inline void set_has_history_alert();
  inline void clear_has_history_alert();
  inline void set_has_history_alert_message();
  inline void clear_has_history_alert_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_describe_;
  ::app::dispatch::LoginResponse* login_;
  ::app::dispatch::EntityResponse* entity_;
  ::app::dispatch::AppendGroupResponse* append_group_;
  ::app::dispatch::ModifyGroupResponse* modify_group_;
  ::app::dispatch::ModifyParticipantsResponse* modify_participants_;
  ::app::dispatch::MediaMessageResponse* media_message_;
  ::app::dispatch::AppendAlertResponse* append_alert_;
  ::app::dispatch::HistoryAlertsResponse* history_alerts_;
  ::app::dispatch::HistoryAlertResponse* history_alert_;
  ::app::dispatch::HistoryAlertMessageResponse* history_alert_message_;
  bool result_;
  bool last_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Indication : public ::google::protobuf::Message {
 public:
  Indication();
  virtual ~Indication();

  Indication(const Indication& from);

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Indication& default_instance();

  void Swap(Indication* other);

  // implements Message ----------------------------------------------

  Indication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Indication& from);
  void MergeFrom(const Indication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.dispatch.EntityNotification entity = 1;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::app::dispatch::EntityNotification& entity() const;
  inline ::app::dispatch::EntityNotification* mutable_entity();
  inline ::app::dispatch::EntityNotification* release_entity();
  inline void set_allocated_entity(::app::dispatch::EntityNotification* entity);

  // optional .app.dispatch.EntityStatusNotification entity_status = 2;
  inline bool has_entity_status() const;
  inline void clear_entity_status();
  static const int kEntityStatusFieldNumber = 2;
  inline const ::app::dispatch::EntityStatusNotification& entity_status() const;
  inline ::app::dispatch::EntityStatusNotification* mutable_entity_status();
  inline ::app::dispatch::EntityStatusNotification* release_entity_status();
  inline void set_allocated_entity_status(::app::dispatch::EntityStatusNotification* entity_status);

  // optional .app.dispatch.ParticipantsNotification participants = 3;
  inline bool has_participants() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 3;
  inline const ::app::dispatch::ParticipantsNotification& participants() const;
  inline ::app::dispatch::ParticipantsNotification* mutable_participants();
  inline ::app::dispatch::ParticipantsNotification* release_participants();
  inline void set_allocated_participants(::app::dispatch::ParticipantsNotification* participants);

  // optional .app.dispatch.JoinGroupRequestNotification join_group_request = 4;
  inline bool has_join_group_request() const;
  inline void clear_join_group_request();
  static const int kJoinGroupRequestFieldNumber = 4;
  inline const ::app::dispatch::JoinGroupRequestNotification& join_group_request() const;
  inline ::app::dispatch::JoinGroupRequestNotification* mutable_join_group_request();
  inline ::app::dispatch::JoinGroupRequestNotification* release_join_group_request();
  inline void set_allocated_join_group_request(::app::dispatch::JoinGroupRequestNotification* join_group_request);

  // optional .app.dispatch.ParticipantStatusNotification participant_status = 5;
  inline bool has_participant_status() const;
  inline void clear_participant_status();
  static const int kParticipantStatusFieldNumber = 5;
  inline const ::app::dispatch::ParticipantStatusNotification& participant_status() const;
  inline ::app::dispatch::ParticipantStatusNotification* mutable_participant_status();
  inline ::app::dispatch::ParticipantStatusNotification* release_participant_status();
  inline void set_allocated_participant_status(::app::dispatch::ParticipantStatusNotification* participant_status);

  // optional .app.dispatch.MediaMessageNotification media_message = 6;
  inline bool has_media_message() const;
  inline void clear_media_message();
  static const int kMediaMessageFieldNumber = 6;
  inline const ::app::dispatch::MediaMessageNotification& media_message() const;
  inline ::app::dispatch::MediaMessageNotification* mutable_media_message();
  inline ::app::dispatch::MediaMessageNotification* release_media_message();
  inline void set_allocated_media_message(::app::dispatch::MediaMessageNotification* media_message);

  // optional .app.dispatch.ParticipantConnectRequestNotification participant_connect_request = 7;
  inline bool has_participant_connect_request() const;
  inline void clear_participant_connect_request();
  static const int kParticipantConnectRequestFieldNumber = 7;
  inline const ::app::dispatch::ParticipantConnectRequestNotification& participant_connect_request() const;
  inline ::app::dispatch::ParticipantConnectRequestNotification* mutable_participant_connect_request();
  inline ::app::dispatch::ParticipantConnectRequestNotification* release_participant_connect_request();
  inline void set_allocated_participant_connect_request(::app::dispatch::ParticipantConnectRequestNotification* participant_connect_request);

  // optional .app.dispatch.ParticipantSpeakRequestNotification participant_speak_request = 8;
  inline bool has_participant_speak_request() const;
  inline void clear_participant_speak_request();
  static const int kParticipantSpeakRequestFieldNumber = 8;
  inline const ::app::dispatch::ParticipantSpeakRequestNotification& participant_speak_request() const;
  inline ::app::dispatch::ParticipantSpeakRequestNotification* mutable_participant_speak_request();
  inline ::app::dispatch::ParticipantSpeakRequestNotification* release_participant_speak_request();
  inline void set_allocated_participant_speak_request(::app::dispatch::ParticipantSpeakRequestNotification* participant_speak_request);

  // optional .app.dispatch.SessionStatusNotification session_status = 9;
  inline bool has_session_status() const;
  inline void clear_session_status();
  static const int kSessionStatusFieldNumber = 9;
  inline const ::app::dispatch::SessionStatusNotification& session_status() const;
  inline ::app::dispatch::SessionStatusNotification* mutable_session_status();
  inline ::app::dispatch::SessionStatusNotification* release_session_status();
  inline void set_allocated_session_status(::app::dispatch::SessionStatusNotification* session_status);

  // optional .app.dispatch.RecordStatusNotification record_status = 10;
  inline bool has_record_status() const;
  inline void clear_record_status();
  static const int kRecordStatusFieldNumber = 10;
  inline const ::app::dispatch::RecordStatusNotification& record_status() const;
  inline ::app::dispatch::RecordStatusNotification* mutable_record_status();
  inline ::app::dispatch::RecordStatusNotification* release_record_status();
  inline void set_allocated_record_status(::app::dispatch::RecordStatusNotification* record_status);

  // optional .app.dispatch.AccountLocationNotification account_location = 11;
  inline bool has_account_location() const;
  inline void clear_account_location();
  static const int kAccountLocationFieldNumber = 11;
  inline const ::app::dispatch::AccountLocationNotification& account_location() const;
  inline ::app::dispatch::AccountLocationNotification* mutable_account_location();
  inline ::app::dispatch::AccountLocationNotification* release_account_location();
  inline void set_allocated_account_location(::app::dispatch::AccountLocationNotification* account_location);

  // optional .app.dispatch.AlertOveredNotification alert_overed = 12;
  inline bool has_alert_overed() const;
  inline void clear_alert_overed();
  static const int kAlertOveredFieldNumber = 12;
  inline const ::app::dispatch::AlertOveredNotification& alert_overed() const;
  inline ::app::dispatch::AlertOveredNotification* mutable_alert_overed();
  inline ::app::dispatch::AlertOveredNotification* release_alert_overed();
  inline void set_allocated_alert_overed(::app::dispatch::AlertOveredNotification* alert_overed);

  // @@protoc_insertion_point(class_scope:app.dispatch.Indication)
 private:
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_entity_status();
  inline void clear_has_entity_status();
  inline void set_has_participants();
  inline void clear_has_participants();
  inline void set_has_join_group_request();
  inline void clear_has_join_group_request();
  inline void set_has_participant_status();
  inline void clear_has_participant_status();
  inline void set_has_media_message();
  inline void clear_has_media_message();
  inline void set_has_participant_connect_request();
  inline void clear_has_participant_connect_request();
  inline void set_has_participant_speak_request();
  inline void clear_has_participant_speak_request();
  inline void set_has_session_status();
  inline void clear_has_session_status();
  inline void set_has_record_status();
  inline void clear_has_record_status();
  inline void set_has_account_location();
  inline void clear_has_account_location();
  inline void set_has_alert_overed();
  inline void clear_has_alert_overed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::dispatch::EntityNotification* entity_;
  ::app::dispatch::EntityStatusNotification* entity_status_;
  ::app::dispatch::ParticipantsNotification* participants_;
  ::app::dispatch::JoinGroupRequestNotification* join_group_request_;
  ::app::dispatch::ParticipantStatusNotification* participant_status_;
  ::app::dispatch::MediaMessageNotification* media_message_;
  ::app::dispatch::ParticipantConnectRequestNotification* participant_connect_request_;
  ::app::dispatch::ParticipantSpeakRequestNotification* participant_speak_request_;
  ::app::dispatch::SessionStatusNotification* session_status_;
  ::app::dispatch::RecordStatusNotification* record_status_;
  ::app::dispatch::AccountLocationNotification* account_location_;
  ::app::dispatch::AlertOveredNotification* alert_overed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static Indication* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.dispatch.MSG msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::app::dispatch::MSG msg_type() const;
  inline void set_msg_type(::app::dispatch::MSG value);

  // required fixed32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional fixed32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional .app.dispatch.Request request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::app::dispatch::Request& request() const;
  inline ::app::dispatch::Request* mutable_request();
  inline ::app::dispatch::Request* release_request();
  inline void set_allocated_request(::app::dispatch::Request* request);

  // optional .app.dispatch.Response response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline const ::app::dispatch::Response& response() const;
  inline ::app::dispatch::Response* mutable_response();
  inline ::app::dispatch::Response* release_response();
  inline void set_allocated_response(::app::dispatch::Response* response);

  // optional .app.dispatch.Indication indication = 6;
  inline bool has_indication() const;
  inline void clear_indication();
  static const int kIndicationFieldNumber = 6;
  inline const ::app::dispatch::Indication& indication() const;
  inline ::app::dispatch::Indication* mutable_indication();
  inline ::app::dispatch::Indication* release_indication();
  inline void set_allocated_indication(::app::dispatch::Indication* indication);

  // @@protoc_insertion_point(class_scope:app.dispatch.Message)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_indication();
  inline void clear_has_indication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int msg_type_;
  ::google::protobuf::uint32 sequence_;
  ::app::dispatch::Request* request_;
  ::app::dispatch::Response* response_;
  ::app::dispatch::Indication* indication_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2edispatch_2eproto();
  friend void protobuf_AssignDesc_app_2edispatch_2eproto();
  friend void protobuf_ShutdownFile_app_2edispatch_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required bytes username = 1;
inline bool LoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginRequest::username() const {
  return *username_;
}
inline void LoginRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required fixed32 session_id = 1;
inline bool LoginResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 LoginResponse::session_id() const {
  return session_id_;
}
inline void LoginResponse::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required .pbmsg.User self = 2;
inline bool LoginResponse::has_self() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_self() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_self() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_self() {
  if (self_ != NULL) self_->::pbmsg::User::Clear();
  clear_has_self();
}
inline const ::pbmsg::User& LoginResponse::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::pbmsg::User* LoginResponse::mutable_self() {
  set_has_self();
  if (self_ == NULL) self_ = new ::pbmsg::User;
  return self_;
}
inline ::pbmsg::User* LoginResponse::release_self() {
  clear_has_self();
  ::pbmsg::User* temp = self_;
  self_ = NULL;
  return temp;
}
inline void LoginResponse::set_allocated_self(::pbmsg::User* self) {
  delete self_;
  self_ = self;
  if (self) {
    set_has_self();
  } else {
    clear_has_self();
  }
}

// required fixed32 ttl = 3;
inline bool LoginResponse::has_ttl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_ttl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 LoginResponse::ttl() const {
  return ttl_;
}
inline void LoginResponse::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// EntityRequest

// required .pbmsg.Entity id = 1;
inline bool EntityRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityRequest::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& EntityRequest::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* EntityRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* EntityRequest::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void EntityRequest::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// -------------------------------------------------------------------

// EntityResponse

// required .pbmsg.EntityData data = 1;
inline bool EntityResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityResponse::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& EntityResponse::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* EntityResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* EntityResponse::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void EntityResponse::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// EntityNotification

// required .pbmsg.EntityNotifyType notify_type = 1;
inline bool EntityNotification::has_notify_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityNotification::set_has_notify_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityNotification::clear_has_notify_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityNotification::clear_notify_type() {
  notify_type_ = 0;
  clear_has_notify_type();
}
inline ::pbmsg::EntityNotifyType EntityNotification::notify_type() const {
  return static_cast< ::pbmsg::EntityNotifyType >(notify_type_);
}
inline void EntityNotification::set_notify_type(::pbmsg::EntityNotifyType value) {
  assert(::pbmsg::EntityNotifyType_IsValid(value));
  set_has_notify_type();
  notify_type_ = value;
}

// required .pbmsg.EntityData data = 2;
inline bool EntityNotification::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityNotification::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityNotification::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityNotification::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& EntityNotification::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* EntityNotification::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* EntityNotification::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void EntityNotification::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// EntityStatusNotification

// required .pbmsg.Entity id = 1;
inline bool EntityStatusNotification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityStatusNotification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityStatusNotification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityStatusNotification::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& EntityStatusNotification::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* EntityStatusNotification::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* EntityStatusNotification::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void EntityStatusNotification::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required .pbmsg.RegisterStatus status = 2;
inline bool EntityStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityStatusNotification::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::RegisterStatus EntityStatusNotification::status() const {
  return static_cast< ::pbmsg::RegisterStatus >(status_);
}
inline void EntityStatusNotification::set_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .pbmsg.RegisterStatus sip_status = 3;
inline bool EntityStatusNotification::has_sip_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityStatusNotification::set_has_sip_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityStatusNotification::clear_has_sip_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityStatusNotification::clear_sip_status() {
  sip_status_ = 0;
  clear_has_sip_status();
}
inline ::pbmsg::RegisterStatus EntityStatusNotification::sip_status() const {
  return static_cast< ::pbmsg::RegisterStatus >(sip_status_);
}
inline void EntityStatusNotification::set_sip_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_sip_status();
  sip_status_ = value;
}

// -------------------------------------------------------------------

// AppendGroupRequest

// required .pbmsg.Group group = 1;
inline bool AppendGroupRequest::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendGroupRequest::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendGroupRequest::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendGroupRequest::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Group::Clear();
  clear_has_group();
}
inline const ::pbmsg::Group& AppendGroupRequest::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Group* AppendGroupRequest::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Group;
  return group_;
}
inline ::pbmsg::Group* AppendGroupRequest::release_group() {
  clear_has_group();
  ::pbmsg::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void AppendGroupRequest::set_allocated_group(::pbmsg::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// AppendGroupResponse

// required .pbmsg.Group group = 1;
inline bool AppendGroupResponse::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendGroupResponse::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendGroupResponse::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendGroupResponse::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Group::Clear();
  clear_has_group();
}
inline const ::pbmsg::Group& AppendGroupResponse::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Group* AppendGroupResponse::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Group;
  return group_;
}
inline ::pbmsg::Group* AppendGroupResponse::release_group() {
  clear_has_group();
  ::pbmsg::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void AppendGroupResponse::set_allocated_group(::pbmsg::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// ModifyGroupRequest

// required .pbmsg.Group group = 1;
inline bool ModifyGroupRequest::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupRequest::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupRequest::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupRequest::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Group::Clear();
  clear_has_group();
}
inline const ::pbmsg::Group& ModifyGroupRequest::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Group* ModifyGroupRequest::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Group;
  return group_;
}
inline ::pbmsg::Group* ModifyGroupRequest::release_group() {
  clear_has_group();
  ::pbmsg::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void ModifyGroupRequest::set_allocated_group(::pbmsg::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// ModifyGroupResponse

// required .pbmsg.Group group = 1;
inline bool ModifyGroupResponse::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupResponse::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupResponse::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupResponse::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Group::Clear();
  clear_has_group();
}
inline const ::pbmsg::Group& ModifyGroupResponse::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Group* ModifyGroupResponse::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Group;
  return group_;
}
inline ::pbmsg::Group* ModifyGroupResponse::release_group() {
  clear_has_group();
  ::pbmsg::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void ModifyGroupResponse::set_allocated_group(::pbmsg::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// ModifyParticipantsRequest

// required .pbmsg.Entity group_id = 1;
inline bool ModifyParticipantsRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyParticipantsRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyParticipantsRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyParticipantsRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ModifyParticipantsRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ModifyParticipantsRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ModifyParticipantsRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ModifyParticipantsRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.ListModifyType modify_type = 2;
inline bool ModifyParticipantsRequest::has_modify_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyParticipantsRequest::set_has_modify_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyParticipantsRequest::clear_has_modify_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyParticipantsRequest::clear_modify_type() {
  modify_type_ = 0;
  clear_has_modify_type();
}
inline ::pbmsg::ListModifyType ModifyParticipantsRequest::modify_type() const {
  return static_cast< ::pbmsg::ListModifyType >(modify_type_);
}
inline void ModifyParticipantsRequest::set_modify_type(::pbmsg::ListModifyType value) {
  assert(::pbmsg::ListModifyType_IsValid(value));
  set_has_modify_type();
  modify_type_ = value;
}

// repeated .pbmsg.Participant particiapnts = 3;
inline int ModifyParticipantsRequest::particiapnts_size() const {
  return particiapnts_.size();
}
inline void ModifyParticipantsRequest::clear_particiapnts() {
  particiapnts_.Clear();
}
inline const ::pbmsg::Participant& ModifyParticipantsRequest::particiapnts(int index) const {
  return particiapnts_.Get(index);
}
inline ::pbmsg::Participant* ModifyParticipantsRequest::mutable_particiapnts(int index) {
  return particiapnts_.Mutable(index);
}
inline ::pbmsg::Participant* ModifyParticipantsRequest::add_particiapnts() {
  return particiapnts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
ModifyParticipantsRequest::particiapnts() const {
  return particiapnts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
ModifyParticipantsRequest::mutable_particiapnts() {
  return &particiapnts_;
}

// -------------------------------------------------------------------

// ModifyParticipantsResponse

// required .pbmsg.Entity group_id = 1;
inline bool ModifyParticipantsResponse::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyParticipantsResponse::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyParticipantsResponse::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyParticipantsResponse::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ModifyParticipantsResponse::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ModifyParticipantsResponse::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ModifyParticipantsResponse::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ModifyParticipantsResponse::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.ListModifyType modify_type = 2;
inline bool ModifyParticipantsResponse::has_modify_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyParticipantsResponse::set_has_modify_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyParticipantsResponse::clear_has_modify_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyParticipantsResponse::clear_modify_type() {
  modify_type_ = 0;
  clear_has_modify_type();
}
inline ::pbmsg::ListModifyType ModifyParticipantsResponse::modify_type() const {
  return static_cast< ::pbmsg::ListModifyType >(modify_type_);
}
inline void ModifyParticipantsResponse::set_modify_type(::pbmsg::ListModifyType value) {
  assert(::pbmsg::ListModifyType_IsValid(value));
  set_has_modify_type();
  modify_type_ = value;
}

// repeated .pbmsg.Participant particiapnts = 3;
inline int ModifyParticipantsResponse::particiapnts_size() const {
  return particiapnts_.size();
}
inline void ModifyParticipantsResponse::clear_particiapnts() {
  particiapnts_.Clear();
}
inline const ::pbmsg::Participant& ModifyParticipantsResponse::particiapnts(int index) const {
  return particiapnts_.Get(index);
}
inline ::pbmsg::Participant* ModifyParticipantsResponse::mutable_particiapnts(int index) {
  return particiapnts_.Mutable(index);
}
inline ::pbmsg::Participant* ModifyParticipantsResponse::add_particiapnts() {
  return particiapnts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
ModifyParticipantsResponse::particiapnts() const {
  return particiapnts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
ModifyParticipantsResponse::mutable_particiapnts() {
  return &particiapnts_;
}

// -------------------------------------------------------------------

// ParticipantsNotification

// required .pbmsg.Entity group_id = 1;
inline bool ParticipantsNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticipantsNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticipantsNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticipantsNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ParticipantsNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ParticipantsNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ParticipantsNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ParticipantsNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.ListModifyType modify_type = 2;
inline bool ParticipantsNotification::has_modify_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticipantsNotification::set_has_modify_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticipantsNotification::clear_has_modify_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticipantsNotification::clear_modify_type() {
  modify_type_ = 0;
  clear_has_modify_type();
}
inline ::pbmsg::ListModifyType ParticipantsNotification::modify_type() const {
  return static_cast< ::pbmsg::ListModifyType >(modify_type_);
}
inline void ParticipantsNotification::set_modify_type(::pbmsg::ListModifyType value) {
  assert(::pbmsg::ListModifyType_IsValid(value));
  set_has_modify_type();
  modify_type_ = value;
}

// repeated .pbmsg.Participant particiapnts = 3;
inline int ParticipantsNotification::particiapnts_size() const {
  return particiapnts_.size();
}
inline void ParticipantsNotification::clear_particiapnts() {
  particiapnts_.Clear();
}
inline const ::pbmsg::Participant& ParticipantsNotification::particiapnts(int index) const {
  return particiapnts_.Get(index);
}
inline ::pbmsg::Participant* ParticipantsNotification::mutable_particiapnts(int index) {
  return particiapnts_.Mutable(index);
}
inline ::pbmsg::Participant* ParticipantsNotification::add_particiapnts() {
  return particiapnts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
ParticipantsNotification::particiapnts() const {
  return particiapnts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
ParticipantsNotification::mutable_particiapnts() {
  return &particiapnts_;
}

// -------------------------------------------------------------------

// JoinGroupRequestNotification

// required .pbmsg.Entity group_id = 1;
inline bool JoinGroupRequestNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroupRequestNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroupRequestNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroupRequestNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& JoinGroupRequestNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* JoinGroupRequestNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* JoinGroupRequestNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void JoinGroupRequestNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool JoinGroupRequestNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGroupRequestNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGroupRequestNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGroupRequestNotification::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& JoinGroupRequestNotification::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* JoinGroupRequestNotification::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* JoinGroupRequestNotification::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void JoinGroupRequestNotification::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// ParticipantStatusNotification

// required .pbmsg.Entity group_id = 1;
inline bool ParticipantStatusNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticipantStatusNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticipantStatusNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticipantStatusNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ParticipantStatusNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ParticipantStatusNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ParticipantStatusNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ParticipantStatusNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool ParticipantStatusNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticipantStatusNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticipantStatusNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticipantStatusNotification::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& ParticipantStatusNotification::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* ParticipantStatusNotification::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* ParticipantStatusNotification::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void ParticipantStatusNotification::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// required .pbmsg.SessionStatus status = 3;
inline bool ParticipantStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParticipantStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParticipantStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParticipantStatusNotification::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::SessionStatus ParticipantStatusNotification::status() const {
  return static_cast< ::pbmsg::SessionStatus >(status_);
}
inline void ParticipantStatusNotification::set_status(::pbmsg::SessionStatus value) {
  assert(::pbmsg::SessionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// MediaMessageRequest

// required .pbmsg.Entity id = 1;
inline bool MediaMessageRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageRequest::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& MediaMessageRequest::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* MediaMessageRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* MediaMessageRequest::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MediaMessageRequest::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional fixed32 from_message_id = 2;
inline bool MediaMessageRequest::has_from_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMessageRequest::set_has_from_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMessageRequest::clear_has_from_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMessageRequest::clear_from_message_id() {
  from_message_id_ = 0u;
  clear_has_from_message_id();
}
inline ::google::protobuf::uint32 MediaMessageRequest::from_message_id() const {
  return from_message_id_;
}
inline void MediaMessageRequest::set_from_message_id(::google::protobuf::uint32 value) {
  set_has_from_message_id();
  from_message_id_ = value;
}

// optional string from_time = 3;
inline bool MediaMessageRequest::has_from_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMessageRequest::set_has_from_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMessageRequest::clear_has_from_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMessageRequest::clear_from_time() {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    from_time_->clear();
  }
  clear_has_from_time();
}
inline const ::std::string& MediaMessageRequest::from_time() const {
  return *from_time_;
}
inline void MediaMessageRequest::set_from_time(const ::std::string& value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void MediaMessageRequest::set_from_time(const char* value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void MediaMessageRequest::set_from_time(const char* value, size_t size) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MediaMessageRequest::mutable_from_time() {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  return from_time_;
}
inline ::std::string* MediaMessageRequest::release_from_time() {
  clear_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_time_;
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MediaMessageRequest::set_allocated_from_time(::std::string* from_time) {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    delete from_time_;
  }
  if (from_time) {
    set_has_from_time();
    from_time_ = from_time;
  } else {
    clear_has_from_time();
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 max_message_count = 4;
inline bool MediaMessageRequest::has_max_message_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MediaMessageRequest::set_has_max_message_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MediaMessageRequest::clear_has_max_message_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MediaMessageRequest::clear_max_message_count() {
  max_message_count_ = 0u;
  clear_has_max_message_count();
}
inline ::google::protobuf::uint32 MediaMessageRequest::max_message_count() const {
  return max_message_count_;
}
inline void MediaMessageRequest::set_max_message_count(::google::protobuf::uint32 value) {
  set_has_max_message_count();
  max_message_count_ = value;
}

// -------------------------------------------------------------------

// MediaMessageResponse

// required .pbmsg.Entity id = 1;
inline bool MediaMessageResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageResponse::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& MediaMessageResponse::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* MediaMessageResponse::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* MediaMessageResponse::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MediaMessageResponse::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// repeated .pbmsg.MediaMessage messages = 2;
inline int MediaMessageResponse::messages_size() const {
  return messages_.size();
}
inline void MediaMessageResponse::clear_messages() {
  messages_.Clear();
}
inline const ::pbmsg::MediaMessage& MediaMessageResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::pbmsg::MediaMessage* MediaMessageResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::pbmsg::MediaMessage* MediaMessageResponse::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >&
MediaMessageResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >*
MediaMessageResponse::mutable_messages() {
  return &messages_;
}

// required fixed32 leave_message_count = 3;
inline bool MediaMessageResponse::has_leave_message_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MediaMessageResponse::set_has_leave_message_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MediaMessageResponse::clear_has_leave_message_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MediaMessageResponse::clear_leave_message_count() {
  leave_message_count_ = 0u;
  clear_has_leave_message_count();
}
inline ::google::protobuf::uint32 MediaMessageResponse::leave_message_count() const {
  return leave_message_count_;
}
inline void MediaMessageResponse::set_leave_message_count(::google::protobuf::uint32 value) {
  set_has_leave_message_count();
  leave_message_count_ = value;
}

// -------------------------------------------------------------------

// MediaMessageNotification

// required .pbmsg.Entity id = 1;
inline bool MediaMessageNotification::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaMessageNotification::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaMessageNotification::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaMessageNotification::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& MediaMessageNotification::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* MediaMessageNotification::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* MediaMessageNotification::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MediaMessageNotification::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required .pbmsg.MediaMessage msg = 2;
inline bool MediaMessageNotification::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaMessageNotification::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaMessageNotification::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaMessageNotification::clear_msg() {
  if (msg_ != NULL) msg_->::pbmsg::MediaMessage::Clear();
  clear_has_msg();
}
inline const ::pbmsg::MediaMessage& MediaMessageNotification::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::pbmsg::MediaMessage* MediaMessageNotification::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::pbmsg::MediaMessage;
  return msg_;
}
inline ::pbmsg::MediaMessage* MediaMessageNotification::release_msg() {
  clear_has_msg();
  ::pbmsg::MediaMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void MediaMessageNotification::set_allocated_msg(::pbmsg::MediaMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// ParticipantConnectRequestNotification

// required .pbmsg.Entity group_id = 1;
inline bool ParticipantConnectRequestNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticipantConnectRequestNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticipantConnectRequestNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticipantConnectRequestNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ParticipantConnectRequestNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ParticipantConnectRequestNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ParticipantConnectRequestNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ParticipantConnectRequestNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool ParticipantConnectRequestNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticipantConnectRequestNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticipantConnectRequestNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticipantConnectRequestNotification::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& ParticipantConnectRequestNotification::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* ParticipantConnectRequestNotification::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* ParticipantConnectRequestNotification::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void ParticipantConnectRequestNotification::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// ParticipantSpeakRequestNotification

// required .pbmsg.Entity group_id = 1;
inline bool ParticipantSpeakRequestNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticipantSpeakRequestNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticipantSpeakRequestNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticipantSpeakRequestNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ParticipantSpeakRequestNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ParticipantSpeakRequestNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ParticipantSpeakRequestNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ParticipantSpeakRequestNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool ParticipantSpeakRequestNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticipantSpeakRequestNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticipantSpeakRequestNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticipantSpeakRequestNotification::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& ParticipantSpeakRequestNotification::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* ParticipantSpeakRequestNotification::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* ParticipantSpeakRequestNotification::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void ParticipantSpeakRequestNotification::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// InviteParticipantRequest

// required .pbmsg.Entity group_id = 1;
inline bool InviteParticipantRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteParticipantRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteParticipantRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteParticipantRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& InviteParticipantRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* InviteParticipantRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* InviteParticipantRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void InviteParticipantRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool InviteParticipantRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteParticipantRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteParticipantRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteParticipantRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& InviteParticipantRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* InviteParticipantRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* InviteParticipantRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void InviteParticipantRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// DropParticipantRequest

// required .pbmsg.Entity group_id = 1;
inline bool DropParticipantRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropParticipantRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropParticipantRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropParticipantRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& DropParticipantRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* DropParticipantRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* DropParticipantRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void DropParticipantRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool DropParticipantRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropParticipantRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropParticipantRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropParticipantRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& DropParticipantRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* DropParticipantRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* DropParticipantRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void DropParticipantRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// ReleaseParticipantTokenRequest

// required .pbmsg.Entity group_id = 1;
inline bool ReleaseParticipantTokenRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseParticipantTokenRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseParticipantTokenRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseParticipantTokenRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& ReleaseParticipantTokenRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* ReleaseParticipantTokenRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* ReleaseParticipantTokenRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void ReleaseParticipantTokenRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool ReleaseParticipantTokenRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReleaseParticipantTokenRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReleaseParticipantTokenRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReleaseParticipantTokenRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& ReleaseParticipantTokenRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* ReleaseParticipantTokenRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* ReleaseParticipantTokenRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void ReleaseParticipantTokenRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// AppointParticipantSpeakRequest

// required .pbmsg.Entity group_id = 1;
inline bool AppointParticipantSpeakRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppointParticipantSpeakRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppointParticipantSpeakRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppointParticipantSpeakRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& AppointParticipantSpeakRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* AppointParticipantSpeakRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* AppointParticipantSpeakRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void AppointParticipantSpeakRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool AppointParticipantSpeakRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppointParticipantSpeakRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppointParticipantSpeakRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppointParticipantSpeakRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& AppointParticipantSpeakRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* AppointParticipantSpeakRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* AppointParticipantSpeakRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void AppointParticipantSpeakRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// JionGroupRequest

// required .pbmsg.Entity group_id = 1;
inline bool JionGroupRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JionGroupRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JionGroupRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JionGroupRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& JionGroupRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* JionGroupRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* JionGroupRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void JionGroupRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// -------------------------------------------------------------------

// LeaveGroupRequest

// required .pbmsg.Entity group_id = 1;
inline bool LeaveGroupRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroupRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroupRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroupRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& LeaveGroupRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* LeaveGroupRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* LeaveGroupRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void LeaveGroupRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// -------------------------------------------------------------------

// SessionStatusNotification

// required .pbmsg.Entity group_id = 1;
inline bool SessionStatusNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionStatusNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionStatusNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionStatusNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& SessionStatusNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* SessionStatusNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* SessionStatusNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void SessionStatusNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.SessionStatus status = 2;
inline bool SessionStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionStatusNotification::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::SessionStatus SessionStatusNotification::status() const {
  return static_cast< ::pbmsg::SessionStatus >(status_);
}
inline void SessionStatusNotification::set_status(::pbmsg::SessionStatus value) {
  assert(::pbmsg::SessionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SendMessageRequest

// required .pbmsg.Entity id = 1;
inline bool SendMessageRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendMessageRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendMessageRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendMessageRequest::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& SendMessageRequest::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* SendMessageRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* SendMessageRequest::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SendMessageRequest::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required .pbmsg.MediaMessage msg = 2;
inline bool SendMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::pbmsg::MediaMessage::Clear();
  clear_has_msg();
}
inline const ::pbmsg::MediaMessage& SendMessageRequest::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::pbmsg::MediaMessage* SendMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::pbmsg::MediaMessage;
  return msg_;
}
inline ::pbmsg::MediaMessage* SendMessageRequest::release_msg() {
  clear_has_msg();
  ::pbmsg::MediaMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void SendMessageRequest::set_allocated_msg(::pbmsg::MediaMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// KickParticipantRequest

// required .pbmsg.Entity group_id = 1;
inline bool KickParticipantRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickParticipantRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickParticipantRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickParticipantRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& KickParticipantRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* KickParticipantRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* KickParticipantRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void KickParticipantRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required .pbmsg.Entity account_id = 2;
inline bool KickParticipantRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickParticipantRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickParticipantRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickParticipantRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& KickParticipantRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* KickParticipantRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* KickParticipantRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void KickParticipantRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// -------------------------------------------------------------------

// StartRecordRequest

// required .pbmsg.Entity group_id = 1;
inline bool StartRecordRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartRecordRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartRecordRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartRecordRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& StartRecordRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* StartRecordRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* StartRecordRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void StartRecordRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// -------------------------------------------------------------------

// StopRecordRequest

// required .pbmsg.Entity group_id = 1;
inline bool StopRecordRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopRecordRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopRecordRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopRecordRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& StopRecordRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* StopRecordRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* StopRecordRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void StopRecordRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// -------------------------------------------------------------------

// RecordStatusNotification

// required .pbmsg.Entity group_id = 1;
inline bool RecordStatusNotification::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordStatusNotification::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordStatusNotification::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordStatusNotification::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& RecordStatusNotification::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* RecordStatusNotification::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* RecordStatusNotification::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void RecordStatusNotification::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// required bool recording = 2;
inline bool RecordStatusNotification::has_recording() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordStatusNotification::set_has_recording() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordStatusNotification::clear_has_recording() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordStatusNotification::clear_recording() {
  recording_ = false;
  clear_has_recording();
}
inline bool RecordStatusNotification::recording() const {
  return recording_;
}
inline void RecordStatusNotification::set_recording(bool value) {
  set_has_recording();
  recording_ = value;
}

// -------------------------------------------------------------------

// SubscribeAccountLocationRequest

// required bool subscribing = 1;
inline bool SubscribeAccountLocationRequest::has_subscribing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeAccountLocationRequest::set_has_subscribing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeAccountLocationRequest::clear_has_subscribing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeAccountLocationRequest::clear_subscribing() {
  subscribing_ = false;
  clear_has_subscribing();
}
inline bool SubscribeAccountLocationRequest::subscribing() const {
  return subscribing_;
}
inline void SubscribeAccountLocationRequest::set_subscribing(bool value) {
  set_has_subscribing();
  subscribing_ = value;
}

// required .pbmsg.Entity account_id = 2;
inline bool SubscribeAccountLocationRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeAccountLocationRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeAccountLocationRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeAccountLocationRequest::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& SubscribeAccountLocationRequest::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* SubscribeAccountLocationRequest::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* SubscribeAccountLocationRequest::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void SubscribeAccountLocationRequest::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// required fixed32 ttl = 3;
inline bool SubscribeAccountLocationRequest::has_ttl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeAccountLocationRequest::set_has_ttl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeAccountLocationRequest::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeAccountLocationRequest::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 SubscribeAccountLocationRequest::ttl() const {
  return ttl_;
}
inline void SubscribeAccountLocationRequest::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// AccountLocationNotification

// required .pbmsg.Entity account_id = 1;
inline bool AccountLocationNotification::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLocationNotification::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLocationNotification::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLocationNotification::clear_account_id() {
  if (account_id_ != NULL) account_id_->::pbmsg::Entity::Clear();
  clear_has_account_id();
}
inline const ::pbmsg::Entity& AccountLocationNotification::account_id() const {
  return account_id_ != NULL ? *account_id_ : *default_instance_->account_id_;
}
inline ::pbmsg::Entity* AccountLocationNotification::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == NULL) account_id_ = new ::pbmsg::Entity;
  return account_id_;
}
inline ::pbmsg::Entity* AccountLocationNotification::release_account_id() {
  clear_has_account_id();
  ::pbmsg::Entity* temp = account_id_;
  account_id_ = NULL;
  return temp;
}
inline void AccountLocationNotification::set_allocated_account_id(::pbmsg::Entity* account_id) {
  delete account_id_;
  account_id_ = account_id;
  if (account_id) {
    set_has_account_id();
  } else {
    clear_has_account_id();
  }
}

// required double longitude = 2;
inline bool AccountLocationNotification::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLocationNotification::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLocationNotification::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLocationNotification::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double AccountLocationNotification::longitude() const {
  return longitude_;
}
inline void AccountLocationNotification::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// required double latitude = 3;
inline bool AccountLocationNotification::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLocationNotification::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLocationNotification::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLocationNotification::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double AccountLocationNotification::latitude() const {
  return latitude_;
}
inline void AccountLocationNotification::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// required string timestamp = 4;
inline bool AccountLocationNotification::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLocationNotification::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLocationNotification::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLocationNotification::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& AccountLocationNotification::timestamp() const {
  return *timestamp_;
}
inline void AccountLocationNotification::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void AccountLocationNotification::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void AccountLocationNotification::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLocationNotification::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* AccountLocationNotification::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLocationNotification::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AppendAlertRequest

// required .pbmsg.Alert alert = 1;
inline bool AppendAlertRequest::has_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendAlertRequest::set_has_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendAlertRequest::clear_has_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendAlertRequest::clear_alert() {
  if (alert_ != NULL) alert_->::pbmsg::Alert::Clear();
  clear_has_alert();
}
inline const ::pbmsg::Alert& AppendAlertRequest::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::pbmsg::Alert* AppendAlertRequest::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::pbmsg::Alert;
  return alert_;
}
inline ::pbmsg::Alert* AppendAlertRequest::release_alert() {
  clear_has_alert();
  ::pbmsg::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void AppendAlertRequest::set_allocated_alert(::pbmsg::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// repeated .pbmsg.Entity members = 2;
inline int AppendAlertRequest::members_size() const {
  return members_.size();
}
inline void AppendAlertRequest::clear_members() {
  members_.Clear();
}
inline const ::pbmsg::Entity& AppendAlertRequest::members(int index) const {
  return members_.Get(index);
}
inline ::pbmsg::Entity* AppendAlertRequest::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pbmsg::Entity* AppendAlertRequest::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
AppendAlertRequest::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
AppendAlertRequest::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// AppendAlertResponse

// required .pbmsg.Alert alert = 1;
inline bool AppendAlertResponse::has_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendAlertResponse::set_has_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendAlertResponse::clear_has_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendAlertResponse::clear_alert() {
  if (alert_ != NULL) alert_->::pbmsg::Alert::Clear();
  clear_has_alert();
}
inline const ::pbmsg::Alert& AppendAlertResponse::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::pbmsg::Alert* AppendAlertResponse::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::pbmsg::Alert;
  return alert_;
}
inline ::pbmsg::Alert* AppendAlertResponse::release_alert() {
  clear_has_alert();
  ::pbmsg::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void AppendAlertResponse::set_allocated_alert(::pbmsg::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// -------------------------------------------------------------------

// ModifyAlertRequest

// required .pbmsg.Alert alert = 1;
inline bool ModifyAlertRequest::has_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyAlertRequest::set_has_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyAlertRequest::clear_has_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyAlertRequest::clear_alert() {
  if (alert_ != NULL) alert_->::pbmsg::Alert::Clear();
  clear_has_alert();
}
inline const ::pbmsg::Alert& ModifyAlertRequest::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::pbmsg::Alert* ModifyAlertRequest::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::pbmsg::Alert;
  return alert_;
}
inline ::pbmsg::Alert* ModifyAlertRequest::release_alert() {
  clear_has_alert();
  ::pbmsg::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void ModifyAlertRequest::set_allocated_alert(::pbmsg::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// -------------------------------------------------------------------

// StopAlertRequest

// required .pbmsg.Entity alert_id = 1;
inline bool StopAlertRequest::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopAlertRequest::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopAlertRequest::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopAlertRequest::clear_alert_id() {
  if (alert_id_ != NULL) alert_id_->::pbmsg::Entity::Clear();
  clear_has_alert_id();
}
inline const ::pbmsg::Entity& StopAlertRequest::alert_id() const {
  return alert_id_ != NULL ? *alert_id_ : *default_instance_->alert_id_;
}
inline ::pbmsg::Entity* StopAlertRequest::mutable_alert_id() {
  set_has_alert_id();
  if (alert_id_ == NULL) alert_id_ = new ::pbmsg::Entity;
  return alert_id_;
}
inline ::pbmsg::Entity* StopAlertRequest::release_alert_id() {
  clear_has_alert_id();
  ::pbmsg::Entity* temp = alert_id_;
  alert_id_ = NULL;
  return temp;
}
inline void StopAlertRequest::set_allocated_alert_id(::pbmsg::Entity* alert_id) {
  delete alert_id_;
  alert_id_ = alert_id;
  if (alert_id) {
    set_has_alert_id();
  } else {
    clear_has_alert_id();
  }
}

// -------------------------------------------------------------------

// AlertOveredNotification

// required .pbmsg.Entity alert_id = 1;
inline bool AlertOveredNotification::has_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertOveredNotification::set_has_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertOveredNotification::clear_has_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertOveredNotification::clear_alert_id() {
  if (alert_id_ != NULL) alert_id_->::pbmsg::Entity::Clear();
  clear_has_alert_id();
}
inline const ::pbmsg::Entity& AlertOveredNotification::alert_id() const {
  return alert_id_ != NULL ? *alert_id_ : *default_instance_->alert_id_;
}
inline ::pbmsg::Entity* AlertOveredNotification::mutable_alert_id() {
  set_has_alert_id();
  if (alert_id_ == NULL) alert_id_ = new ::pbmsg::Entity;
  return alert_id_;
}
inline ::pbmsg::Entity* AlertOveredNotification::release_alert_id() {
  clear_has_alert_id();
  ::pbmsg::Entity* temp = alert_id_;
  alert_id_ = NULL;
  return temp;
}
inline void AlertOveredNotification::set_allocated_alert_id(::pbmsg::Entity* alert_id) {
  delete alert_id_;
  alert_id_ = alert_id;
  if (alert_id) {
    set_has_alert_id();
  } else {
    clear_has_alert_id();
  }
}

// -------------------------------------------------------------------

// HistoryAlertsRequest

// optional bytes name = 1;
inline bool HistoryAlertsRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertsRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertsRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertsRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HistoryAlertsRequest::name() const {
  return *name_;
}
inline void HistoryAlertsRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlertsRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HistoryAlertsRequest::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HistoryAlertsRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time_from = 2;
inline bool HistoryAlertsRequest::has_create_time_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryAlertsRequest::set_has_create_time_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryAlertsRequest::clear_has_create_time_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryAlertsRequest::clear_create_time_from() {
  if (create_time_from_ != &::google::protobuf::internal::kEmptyString) {
    create_time_from_->clear();
  }
  clear_has_create_time_from();
}
inline const ::std::string& HistoryAlertsRequest::create_time_from() const {
  return *create_time_from_;
}
inline void HistoryAlertsRequest::set_create_time_from(const ::std::string& value) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_from(const char* value) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_from(const char* value, size_t size) {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  create_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_create_time_from() {
  set_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    create_time_from_ = new ::std::string;
  }
  return create_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_create_time_from() {
  clear_has_create_time_from();
  if (create_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_from_;
    create_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_create_time_from(::std::string* create_time_from) {
  if (create_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_from_;
  }
  if (create_time_from) {
    set_has_create_time_from();
    create_time_from_ = create_time_from;
  } else {
    clear_has_create_time_from();
    create_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string create_time_to = 3;
inline bool HistoryAlertsRequest::has_create_time_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertsRequest::set_has_create_time_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertsRequest::clear_has_create_time_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertsRequest::clear_create_time_to() {
  if (create_time_to_ != &::google::protobuf::internal::kEmptyString) {
    create_time_to_->clear();
  }
  clear_has_create_time_to();
}
inline const ::std::string& HistoryAlertsRequest::create_time_to() const {
  return *create_time_to_;
}
inline void HistoryAlertsRequest::set_create_time_to(const ::std::string& value) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_to(const char* value) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_create_time_to(const char* value, size_t size) {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  create_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_create_time_to() {
  set_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    create_time_to_ = new ::std::string;
  }
  return create_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_create_time_to() {
  clear_has_create_time_to();
  if (create_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_to_;
    create_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_create_time_to(::std::string* create_time_to) {
  if (create_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_to_;
  }
  if (create_time_to) {
    set_has_create_time_to();
    create_time_to_ = create_time_to;
  } else {
    clear_has_create_time_to();
    create_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alram_time_from = 4;
inline bool HistoryAlertsRequest::has_alram_time_from() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryAlertsRequest::set_has_alram_time_from() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryAlertsRequest::clear_has_alram_time_from() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryAlertsRequest::clear_alram_time_from() {
  if (alram_time_from_ != &::google::protobuf::internal::kEmptyString) {
    alram_time_from_->clear();
  }
  clear_has_alram_time_from();
}
inline const ::std::string& HistoryAlertsRequest::alram_time_from() const {
  return *alram_time_from_;
}
inline void HistoryAlertsRequest::set_alram_time_from(const ::std::string& value) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_from(const char* value) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_from(const char* value, size_t size) {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  alram_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_alram_time_from() {
  set_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_from_ = new ::std::string;
  }
  return alram_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_alram_time_from() {
  clear_has_alram_time_from();
  if (alram_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alram_time_from_;
    alram_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_alram_time_from(::std::string* alram_time_from) {
  if (alram_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete alram_time_from_;
  }
  if (alram_time_from) {
    set_has_alram_time_from();
    alram_time_from_ = alram_time_from;
  } else {
    clear_has_alram_time_from();
    alram_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string alram_time_to = 5;
inline bool HistoryAlertsRequest::has_alram_time_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryAlertsRequest::set_has_alram_time_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryAlertsRequest::clear_has_alram_time_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryAlertsRequest::clear_alram_time_to() {
  if (alram_time_to_ != &::google::protobuf::internal::kEmptyString) {
    alram_time_to_->clear();
  }
  clear_has_alram_time_to();
}
inline const ::std::string& HistoryAlertsRequest::alram_time_to() const {
  return *alram_time_to_;
}
inline void HistoryAlertsRequest::set_alram_time_to(const ::std::string& value) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_to(const char* value) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_alram_time_to(const char* value, size_t size) {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  alram_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_alram_time_to() {
  set_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_to_ = new ::std::string;
  }
  return alram_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_alram_time_to() {
  clear_has_alram_time_to();
  if (alram_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alram_time_to_;
    alram_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_alram_time_to(::std::string* alram_time_to) {
  if (alram_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete alram_time_to_;
  }
  if (alram_time_to) {
    set_has_alram_time_to();
    alram_time_to_ = alram_time_to;
  } else {
    clear_has_alram_time_to();
    alram_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string over_time_from = 6;
inline bool HistoryAlertsRequest::has_over_time_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoryAlertsRequest::set_has_over_time_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoryAlertsRequest::clear_has_over_time_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoryAlertsRequest::clear_over_time_from() {
  if (over_time_from_ != &::google::protobuf::internal::kEmptyString) {
    over_time_from_->clear();
  }
  clear_has_over_time_from();
}
inline const ::std::string& HistoryAlertsRequest::over_time_from() const {
  return *over_time_from_;
}
inline void HistoryAlertsRequest::set_over_time_from(const ::std::string& value) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_from(const char* value) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_from(const char* value, size_t size) {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  over_time_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_over_time_from() {
  set_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    over_time_from_ = new ::std::string;
  }
  return over_time_from_;
}
inline ::std::string* HistoryAlertsRequest::release_over_time_from() {
  clear_has_over_time_from();
  if (over_time_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = over_time_from_;
    over_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_over_time_from(::std::string* over_time_from) {
  if (over_time_from_ != &::google::protobuf::internal::kEmptyString) {
    delete over_time_from_;
  }
  if (over_time_from) {
    set_has_over_time_from();
    over_time_from_ = over_time_from;
  } else {
    clear_has_over_time_from();
    over_time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string over_time_to = 7;
inline bool HistoryAlertsRequest::has_over_time_to() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoryAlertsRequest::set_has_over_time_to() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoryAlertsRequest::clear_has_over_time_to() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoryAlertsRequest::clear_over_time_to() {
  if (over_time_to_ != &::google::protobuf::internal::kEmptyString) {
    over_time_to_->clear();
  }
  clear_has_over_time_to();
}
inline const ::std::string& HistoryAlertsRequest::over_time_to() const {
  return *over_time_to_;
}
inline void HistoryAlertsRequest::set_over_time_to(const ::std::string& value) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_to(const char* value) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(value);
}
inline void HistoryAlertsRequest::set_over_time_to(const char* value, size_t size) {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  over_time_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertsRequest::mutable_over_time_to() {
  set_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    over_time_to_ = new ::std::string;
  }
  return over_time_to_;
}
inline ::std::string* HistoryAlertsRequest::release_over_time_to() {
  clear_has_over_time_to();
  if (over_time_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = over_time_to_;
    over_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertsRequest::set_allocated_over_time_to(::std::string* over_time_to) {
  if (over_time_to_ != &::google::protobuf::internal::kEmptyString) {
    delete over_time_to_;
  }
  if (over_time_to) {
    set_has_over_time_to();
    over_time_to_ = over_time_to;
  } else {
    clear_has_over_time_to();
    over_time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HistoryAlertsResponse

// repeated .pbmsg.HistoryAlert history_alerts = 1;
inline int HistoryAlertsResponse::history_alerts_size() const {
  return history_alerts_.size();
}
inline void HistoryAlertsResponse::clear_history_alerts() {
  history_alerts_.Clear();
}
inline const ::pbmsg::HistoryAlert& HistoryAlertsResponse::history_alerts(int index) const {
  return history_alerts_.Get(index);
}
inline ::pbmsg::HistoryAlert* HistoryAlertsResponse::mutable_history_alerts(int index) {
  return history_alerts_.Mutable(index);
}
inline ::pbmsg::HistoryAlert* HistoryAlertsResponse::add_history_alerts() {
  return history_alerts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::HistoryAlert >&
HistoryAlertsResponse::history_alerts() const {
  return history_alerts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::HistoryAlert >*
HistoryAlertsResponse::mutable_history_alerts() {
  return &history_alerts_;
}

// -------------------------------------------------------------------

// HistoryAlertRequest

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertRequest::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertRequest::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertRequest::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertRequest::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertRequest::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertRequest::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// -------------------------------------------------------------------

// HistoryAlertResponse

// required .pbmsg.HistoryAlert history_alert = 1;
inline bool HistoryAlertResponse::has_history_alert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertResponse::set_has_history_alert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertResponse::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertResponse::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::pbmsg::HistoryAlert::Clear();
  clear_has_history_alert();
}
inline const ::pbmsg::HistoryAlert& HistoryAlertResponse::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::pbmsg::HistoryAlert* HistoryAlertResponse::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::pbmsg::HistoryAlert;
  return history_alert_;
}
inline ::pbmsg::HistoryAlert* HistoryAlertResponse::release_history_alert() {
  clear_has_history_alert();
  ::pbmsg::HistoryAlert* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void HistoryAlertResponse::set_allocated_history_alert(::pbmsg::HistoryAlert* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// -------------------------------------------------------------------

// HistoryAlertMessageRequest

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertMessageRequest::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertMessageRequest::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertMessageRequest::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertMessageRequest::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertMessageRequest::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertMessageRequest::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// optional fixed32 from_message_id = 2;
inline bool HistoryAlertMessageRequest::has_from_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryAlertMessageRequest::set_has_from_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryAlertMessageRequest::clear_has_from_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryAlertMessageRequest::clear_from_message_id() {
  from_message_id_ = 0u;
  clear_has_from_message_id();
}
inline ::google::protobuf::uint32 HistoryAlertMessageRequest::from_message_id() const {
  return from_message_id_;
}
inline void HistoryAlertMessageRequest::set_from_message_id(::google::protobuf::uint32 value) {
  set_has_from_message_id();
  from_message_id_ = value;
}

// optional string from_time = 3;
inline bool HistoryAlertMessageRequest::has_from_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertMessageRequest::set_has_from_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertMessageRequest::clear_has_from_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertMessageRequest::clear_from_time() {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    from_time_->clear();
  }
  clear_has_from_time();
}
inline const ::std::string& HistoryAlertMessageRequest::from_time() const {
  return *from_time_;
}
inline void HistoryAlertMessageRequest::set_from_time(const ::std::string& value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void HistoryAlertMessageRequest::set_from_time(const char* value) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(value);
}
inline void HistoryAlertMessageRequest::set_from_time(const char* value, size_t size) {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  from_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistoryAlertMessageRequest::mutable_from_time() {
  set_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    from_time_ = new ::std::string;
  }
  return from_time_;
}
inline ::std::string* HistoryAlertMessageRequest::release_from_time() {
  clear_has_from_time();
  if (from_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_time_;
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HistoryAlertMessageRequest::set_allocated_from_time(::std::string* from_time) {
  if (from_time_ != &::google::protobuf::internal::kEmptyString) {
    delete from_time_;
  }
  if (from_time) {
    set_has_from_time();
    from_time_ = from_time;
  } else {
    clear_has_from_time();
    from_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 max_message_count = 4;
inline bool HistoryAlertMessageRequest::has_max_message_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryAlertMessageRequest::set_has_max_message_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryAlertMessageRequest::clear_has_max_message_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryAlertMessageRequest::clear_max_message_count() {
  max_message_count_ = 0u;
  clear_has_max_message_count();
}
inline ::google::protobuf::uint32 HistoryAlertMessageRequest::max_message_count() const {
  return max_message_count_;
}
inline void HistoryAlertMessageRequest::set_max_message_count(::google::protobuf::uint32 value) {
  set_has_max_message_count();
  max_message_count_ = value;
}

// -------------------------------------------------------------------

// HistoryAlertMessageResponse

// required fixed32 history_alert_id = 1;
inline bool HistoryAlertMessageResponse::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryAlertMessageResponse::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryAlertMessageResponse::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryAlertMessageResponse::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 HistoryAlertMessageResponse::history_alert_id() const {
  return history_alert_id_;
}
inline void HistoryAlertMessageResponse::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// repeated .pbmsg.MediaMessage messages = 2;
inline int HistoryAlertMessageResponse::messages_size() const {
  return messages_.size();
}
inline void HistoryAlertMessageResponse::clear_messages() {
  messages_.Clear();
}
inline const ::pbmsg::MediaMessage& HistoryAlertMessageResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::pbmsg::MediaMessage* HistoryAlertMessageResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::pbmsg::MediaMessage* HistoryAlertMessageResponse::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >&
HistoryAlertMessageResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::MediaMessage >*
HistoryAlertMessageResponse::mutable_messages() {
  return &messages_;
}

// required fixed32 leave_message_count = 3;
inline bool HistoryAlertMessageResponse::has_leave_message_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryAlertMessageResponse::set_has_leave_message_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryAlertMessageResponse::clear_has_leave_message_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryAlertMessageResponse::clear_leave_message_count() {
  leave_message_count_ = 0u;
  clear_has_leave_message_count();
}
inline ::google::protobuf::uint32 HistoryAlertMessageResponse::leave_message_count() const {
  return leave_message_count_;
}
inline void HistoryAlertMessageResponse::set_leave_message_count(::google::protobuf::uint32 value) {
  set_has_leave_message_count();
  leave_message_count_ = value;
}

// -------------------------------------------------------------------

// DeleteHistoryAlertRequest

// required fixed32 history_alert_id = 1;
inline bool DeleteHistoryAlertRequest::has_history_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteHistoryAlertRequest::set_has_history_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteHistoryAlertRequest::clear_has_history_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteHistoryAlertRequest::clear_history_alert_id() {
  history_alert_id_ = 0u;
  clear_has_history_alert_id();
}
inline ::google::protobuf::uint32 DeleteHistoryAlertRequest::history_alert_id() const {
  return history_alert_id_;
}
inline void DeleteHistoryAlertRequest::set_history_alert_id(::google::protobuf::uint32 value) {
  set_has_history_alert_id();
  history_alert_id_ = value;
}

// -------------------------------------------------------------------

// DeleteGroupRequest

// required .pbmsg.Entity group_id = 1;
inline bool DeleteGroupRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteGroupRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteGroupRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteGroupRequest::clear_group_id() {
  if (group_id_ != NULL) group_id_->::pbmsg::Entity::Clear();
  clear_has_group_id();
}
inline const ::pbmsg::Entity& DeleteGroupRequest::group_id() const {
  return group_id_ != NULL ? *group_id_ : *default_instance_->group_id_;
}
inline ::pbmsg::Entity* DeleteGroupRequest::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == NULL) group_id_ = new ::pbmsg::Entity;
  return group_id_;
}
inline ::pbmsg::Entity* DeleteGroupRequest::release_group_id() {
  clear_has_group_id();
  ::pbmsg::Entity* temp = group_id_;
  group_id_ = NULL;
  return temp;
}
inline void DeleteGroupRequest::set_allocated_group_id(::pbmsg::Entity* group_id) {
  delete group_id_;
  group_id_ = group_id;
  if (group_id) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
}

// -------------------------------------------------------------------

// Request

// optional .app.dispatch.LoginRequest login = 1;
inline bool Request::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_login() {
  if (login_ != NULL) login_->::app::dispatch::LoginRequest::Clear();
  clear_has_login();
}
inline const ::app::dispatch::LoginRequest& Request::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::dispatch::LoginRequest* Request::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::dispatch::LoginRequest;
  return login_;
}
inline ::app::dispatch::LoginRequest* Request::release_login() {
  clear_has_login();
  ::app::dispatch::LoginRequest* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Request::set_allocated_login(::app::dispatch::LoginRequest* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.dispatch.EntityRequest entity = 2;
inline bool Request::has_entity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_entity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_entity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_entity() {
  if (entity_ != NULL) entity_->::app::dispatch::EntityRequest::Clear();
  clear_has_entity();
}
inline const ::app::dispatch::EntityRequest& Request::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::dispatch::EntityRequest* Request::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::dispatch::EntityRequest;
  return entity_;
}
inline ::app::dispatch::EntityRequest* Request::release_entity() {
  clear_has_entity();
  ::app::dispatch::EntityRequest* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Request::set_allocated_entity(::app::dispatch::EntityRequest* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional .app.dispatch.AppendGroupRequest append_group = 3;
inline bool Request::has_append_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_append_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_append_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_append_group() {
  if (append_group_ != NULL) append_group_->::app::dispatch::AppendGroupRequest::Clear();
  clear_has_append_group();
}
inline const ::app::dispatch::AppendGroupRequest& Request::append_group() const {
  return append_group_ != NULL ? *append_group_ : *default_instance_->append_group_;
}
inline ::app::dispatch::AppendGroupRequest* Request::mutable_append_group() {
  set_has_append_group();
  if (append_group_ == NULL) append_group_ = new ::app::dispatch::AppendGroupRequest;
  return append_group_;
}
inline ::app::dispatch::AppendGroupRequest* Request::release_append_group() {
  clear_has_append_group();
  ::app::dispatch::AppendGroupRequest* temp = append_group_;
  append_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_append_group(::app::dispatch::AppendGroupRequest* append_group) {
  delete append_group_;
  append_group_ = append_group;
  if (append_group) {
    set_has_append_group();
  } else {
    clear_has_append_group();
  }
}

// optional .app.dispatch.ModifyGroupRequest modify_group = 4;
inline bool Request::has_modify_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_modify_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_modify_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_modify_group() {
  if (modify_group_ != NULL) modify_group_->::app::dispatch::ModifyGroupRequest::Clear();
  clear_has_modify_group();
}
inline const ::app::dispatch::ModifyGroupRequest& Request::modify_group() const {
  return modify_group_ != NULL ? *modify_group_ : *default_instance_->modify_group_;
}
inline ::app::dispatch::ModifyGroupRequest* Request::mutable_modify_group() {
  set_has_modify_group();
  if (modify_group_ == NULL) modify_group_ = new ::app::dispatch::ModifyGroupRequest;
  return modify_group_;
}
inline ::app::dispatch::ModifyGroupRequest* Request::release_modify_group() {
  clear_has_modify_group();
  ::app::dispatch::ModifyGroupRequest* temp = modify_group_;
  modify_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_modify_group(::app::dispatch::ModifyGroupRequest* modify_group) {
  delete modify_group_;
  modify_group_ = modify_group;
  if (modify_group) {
    set_has_modify_group();
  } else {
    clear_has_modify_group();
  }
}

// optional .app.dispatch.ModifyParticipantsRequest modify_participants = 5;
inline bool Request::has_modify_participants() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_modify_participants() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_modify_participants() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_modify_participants() {
  if (modify_participants_ != NULL) modify_participants_->::app::dispatch::ModifyParticipantsRequest::Clear();
  clear_has_modify_participants();
}
inline const ::app::dispatch::ModifyParticipantsRequest& Request::modify_participants() const {
  return modify_participants_ != NULL ? *modify_participants_ : *default_instance_->modify_participants_;
}
inline ::app::dispatch::ModifyParticipantsRequest* Request::mutable_modify_participants() {
  set_has_modify_participants();
  if (modify_participants_ == NULL) modify_participants_ = new ::app::dispatch::ModifyParticipantsRequest;
  return modify_participants_;
}
inline ::app::dispatch::ModifyParticipantsRequest* Request::release_modify_participants() {
  clear_has_modify_participants();
  ::app::dispatch::ModifyParticipantsRequest* temp = modify_participants_;
  modify_participants_ = NULL;
  return temp;
}
inline void Request::set_allocated_modify_participants(::app::dispatch::ModifyParticipantsRequest* modify_participants) {
  delete modify_participants_;
  modify_participants_ = modify_participants;
  if (modify_participants) {
    set_has_modify_participants();
  } else {
    clear_has_modify_participants();
  }
}

// optional .app.dispatch.MediaMessageRequest media_message = 6;
inline bool Request::has_media_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_media_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_media_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_media_message() {
  if (media_message_ != NULL) media_message_->::app::dispatch::MediaMessageRequest::Clear();
  clear_has_media_message();
}
inline const ::app::dispatch::MediaMessageRequest& Request::media_message() const {
  return media_message_ != NULL ? *media_message_ : *default_instance_->media_message_;
}
inline ::app::dispatch::MediaMessageRequest* Request::mutable_media_message() {
  set_has_media_message();
  if (media_message_ == NULL) media_message_ = new ::app::dispatch::MediaMessageRequest;
  return media_message_;
}
inline ::app::dispatch::MediaMessageRequest* Request::release_media_message() {
  clear_has_media_message();
  ::app::dispatch::MediaMessageRequest* temp = media_message_;
  media_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_media_message(::app::dispatch::MediaMessageRequest* media_message) {
  delete media_message_;
  media_message_ = media_message;
  if (media_message) {
    set_has_media_message();
  } else {
    clear_has_media_message();
  }
}

// optional .app.dispatch.InviteParticipantRequest invite_participant = 7;
inline bool Request::has_invite_participant() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_invite_participant() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_invite_participant() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_invite_participant() {
  if (invite_participant_ != NULL) invite_participant_->::app::dispatch::InviteParticipantRequest::Clear();
  clear_has_invite_participant();
}
inline const ::app::dispatch::InviteParticipantRequest& Request::invite_participant() const {
  return invite_participant_ != NULL ? *invite_participant_ : *default_instance_->invite_participant_;
}
inline ::app::dispatch::InviteParticipantRequest* Request::mutable_invite_participant() {
  set_has_invite_participant();
  if (invite_participant_ == NULL) invite_participant_ = new ::app::dispatch::InviteParticipantRequest;
  return invite_participant_;
}
inline ::app::dispatch::InviteParticipantRequest* Request::release_invite_participant() {
  clear_has_invite_participant();
  ::app::dispatch::InviteParticipantRequest* temp = invite_participant_;
  invite_participant_ = NULL;
  return temp;
}
inline void Request::set_allocated_invite_participant(::app::dispatch::InviteParticipantRequest* invite_participant) {
  delete invite_participant_;
  invite_participant_ = invite_participant;
  if (invite_participant) {
    set_has_invite_participant();
  } else {
    clear_has_invite_participant();
  }
}

// optional .app.dispatch.DropParticipantRequest drop_participant = 8;
inline bool Request::has_drop_participant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_drop_participant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_drop_participant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_drop_participant() {
  if (drop_participant_ != NULL) drop_participant_->::app::dispatch::DropParticipantRequest::Clear();
  clear_has_drop_participant();
}
inline const ::app::dispatch::DropParticipantRequest& Request::drop_participant() const {
  return drop_participant_ != NULL ? *drop_participant_ : *default_instance_->drop_participant_;
}
inline ::app::dispatch::DropParticipantRequest* Request::mutable_drop_participant() {
  set_has_drop_participant();
  if (drop_participant_ == NULL) drop_participant_ = new ::app::dispatch::DropParticipantRequest;
  return drop_participant_;
}
inline ::app::dispatch::DropParticipantRequest* Request::release_drop_participant() {
  clear_has_drop_participant();
  ::app::dispatch::DropParticipantRequest* temp = drop_participant_;
  drop_participant_ = NULL;
  return temp;
}
inline void Request::set_allocated_drop_participant(::app::dispatch::DropParticipantRequest* drop_participant) {
  delete drop_participant_;
  drop_participant_ = drop_participant;
  if (drop_participant) {
    set_has_drop_participant();
  } else {
    clear_has_drop_participant();
  }
}

// optional .app.dispatch.ReleaseParticipantTokenRequest release_participant_token = 9;
inline bool Request::has_release_participant_token() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_release_participant_token() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_release_participant_token() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_release_participant_token() {
  if (release_participant_token_ != NULL) release_participant_token_->::app::dispatch::ReleaseParticipantTokenRequest::Clear();
  clear_has_release_participant_token();
}
inline const ::app::dispatch::ReleaseParticipantTokenRequest& Request::release_participant_token() const {
  return release_participant_token_ != NULL ? *release_participant_token_ : *default_instance_->release_participant_token_;
}
inline ::app::dispatch::ReleaseParticipantTokenRequest* Request::mutable_release_participant_token() {
  set_has_release_participant_token();
  if (release_participant_token_ == NULL) release_participant_token_ = new ::app::dispatch::ReleaseParticipantTokenRequest;
  return release_participant_token_;
}
inline ::app::dispatch::ReleaseParticipantTokenRequest* Request::release_release_participant_token() {
  clear_has_release_participant_token();
  ::app::dispatch::ReleaseParticipantTokenRequest* temp = release_participant_token_;
  release_participant_token_ = NULL;
  return temp;
}
inline void Request::set_allocated_release_participant_token(::app::dispatch::ReleaseParticipantTokenRequest* release_participant_token) {
  delete release_participant_token_;
  release_participant_token_ = release_participant_token;
  if (release_participant_token) {
    set_has_release_participant_token();
  } else {
    clear_has_release_participant_token();
  }
}

// optional .app.dispatch.AppointParticipantSpeakRequest appoint_participant_speak = 10;
inline bool Request::has_appoint_participant_speak() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_appoint_participant_speak() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_appoint_participant_speak() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_appoint_participant_speak() {
  if (appoint_participant_speak_ != NULL) appoint_participant_speak_->::app::dispatch::AppointParticipantSpeakRequest::Clear();
  clear_has_appoint_participant_speak();
}
inline const ::app::dispatch::AppointParticipantSpeakRequest& Request::appoint_participant_speak() const {
  return appoint_participant_speak_ != NULL ? *appoint_participant_speak_ : *default_instance_->appoint_participant_speak_;
}
inline ::app::dispatch::AppointParticipantSpeakRequest* Request::mutable_appoint_participant_speak() {
  set_has_appoint_participant_speak();
  if (appoint_participant_speak_ == NULL) appoint_participant_speak_ = new ::app::dispatch::AppointParticipantSpeakRequest;
  return appoint_participant_speak_;
}
inline ::app::dispatch::AppointParticipantSpeakRequest* Request::release_appoint_participant_speak() {
  clear_has_appoint_participant_speak();
  ::app::dispatch::AppointParticipantSpeakRequest* temp = appoint_participant_speak_;
  appoint_participant_speak_ = NULL;
  return temp;
}
inline void Request::set_allocated_appoint_participant_speak(::app::dispatch::AppointParticipantSpeakRequest* appoint_participant_speak) {
  delete appoint_participant_speak_;
  appoint_participant_speak_ = appoint_participant_speak;
  if (appoint_participant_speak) {
    set_has_appoint_participant_speak();
  } else {
    clear_has_appoint_participant_speak();
  }
}

// optional .app.dispatch.JionGroupRequest jion_group = 11;
inline bool Request::has_jion_group() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_jion_group() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_jion_group() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_jion_group() {
  if (jion_group_ != NULL) jion_group_->::app::dispatch::JionGroupRequest::Clear();
  clear_has_jion_group();
}
inline const ::app::dispatch::JionGroupRequest& Request::jion_group() const {
  return jion_group_ != NULL ? *jion_group_ : *default_instance_->jion_group_;
}
inline ::app::dispatch::JionGroupRequest* Request::mutable_jion_group() {
  set_has_jion_group();
  if (jion_group_ == NULL) jion_group_ = new ::app::dispatch::JionGroupRequest;
  return jion_group_;
}
inline ::app::dispatch::JionGroupRequest* Request::release_jion_group() {
  clear_has_jion_group();
  ::app::dispatch::JionGroupRequest* temp = jion_group_;
  jion_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_jion_group(::app::dispatch::JionGroupRequest* jion_group) {
  delete jion_group_;
  jion_group_ = jion_group;
  if (jion_group) {
    set_has_jion_group();
  } else {
    clear_has_jion_group();
  }
}

// optional .app.dispatch.LeaveGroupRequest leave_group = 12;
inline bool Request::has_leave_group() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_leave_group() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_leave_group() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_leave_group() {
  if (leave_group_ != NULL) leave_group_->::app::dispatch::LeaveGroupRequest::Clear();
  clear_has_leave_group();
}
inline const ::app::dispatch::LeaveGroupRequest& Request::leave_group() const {
  return leave_group_ != NULL ? *leave_group_ : *default_instance_->leave_group_;
}
inline ::app::dispatch::LeaveGroupRequest* Request::mutable_leave_group() {
  set_has_leave_group();
  if (leave_group_ == NULL) leave_group_ = new ::app::dispatch::LeaveGroupRequest;
  return leave_group_;
}
inline ::app::dispatch::LeaveGroupRequest* Request::release_leave_group() {
  clear_has_leave_group();
  ::app::dispatch::LeaveGroupRequest* temp = leave_group_;
  leave_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_leave_group(::app::dispatch::LeaveGroupRequest* leave_group) {
  delete leave_group_;
  leave_group_ = leave_group;
  if (leave_group) {
    set_has_leave_group();
  } else {
    clear_has_leave_group();
  }
}

// optional .app.dispatch.SendMessageRequest send_message = 13;
inline bool Request::has_send_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_send_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_send_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_send_message() {
  if (send_message_ != NULL) send_message_->::app::dispatch::SendMessageRequest::Clear();
  clear_has_send_message();
}
inline const ::app::dispatch::SendMessageRequest& Request::send_message() const {
  return send_message_ != NULL ? *send_message_ : *default_instance_->send_message_;
}
inline ::app::dispatch::SendMessageRequest* Request::mutable_send_message() {
  set_has_send_message();
  if (send_message_ == NULL) send_message_ = new ::app::dispatch::SendMessageRequest;
  return send_message_;
}
inline ::app::dispatch::SendMessageRequest* Request::release_send_message() {
  clear_has_send_message();
  ::app::dispatch::SendMessageRequest* temp = send_message_;
  send_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_send_message(::app::dispatch::SendMessageRequest* send_message) {
  delete send_message_;
  send_message_ = send_message;
  if (send_message) {
    set_has_send_message();
  } else {
    clear_has_send_message();
  }
}

// optional .app.dispatch.KickParticipantRequest kick_participant = 14;
inline bool Request::has_kick_participant() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_kick_participant() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_kick_participant() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_kick_participant() {
  if (kick_participant_ != NULL) kick_participant_->::app::dispatch::KickParticipantRequest::Clear();
  clear_has_kick_participant();
}
inline const ::app::dispatch::KickParticipantRequest& Request::kick_participant() const {
  return kick_participant_ != NULL ? *kick_participant_ : *default_instance_->kick_participant_;
}
inline ::app::dispatch::KickParticipantRequest* Request::mutable_kick_participant() {
  set_has_kick_participant();
  if (kick_participant_ == NULL) kick_participant_ = new ::app::dispatch::KickParticipantRequest;
  return kick_participant_;
}
inline ::app::dispatch::KickParticipantRequest* Request::release_kick_participant() {
  clear_has_kick_participant();
  ::app::dispatch::KickParticipantRequest* temp = kick_participant_;
  kick_participant_ = NULL;
  return temp;
}
inline void Request::set_allocated_kick_participant(::app::dispatch::KickParticipantRequest* kick_participant) {
  delete kick_participant_;
  kick_participant_ = kick_participant;
  if (kick_participant) {
    set_has_kick_participant();
  } else {
    clear_has_kick_participant();
  }
}

// optional .app.dispatch.StartRecordRequest start_record = 15;
inline bool Request::has_start_record() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_start_record() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_start_record() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_start_record() {
  if (start_record_ != NULL) start_record_->::app::dispatch::StartRecordRequest::Clear();
  clear_has_start_record();
}
inline const ::app::dispatch::StartRecordRequest& Request::start_record() const {
  return start_record_ != NULL ? *start_record_ : *default_instance_->start_record_;
}
inline ::app::dispatch::StartRecordRequest* Request::mutable_start_record() {
  set_has_start_record();
  if (start_record_ == NULL) start_record_ = new ::app::dispatch::StartRecordRequest;
  return start_record_;
}
inline ::app::dispatch::StartRecordRequest* Request::release_start_record() {
  clear_has_start_record();
  ::app::dispatch::StartRecordRequest* temp = start_record_;
  start_record_ = NULL;
  return temp;
}
inline void Request::set_allocated_start_record(::app::dispatch::StartRecordRequest* start_record) {
  delete start_record_;
  start_record_ = start_record;
  if (start_record) {
    set_has_start_record();
  } else {
    clear_has_start_record();
  }
}

// optional .app.dispatch.StopRecordRequest stop_record = 16;
inline bool Request::has_stop_record() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Request::set_has_stop_record() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Request::clear_has_stop_record() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Request::clear_stop_record() {
  if (stop_record_ != NULL) stop_record_->::app::dispatch::StopRecordRequest::Clear();
  clear_has_stop_record();
}
inline const ::app::dispatch::StopRecordRequest& Request::stop_record() const {
  return stop_record_ != NULL ? *stop_record_ : *default_instance_->stop_record_;
}
inline ::app::dispatch::StopRecordRequest* Request::mutable_stop_record() {
  set_has_stop_record();
  if (stop_record_ == NULL) stop_record_ = new ::app::dispatch::StopRecordRequest;
  return stop_record_;
}
inline ::app::dispatch::StopRecordRequest* Request::release_stop_record() {
  clear_has_stop_record();
  ::app::dispatch::StopRecordRequest* temp = stop_record_;
  stop_record_ = NULL;
  return temp;
}
inline void Request::set_allocated_stop_record(::app::dispatch::StopRecordRequest* stop_record) {
  delete stop_record_;
  stop_record_ = stop_record;
  if (stop_record) {
    set_has_stop_record();
  } else {
    clear_has_stop_record();
  }
}

// optional .app.dispatch.SubscribeAccountLocationRequest subscribe_account_location = 17;
inline bool Request::has_subscribe_account_location() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Request::set_has_subscribe_account_location() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Request::clear_has_subscribe_account_location() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Request::clear_subscribe_account_location() {
  if (subscribe_account_location_ != NULL) subscribe_account_location_->::app::dispatch::SubscribeAccountLocationRequest::Clear();
  clear_has_subscribe_account_location();
}
inline const ::app::dispatch::SubscribeAccountLocationRequest& Request::subscribe_account_location() const {
  return subscribe_account_location_ != NULL ? *subscribe_account_location_ : *default_instance_->subscribe_account_location_;
}
inline ::app::dispatch::SubscribeAccountLocationRequest* Request::mutable_subscribe_account_location() {
  set_has_subscribe_account_location();
  if (subscribe_account_location_ == NULL) subscribe_account_location_ = new ::app::dispatch::SubscribeAccountLocationRequest;
  return subscribe_account_location_;
}
inline ::app::dispatch::SubscribeAccountLocationRequest* Request::release_subscribe_account_location() {
  clear_has_subscribe_account_location();
  ::app::dispatch::SubscribeAccountLocationRequest* temp = subscribe_account_location_;
  subscribe_account_location_ = NULL;
  return temp;
}
inline void Request::set_allocated_subscribe_account_location(::app::dispatch::SubscribeAccountLocationRequest* subscribe_account_location) {
  delete subscribe_account_location_;
  subscribe_account_location_ = subscribe_account_location;
  if (subscribe_account_location) {
    set_has_subscribe_account_location();
  } else {
    clear_has_subscribe_account_location();
  }
}

// optional .app.dispatch.AppendAlertRequest append_alert = 18;
inline bool Request::has_append_alert() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Request::set_has_append_alert() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Request::clear_has_append_alert() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Request::clear_append_alert() {
  if (append_alert_ != NULL) append_alert_->::app::dispatch::AppendAlertRequest::Clear();
  clear_has_append_alert();
}
inline const ::app::dispatch::AppendAlertRequest& Request::append_alert() const {
  return append_alert_ != NULL ? *append_alert_ : *default_instance_->append_alert_;
}
inline ::app::dispatch::AppendAlertRequest* Request::mutable_append_alert() {
  set_has_append_alert();
  if (append_alert_ == NULL) append_alert_ = new ::app::dispatch::AppendAlertRequest;
  return append_alert_;
}
inline ::app::dispatch::AppendAlertRequest* Request::release_append_alert() {
  clear_has_append_alert();
  ::app::dispatch::AppendAlertRequest* temp = append_alert_;
  append_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_append_alert(::app::dispatch::AppendAlertRequest* append_alert) {
  delete append_alert_;
  append_alert_ = append_alert;
  if (append_alert) {
    set_has_append_alert();
  } else {
    clear_has_append_alert();
  }
}

// optional .app.dispatch.ModifyAlertRequest modify_alert = 19;
inline bool Request::has_modify_alert() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Request::set_has_modify_alert() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Request::clear_has_modify_alert() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Request::clear_modify_alert() {
  if (modify_alert_ != NULL) modify_alert_->::app::dispatch::ModifyAlertRequest::Clear();
  clear_has_modify_alert();
}
inline const ::app::dispatch::ModifyAlertRequest& Request::modify_alert() const {
  return modify_alert_ != NULL ? *modify_alert_ : *default_instance_->modify_alert_;
}
inline ::app::dispatch::ModifyAlertRequest* Request::mutable_modify_alert() {
  set_has_modify_alert();
  if (modify_alert_ == NULL) modify_alert_ = new ::app::dispatch::ModifyAlertRequest;
  return modify_alert_;
}
inline ::app::dispatch::ModifyAlertRequest* Request::release_modify_alert() {
  clear_has_modify_alert();
  ::app::dispatch::ModifyAlertRequest* temp = modify_alert_;
  modify_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_modify_alert(::app::dispatch::ModifyAlertRequest* modify_alert) {
  delete modify_alert_;
  modify_alert_ = modify_alert;
  if (modify_alert) {
    set_has_modify_alert();
  } else {
    clear_has_modify_alert();
  }
}

// optional .app.dispatch.StopAlertRequest stop_alert = 20;
inline bool Request::has_stop_alert() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Request::set_has_stop_alert() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Request::clear_has_stop_alert() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Request::clear_stop_alert() {
  if (stop_alert_ != NULL) stop_alert_->::app::dispatch::StopAlertRequest::Clear();
  clear_has_stop_alert();
}
inline const ::app::dispatch::StopAlertRequest& Request::stop_alert() const {
  return stop_alert_ != NULL ? *stop_alert_ : *default_instance_->stop_alert_;
}
inline ::app::dispatch::StopAlertRequest* Request::mutable_stop_alert() {
  set_has_stop_alert();
  if (stop_alert_ == NULL) stop_alert_ = new ::app::dispatch::StopAlertRequest;
  return stop_alert_;
}
inline ::app::dispatch::StopAlertRequest* Request::release_stop_alert() {
  clear_has_stop_alert();
  ::app::dispatch::StopAlertRequest* temp = stop_alert_;
  stop_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_stop_alert(::app::dispatch::StopAlertRequest* stop_alert) {
  delete stop_alert_;
  stop_alert_ = stop_alert;
  if (stop_alert) {
    set_has_stop_alert();
  } else {
    clear_has_stop_alert();
  }
}

// optional .app.dispatch.HistoryAlertsRequest history_alerts = 21;
inline bool Request::has_history_alerts() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Request::set_has_history_alerts() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Request::clear_has_history_alerts() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Request::clear_history_alerts() {
  if (history_alerts_ != NULL) history_alerts_->::app::dispatch::HistoryAlertsRequest::Clear();
  clear_has_history_alerts();
}
inline const ::app::dispatch::HistoryAlertsRequest& Request::history_alerts() const {
  return history_alerts_ != NULL ? *history_alerts_ : *default_instance_->history_alerts_;
}
inline ::app::dispatch::HistoryAlertsRequest* Request::mutable_history_alerts() {
  set_has_history_alerts();
  if (history_alerts_ == NULL) history_alerts_ = new ::app::dispatch::HistoryAlertsRequest;
  return history_alerts_;
}
inline ::app::dispatch::HistoryAlertsRequest* Request::release_history_alerts() {
  clear_has_history_alerts();
  ::app::dispatch::HistoryAlertsRequest* temp = history_alerts_;
  history_alerts_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alerts(::app::dispatch::HistoryAlertsRequest* history_alerts) {
  delete history_alerts_;
  history_alerts_ = history_alerts;
  if (history_alerts) {
    set_has_history_alerts();
  } else {
    clear_has_history_alerts();
  }
}

// optional .app.dispatch.HistoryAlertRequest history_alert = 22;
inline bool Request::has_history_alert() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Request::set_has_history_alert() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Request::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Request::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::app::dispatch::HistoryAlertRequest::Clear();
  clear_has_history_alert();
}
inline const ::app::dispatch::HistoryAlertRequest& Request::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::app::dispatch::HistoryAlertRequest* Request::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::app::dispatch::HistoryAlertRequest;
  return history_alert_;
}
inline ::app::dispatch::HistoryAlertRequest* Request::release_history_alert() {
  clear_has_history_alert();
  ::app::dispatch::HistoryAlertRequest* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alert(::app::dispatch::HistoryAlertRequest* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// optional .app.dispatch.DeleteHistoryAlertRequest delete_history_alert = 23;
inline bool Request::has_delete_history_alert() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Request::set_has_delete_history_alert() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Request::clear_has_delete_history_alert() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Request::clear_delete_history_alert() {
  if (delete_history_alert_ != NULL) delete_history_alert_->::app::dispatch::DeleteHistoryAlertRequest::Clear();
  clear_has_delete_history_alert();
}
inline const ::app::dispatch::DeleteHistoryAlertRequest& Request::delete_history_alert() const {
  return delete_history_alert_ != NULL ? *delete_history_alert_ : *default_instance_->delete_history_alert_;
}
inline ::app::dispatch::DeleteHistoryAlertRequest* Request::mutable_delete_history_alert() {
  set_has_delete_history_alert();
  if (delete_history_alert_ == NULL) delete_history_alert_ = new ::app::dispatch::DeleteHistoryAlertRequest;
  return delete_history_alert_;
}
inline ::app::dispatch::DeleteHistoryAlertRequest* Request::release_delete_history_alert() {
  clear_has_delete_history_alert();
  ::app::dispatch::DeleteHistoryAlertRequest* temp = delete_history_alert_;
  delete_history_alert_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_history_alert(::app::dispatch::DeleteHistoryAlertRequest* delete_history_alert) {
  delete delete_history_alert_;
  delete_history_alert_ = delete_history_alert;
  if (delete_history_alert) {
    set_has_delete_history_alert();
  } else {
    clear_has_delete_history_alert();
  }
}

// optional .app.dispatch.DeleteGroupRequest delete_group = 24;
inline bool Request::has_delete_group() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Request::set_has_delete_group() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Request::clear_has_delete_group() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Request::clear_delete_group() {
  if (delete_group_ != NULL) delete_group_->::app::dispatch::DeleteGroupRequest::Clear();
  clear_has_delete_group();
}
inline const ::app::dispatch::DeleteGroupRequest& Request::delete_group() const {
  return delete_group_ != NULL ? *delete_group_ : *default_instance_->delete_group_;
}
inline ::app::dispatch::DeleteGroupRequest* Request::mutable_delete_group() {
  set_has_delete_group();
  if (delete_group_ == NULL) delete_group_ = new ::app::dispatch::DeleteGroupRequest;
  return delete_group_;
}
inline ::app::dispatch::DeleteGroupRequest* Request::release_delete_group() {
  clear_has_delete_group();
  ::app::dispatch::DeleteGroupRequest* temp = delete_group_;
  delete_group_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_group(::app::dispatch::DeleteGroupRequest* delete_group) {
  delete delete_group_;
  delete_group_ = delete_group;
  if (delete_group) {
    set_has_delete_group();
  } else {
    clear_has_delete_group();
  }
}

// optional .app.dispatch.HistoryAlertMessageRequest history_alert_message = 25;
inline bool Request::has_history_alert_message() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Request::set_has_history_alert_message() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Request::clear_has_history_alert_message() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Request::clear_history_alert_message() {
  if (history_alert_message_ != NULL) history_alert_message_->::app::dispatch::HistoryAlertMessageRequest::Clear();
  clear_has_history_alert_message();
}
inline const ::app::dispatch::HistoryAlertMessageRequest& Request::history_alert_message() const {
  return history_alert_message_ != NULL ? *history_alert_message_ : *default_instance_->history_alert_message_;
}
inline ::app::dispatch::HistoryAlertMessageRequest* Request::mutable_history_alert_message() {
  set_has_history_alert_message();
  if (history_alert_message_ == NULL) history_alert_message_ = new ::app::dispatch::HistoryAlertMessageRequest;
  return history_alert_message_;
}
inline ::app::dispatch::HistoryAlertMessageRequest* Request::release_history_alert_message() {
  clear_has_history_alert_message();
  ::app::dispatch::HistoryAlertMessageRequest* temp = history_alert_message_;
  history_alert_message_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_alert_message(::app::dispatch::HistoryAlertMessageRequest* history_alert_message) {
  delete history_alert_message_;
  history_alert_message_ = history_alert_message;
  if (history_alert_message) {
    set_has_history_alert_message();
  } else {
    clear_has_history_alert_message();
  }
}

// -------------------------------------------------------------------

// Response

// required bool result = 1;
inline bool Response::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool Response::result() const {
  return result_;
}
inline void Response::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required bool last_response = 2;
inline bool Response::has_last_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_last_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_last_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_last_response() {
  last_response_ = false;
  clear_has_last_response();
}
inline bool Response::last_response() const {
  return last_response_;
}
inline void Response::set_last_response(bool value) {
  set_has_last_response();
  last_response_ = value;
}

// optional bytes error_describe = 3;
inline bool Response::has_error_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_error_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_error_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_error_describe() {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    error_describe_->clear();
  }
  clear_has_error_describe();
}
inline const ::std::string& Response::error_describe() const {
  return *error_describe_;
}
inline void Response::set_error_describe(const ::std::string& value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const char* value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const void* value, size_t size) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_error_describe() {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  return error_describe_;
}
inline ::std::string* Response::release_error_describe() {
  clear_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_describe_;
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_error_describe(::std::string* error_describe) {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    delete error_describe_;
  }
  if (error_describe) {
    set_has_error_describe();
    error_describe_ = error_describe;
  } else {
    clear_has_error_describe();
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .app.dispatch.LoginResponse login = 4;
inline bool Response::has_login() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_login() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_login() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_login() {
  if (login_ != NULL) login_->::app::dispatch::LoginResponse::Clear();
  clear_has_login();
}
inline const ::app::dispatch::LoginResponse& Response::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::dispatch::LoginResponse* Response::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::dispatch::LoginResponse;
  return login_;
}
inline ::app::dispatch::LoginResponse* Response::release_login() {
  clear_has_login();
  ::app::dispatch::LoginResponse* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Response::set_allocated_login(::app::dispatch::LoginResponse* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.dispatch.EntityResponse entity = 5;
inline bool Response::has_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_entity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_entity() {
  if (entity_ != NULL) entity_->::app::dispatch::EntityResponse::Clear();
  clear_has_entity();
}
inline const ::app::dispatch::EntityResponse& Response::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::dispatch::EntityResponse* Response::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::dispatch::EntityResponse;
  return entity_;
}
inline ::app::dispatch::EntityResponse* Response::release_entity() {
  clear_has_entity();
  ::app::dispatch::EntityResponse* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Response::set_allocated_entity(::app::dispatch::EntityResponse* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional .app.dispatch.AppendGroupResponse append_group = 6;
inline bool Response::has_append_group() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_append_group() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_append_group() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_append_group() {
  if (append_group_ != NULL) append_group_->::app::dispatch::AppendGroupResponse::Clear();
  clear_has_append_group();
}
inline const ::app::dispatch::AppendGroupResponse& Response::append_group() const {
  return append_group_ != NULL ? *append_group_ : *default_instance_->append_group_;
}
inline ::app::dispatch::AppendGroupResponse* Response::mutable_append_group() {
  set_has_append_group();
  if (append_group_ == NULL) append_group_ = new ::app::dispatch::AppendGroupResponse;
  return append_group_;
}
inline ::app::dispatch::AppendGroupResponse* Response::release_append_group() {
  clear_has_append_group();
  ::app::dispatch::AppendGroupResponse* temp = append_group_;
  append_group_ = NULL;
  return temp;
}
inline void Response::set_allocated_append_group(::app::dispatch::AppendGroupResponse* append_group) {
  delete append_group_;
  append_group_ = append_group;
  if (append_group) {
    set_has_append_group();
  } else {
    clear_has_append_group();
  }
}

// optional .app.dispatch.ModifyGroupResponse modify_group = 7;
inline bool Response::has_modify_group() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_modify_group() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_modify_group() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_modify_group() {
  if (modify_group_ != NULL) modify_group_->::app::dispatch::ModifyGroupResponse::Clear();
  clear_has_modify_group();
}
inline const ::app::dispatch::ModifyGroupResponse& Response::modify_group() const {
  return modify_group_ != NULL ? *modify_group_ : *default_instance_->modify_group_;
}
inline ::app::dispatch::ModifyGroupResponse* Response::mutable_modify_group() {
  set_has_modify_group();
  if (modify_group_ == NULL) modify_group_ = new ::app::dispatch::ModifyGroupResponse;
  return modify_group_;
}
inline ::app::dispatch::ModifyGroupResponse* Response::release_modify_group() {
  clear_has_modify_group();
  ::app::dispatch::ModifyGroupResponse* temp = modify_group_;
  modify_group_ = NULL;
  return temp;
}
inline void Response::set_allocated_modify_group(::app::dispatch::ModifyGroupResponse* modify_group) {
  delete modify_group_;
  modify_group_ = modify_group;
  if (modify_group) {
    set_has_modify_group();
  } else {
    clear_has_modify_group();
  }
}

// optional .app.dispatch.ModifyParticipantsResponse modify_participants = 8;
inline bool Response::has_modify_participants() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_modify_participants() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_modify_participants() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_modify_participants() {
  if (modify_participants_ != NULL) modify_participants_->::app::dispatch::ModifyParticipantsResponse::Clear();
  clear_has_modify_participants();
}
inline const ::app::dispatch::ModifyParticipantsResponse& Response::modify_participants() const {
  return modify_participants_ != NULL ? *modify_participants_ : *default_instance_->modify_participants_;
}
inline ::app::dispatch::ModifyParticipantsResponse* Response::mutable_modify_participants() {
  set_has_modify_participants();
  if (modify_participants_ == NULL) modify_participants_ = new ::app::dispatch::ModifyParticipantsResponse;
  return modify_participants_;
}
inline ::app::dispatch::ModifyParticipantsResponse* Response::release_modify_participants() {
  clear_has_modify_participants();
  ::app::dispatch::ModifyParticipantsResponse* temp = modify_participants_;
  modify_participants_ = NULL;
  return temp;
}
inline void Response::set_allocated_modify_participants(::app::dispatch::ModifyParticipantsResponse* modify_participants) {
  delete modify_participants_;
  modify_participants_ = modify_participants;
  if (modify_participants) {
    set_has_modify_participants();
  } else {
    clear_has_modify_participants();
  }
}

// optional .app.dispatch.MediaMessageResponse media_message = 9;
inline bool Response::has_media_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_media_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_media_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_media_message() {
  if (media_message_ != NULL) media_message_->::app::dispatch::MediaMessageResponse::Clear();
  clear_has_media_message();
}
inline const ::app::dispatch::MediaMessageResponse& Response::media_message() const {
  return media_message_ != NULL ? *media_message_ : *default_instance_->media_message_;
}
inline ::app::dispatch::MediaMessageResponse* Response::mutable_media_message() {
  set_has_media_message();
  if (media_message_ == NULL) media_message_ = new ::app::dispatch::MediaMessageResponse;
  return media_message_;
}
inline ::app::dispatch::MediaMessageResponse* Response::release_media_message() {
  clear_has_media_message();
  ::app::dispatch::MediaMessageResponse* temp = media_message_;
  media_message_ = NULL;
  return temp;
}
inline void Response::set_allocated_media_message(::app::dispatch::MediaMessageResponse* media_message) {
  delete media_message_;
  media_message_ = media_message;
  if (media_message) {
    set_has_media_message();
  } else {
    clear_has_media_message();
  }
}

// optional .app.dispatch.AppendAlertResponse append_alert = 10;
inline bool Response::has_append_alert() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_append_alert() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_append_alert() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_append_alert() {
  if (append_alert_ != NULL) append_alert_->::app::dispatch::AppendAlertResponse::Clear();
  clear_has_append_alert();
}
inline const ::app::dispatch::AppendAlertResponse& Response::append_alert() const {
  return append_alert_ != NULL ? *append_alert_ : *default_instance_->append_alert_;
}
inline ::app::dispatch::AppendAlertResponse* Response::mutable_append_alert() {
  set_has_append_alert();
  if (append_alert_ == NULL) append_alert_ = new ::app::dispatch::AppendAlertResponse;
  return append_alert_;
}
inline ::app::dispatch::AppendAlertResponse* Response::release_append_alert() {
  clear_has_append_alert();
  ::app::dispatch::AppendAlertResponse* temp = append_alert_;
  append_alert_ = NULL;
  return temp;
}
inline void Response::set_allocated_append_alert(::app::dispatch::AppendAlertResponse* append_alert) {
  delete append_alert_;
  append_alert_ = append_alert;
  if (append_alert) {
    set_has_append_alert();
  } else {
    clear_has_append_alert();
  }
}

// optional .app.dispatch.HistoryAlertsResponse history_alerts = 11;
inline bool Response::has_history_alerts() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_history_alerts() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_history_alerts() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_history_alerts() {
  if (history_alerts_ != NULL) history_alerts_->::app::dispatch::HistoryAlertsResponse::Clear();
  clear_has_history_alerts();
}
inline const ::app::dispatch::HistoryAlertsResponse& Response::history_alerts() const {
  return history_alerts_ != NULL ? *history_alerts_ : *default_instance_->history_alerts_;
}
inline ::app::dispatch::HistoryAlertsResponse* Response::mutable_history_alerts() {
  set_has_history_alerts();
  if (history_alerts_ == NULL) history_alerts_ = new ::app::dispatch::HistoryAlertsResponse;
  return history_alerts_;
}
inline ::app::dispatch::HistoryAlertsResponse* Response::release_history_alerts() {
  clear_has_history_alerts();
  ::app::dispatch::HistoryAlertsResponse* temp = history_alerts_;
  history_alerts_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alerts(::app::dispatch::HistoryAlertsResponse* history_alerts) {
  delete history_alerts_;
  history_alerts_ = history_alerts;
  if (history_alerts) {
    set_has_history_alerts();
  } else {
    clear_has_history_alerts();
  }
}

// optional .app.dispatch.HistoryAlertResponse history_alert = 12;
inline bool Response::has_history_alert() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_history_alert() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_history_alert() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_history_alert() {
  if (history_alert_ != NULL) history_alert_->::app::dispatch::HistoryAlertResponse::Clear();
  clear_has_history_alert();
}
inline const ::app::dispatch::HistoryAlertResponse& Response::history_alert() const {
  return history_alert_ != NULL ? *history_alert_ : *default_instance_->history_alert_;
}
inline ::app::dispatch::HistoryAlertResponse* Response::mutable_history_alert() {
  set_has_history_alert();
  if (history_alert_ == NULL) history_alert_ = new ::app::dispatch::HistoryAlertResponse;
  return history_alert_;
}
inline ::app::dispatch::HistoryAlertResponse* Response::release_history_alert() {
  clear_has_history_alert();
  ::app::dispatch::HistoryAlertResponse* temp = history_alert_;
  history_alert_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alert(::app::dispatch::HistoryAlertResponse* history_alert) {
  delete history_alert_;
  history_alert_ = history_alert;
  if (history_alert) {
    set_has_history_alert();
  } else {
    clear_has_history_alert();
  }
}

// optional .app.dispatch.HistoryAlertMessageResponse history_alert_message = 13;
inline bool Response::has_history_alert_message() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_history_alert_message() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_history_alert_message() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_history_alert_message() {
  if (history_alert_message_ != NULL) history_alert_message_->::app::dispatch::HistoryAlertMessageResponse::Clear();
  clear_has_history_alert_message();
}
inline const ::app::dispatch::HistoryAlertMessageResponse& Response::history_alert_message() const {
  return history_alert_message_ != NULL ? *history_alert_message_ : *default_instance_->history_alert_message_;
}
inline ::app::dispatch::HistoryAlertMessageResponse* Response::mutable_history_alert_message() {
  set_has_history_alert_message();
  if (history_alert_message_ == NULL) history_alert_message_ = new ::app::dispatch::HistoryAlertMessageResponse;
  return history_alert_message_;
}
inline ::app::dispatch::HistoryAlertMessageResponse* Response::release_history_alert_message() {
  clear_has_history_alert_message();
  ::app::dispatch::HistoryAlertMessageResponse* temp = history_alert_message_;
  history_alert_message_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_alert_message(::app::dispatch::HistoryAlertMessageResponse* history_alert_message) {
  delete history_alert_message_;
  history_alert_message_ = history_alert_message;
  if (history_alert_message) {
    set_has_history_alert_message();
  } else {
    clear_has_history_alert_message();
  }
}

// -------------------------------------------------------------------

// Indication

// optional .app.dispatch.EntityNotification entity = 1;
inline bool Indication::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Indication::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Indication::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Indication::clear_entity() {
  if (entity_ != NULL) entity_->::app::dispatch::EntityNotification::Clear();
  clear_has_entity();
}
inline const ::app::dispatch::EntityNotification& Indication::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::dispatch::EntityNotification* Indication::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::dispatch::EntityNotification;
  return entity_;
}
inline ::app::dispatch::EntityNotification* Indication::release_entity() {
  clear_has_entity();
  ::app::dispatch::EntityNotification* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Indication::set_allocated_entity(::app::dispatch::EntityNotification* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional .app.dispatch.EntityStatusNotification entity_status = 2;
inline bool Indication::has_entity_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Indication::set_has_entity_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Indication::clear_has_entity_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Indication::clear_entity_status() {
  if (entity_status_ != NULL) entity_status_->::app::dispatch::EntityStatusNotification::Clear();
  clear_has_entity_status();
}
inline const ::app::dispatch::EntityStatusNotification& Indication::entity_status() const {
  return entity_status_ != NULL ? *entity_status_ : *default_instance_->entity_status_;
}
inline ::app::dispatch::EntityStatusNotification* Indication::mutable_entity_status() {
  set_has_entity_status();
  if (entity_status_ == NULL) entity_status_ = new ::app::dispatch::EntityStatusNotification;
  return entity_status_;
}
inline ::app::dispatch::EntityStatusNotification* Indication::release_entity_status() {
  clear_has_entity_status();
  ::app::dispatch::EntityStatusNotification* temp = entity_status_;
  entity_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_entity_status(::app::dispatch::EntityStatusNotification* entity_status) {
  delete entity_status_;
  entity_status_ = entity_status;
  if (entity_status) {
    set_has_entity_status();
  } else {
    clear_has_entity_status();
  }
}

// optional .app.dispatch.ParticipantsNotification participants = 3;
inline bool Indication::has_participants() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Indication::set_has_participants() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Indication::clear_has_participants() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Indication::clear_participants() {
  if (participants_ != NULL) participants_->::app::dispatch::ParticipantsNotification::Clear();
  clear_has_participants();
}
inline const ::app::dispatch::ParticipantsNotification& Indication::participants() const {
  return participants_ != NULL ? *participants_ : *default_instance_->participants_;
}
inline ::app::dispatch::ParticipantsNotification* Indication::mutable_participants() {
  set_has_participants();
  if (participants_ == NULL) participants_ = new ::app::dispatch::ParticipantsNotification;
  return participants_;
}
inline ::app::dispatch::ParticipantsNotification* Indication::release_participants() {
  clear_has_participants();
  ::app::dispatch::ParticipantsNotification* temp = participants_;
  participants_ = NULL;
  return temp;
}
inline void Indication::set_allocated_participants(::app::dispatch::ParticipantsNotification* participants) {
  delete participants_;
  participants_ = participants;
  if (participants) {
    set_has_participants();
  } else {
    clear_has_participants();
  }
}

// optional .app.dispatch.JoinGroupRequestNotification join_group_request = 4;
inline bool Indication::has_join_group_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Indication::set_has_join_group_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Indication::clear_has_join_group_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Indication::clear_join_group_request() {
  if (join_group_request_ != NULL) join_group_request_->::app::dispatch::JoinGroupRequestNotification::Clear();
  clear_has_join_group_request();
}
inline const ::app::dispatch::JoinGroupRequestNotification& Indication::join_group_request() const {
  return join_group_request_ != NULL ? *join_group_request_ : *default_instance_->join_group_request_;
}
inline ::app::dispatch::JoinGroupRequestNotification* Indication::mutable_join_group_request() {
  set_has_join_group_request();
  if (join_group_request_ == NULL) join_group_request_ = new ::app::dispatch::JoinGroupRequestNotification;
  return join_group_request_;
}
inline ::app::dispatch::JoinGroupRequestNotification* Indication::release_join_group_request() {
  clear_has_join_group_request();
  ::app::dispatch::JoinGroupRequestNotification* temp = join_group_request_;
  join_group_request_ = NULL;
  return temp;
}
inline void Indication::set_allocated_join_group_request(::app::dispatch::JoinGroupRequestNotification* join_group_request) {
  delete join_group_request_;
  join_group_request_ = join_group_request;
  if (join_group_request) {
    set_has_join_group_request();
  } else {
    clear_has_join_group_request();
  }
}

// optional .app.dispatch.ParticipantStatusNotification participant_status = 5;
inline bool Indication::has_participant_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Indication::set_has_participant_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Indication::clear_has_participant_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Indication::clear_participant_status() {
  if (participant_status_ != NULL) participant_status_->::app::dispatch::ParticipantStatusNotification::Clear();
  clear_has_participant_status();
}
inline const ::app::dispatch::ParticipantStatusNotification& Indication::participant_status() const {
  return participant_status_ != NULL ? *participant_status_ : *default_instance_->participant_status_;
}
inline ::app::dispatch::ParticipantStatusNotification* Indication::mutable_participant_status() {
  set_has_participant_status();
  if (participant_status_ == NULL) participant_status_ = new ::app::dispatch::ParticipantStatusNotification;
  return participant_status_;
}
inline ::app::dispatch::ParticipantStatusNotification* Indication::release_participant_status() {
  clear_has_participant_status();
  ::app::dispatch::ParticipantStatusNotification* temp = participant_status_;
  participant_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_participant_status(::app::dispatch::ParticipantStatusNotification* participant_status) {
  delete participant_status_;
  participant_status_ = participant_status;
  if (participant_status) {
    set_has_participant_status();
  } else {
    clear_has_participant_status();
  }
}

// optional .app.dispatch.MediaMessageNotification media_message = 6;
inline bool Indication::has_media_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Indication::set_has_media_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Indication::clear_has_media_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Indication::clear_media_message() {
  if (media_message_ != NULL) media_message_->::app::dispatch::MediaMessageNotification::Clear();
  clear_has_media_message();
}
inline const ::app::dispatch::MediaMessageNotification& Indication::media_message() const {
  return media_message_ != NULL ? *media_message_ : *default_instance_->media_message_;
}
inline ::app::dispatch::MediaMessageNotification* Indication::mutable_media_message() {
  set_has_media_message();
  if (media_message_ == NULL) media_message_ = new ::app::dispatch::MediaMessageNotification;
  return media_message_;
}
inline ::app::dispatch::MediaMessageNotification* Indication::release_media_message() {
  clear_has_media_message();
  ::app::dispatch::MediaMessageNotification* temp = media_message_;
  media_message_ = NULL;
  return temp;
}
inline void Indication::set_allocated_media_message(::app::dispatch::MediaMessageNotification* media_message) {
  delete media_message_;
  media_message_ = media_message;
  if (media_message) {
    set_has_media_message();
  } else {
    clear_has_media_message();
  }
}

// optional .app.dispatch.ParticipantConnectRequestNotification participant_connect_request = 7;
inline bool Indication::has_participant_connect_request() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Indication::set_has_participant_connect_request() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Indication::clear_has_participant_connect_request() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Indication::clear_participant_connect_request() {
  if (participant_connect_request_ != NULL) participant_connect_request_->::app::dispatch::ParticipantConnectRequestNotification::Clear();
  clear_has_participant_connect_request();
}
inline const ::app::dispatch::ParticipantConnectRequestNotification& Indication::participant_connect_request() const {
  return participant_connect_request_ != NULL ? *participant_connect_request_ : *default_instance_->participant_connect_request_;
}
inline ::app::dispatch::ParticipantConnectRequestNotification* Indication::mutable_participant_connect_request() {
  set_has_participant_connect_request();
  if (participant_connect_request_ == NULL) participant_connect_request_ = new ::app::dispatch::ParticipantConnectRequestNotification;
  return participant_connect_request_;
}
inline ::app::dispatch::ParticipantConnectRequestNotification* Indication::release_participant_connect_request() {
  clear_has_participant_connect_request();
  ::app::dispatch::ParticipantConnectRequestNotification* temp = participant_connect_request_;
  participant_connect_request_ = NULL;
  return temp;
}
inline void Indication::set_allocated_participant_connect_request(::app::dispatch::ParticipantConnectRequestNotification* participant_connect_request) {
  delete participant_connect_request_;
  participant_connect_request_ = participant_connect_request;
  if (participant_connect_request) {
    set_has_participant_connect_request();
  } else {
    clear_has_participant_connect_request();
  }
}

// optional .app.dispatch.ParticipantSpeakRequestNotification participant_speak_request = 8;
inline bool Indication::has_participant_speak_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Indication::set_has_participant_speak_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Indication::clear_has_participant_speak_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Indication::clear_participant_speak_request() {
  if (participant_speak_request_ != NULL) participant_speak_request_->::app::dispatch::ParticipantSpeakRequestNotification::Clear();
  clear_has_participant_speak_request();
}
inline const ::app::dispatch::ParticipantSpeakRequestNotification& Indication::participant_speak_request() const {
  return participant_speak_request_ != NULL ? *participant_speak_request_ : *default_instance_->participant_speak_request_;
}
inline ::app::dispatch::ParticipantSpeakRequestNotification* Indication::mutable_participant_speak_request() {
  set_has_participant_speak_request();
  if (participant_speak_request_ == NULL) participant_speak_request_ = new ::app::dispatch::ParticipantSpeakRequestNotification;
  return participant_speak_request_;
}
inline ::app::dispatch::ParticipantSpeakRequestNotification* Indication::release_participant_speak_request() {
  clear_has_participant_speak_request();
  ::app::dispatch::ParticipantSpeakRequestNotification* temp = participant_speak_request_;
  participant_speak_request_ = NULL;
  return temp;
}
inline void Indication::set_allocated_participant_speak_request(::app::dispatch::ParticipantSpeakRequestNotification* participant_speak_request) {
  delete participant_speak_request_;
  participant_speak_request_ = participant_speak_request;
  if (participant_speak_request) {
    set_has_participant_speak_request();
  } else {
    clear_has_participant_speak_request();
  }
}

// optional .app.dispatch.SessionStatusNotification session_status = 9;
inline bool Indication::has_session_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Indication::set_has_session_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Indication::clear_has_session_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Indication::clear_session_status() {
  if (session_status_ != NULL) session_status_->::app::dispatch::SessionStatusNotification::Clear();
  clear_has_session_status();
}
inline const ::app::dispatch::SessionStatusNotification& Indication::session_status() const {
  return session_status_ != NULL ? *session_status_ : *default_instance_->session_status_;
}
inline ::app::dispatch::SessionStatusNotification* Indication::mutable_session_status() {
  set_has_session_status();
  if (session_status_ == NULL) session_status_ = new ::app::dispatch::SessionStatusNotification;
  return session_status_;
}
inline ::app::dispatch::SessionStatusNotification* Indication::release_session_status() {
  clear_has_session_status();
  ::app::dispatch::SessionStatusNotification* temp = session_status_;
  session_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_session_status(::app::dispatch::SessionStatusNotification* session_status) {
  delete session_status_;
  session_status_ = session_status;
  if (session_status) {
    set_has_session_status();
  } else {
    clear_has_session_status();
  }
}

// optional .app.dispatch.RecordStatusNotification record_status = 10;
inline bool Indication::has_record_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Indication::set_has_record_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Indication::clear_has_record_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Indication::clear_record_status() {
  if (record_status_ != NULL) record_status_->::app::dispatch::RecordStatusNotification::Clear();
  clear_has_record_status();
}
inline const ::app::dispatch::RecordStatusNotification& Indication::record_status() const {
  return record_status_ != NULL ? *record_status_ : *default_instance_->record_status_;
}
inline ::app::dispatch::RecordStatusNotification* Indication::mutable_record_status() {
  set_has_record_status();
  if (record_status_ == NULL) record_status_ = new ::app::dispatch::RecordStatusNotification;
  return record_status_;
}
inline ::app::dispatch::RecordStatusNotification* Indication::release_record_status() {
  clear_has_record_status();
  ::app::dispatch::RecordStatusNotification* temp = record_status_;
  record_status_ = NULL;
  return temp;
}
inline void Indication::set_allocated_record_status(::app::dispatch::RecordStatusNotification* record_status) {
  delete record_status_;
  record_status_ = record_status;
  if (record_status) {
    set_has_record_status();
  } else {
    clear_has_record_status();
  }
}

// optional .app.dispatch.AccountLocationNotification account_location = 11;
inline bool Indication::has_account_location() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Indication::set_has_account_location() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Indication::clear_has_account_location() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Indication::clear_account_location() {
  if (account_location_ != NULL) account_location_->::app::dispatch::AccountLocationNotification::Clear();
  clear_has_account_location();
}
inline const ::app::dispatch::AccountLocationNotification& Indication::account_location() const {
  return account_location_ != NULL ? *account_location_ : *default_instance_->account_location_;
}
inline ::app::dispatch::AccountLocationNotification* Indication::mutable_account_location() {
  set_has_account_location();
  if (account_location_ == NULL) account_location_ = new ::app::dispatch::AccountLocationNotification;
  return account_location_;
}
inline ::app::dispatch::AccountLocationNotification* Indication::release_account_location() {
  clear_has_account_location();
  ::app::dispatch::AccountLocationNotification* temp = account_location_;
  account_location_ = NULL;
  return temp;
}
inline void Indication::set_allocated_account_location(::app::dispatch::AccountLocationNotification* account_location) {
  delete account_location_;
  account_location_ = account_location;
  if (account_location) {
    set_has_account_location();
  } else {
    clear_has_account_location();
  }
}

// optional .app.dispatch.AlertOveredNotification alert_overed = 12;
inline bool Indication::has_alert_overed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Indication::set_has_alert_overed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Indication::clear_has_alert_overed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Indication::clear_alert_overed() {
  if (alert_overed_ != NULL) alert_overed_->::app::dispatch::AlertOveredNotification::Clear();
  clear_has_alert_overed();
}
inline const ::app::dispatch::AlertOveredNotification& Indication::alert_overed() const {
  return alert_overed_ != NULL ? *alert_overed_ : *default_instance_->alert_overed_;
}
inline ::app::dispatch::AlertOveredNotification* Indication::mutable_alert_overed() {
  set_has_alert_overed();
  if (alert_overed_ == NULL) alert_overed_ = new ::app::dispatch::AlertOveredNotification;
  return alert_overed_;
}
inline ::app::dispatch::AlertOveredNotification* Indication::release_alert_overed() {
  clear_has_alert_overed();
  ::app::dispatch::AlertOveredNotification* temp = alert_overed_;
  alert_overed_ = NULL;
  return temp;
}
inline void Indication::set_allocated_alert_overed(::app::dispatch::AlertOveredNotification* alert_overed) {
  delete alert_overed_;
  alert_overed_ = alert_overed;
  if (alert_overed) {
    set_has_alert_overed();
  } else {
    clear_has_alert_overed();
  }
}

// -------------------------------------------------------------------

// Message

// required .app.dispatch.MSG msg_type = 1;
inline bool Message::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msg_type() {
  msg_type_ = 200001;
  clear_has_msg_type();
}
inline ::app::dispatch::MSG Message::msg_type() const {
  return static_cast< ::app::dispatch::MSG >(msg_type_);
}
inline void Message::set_msg_type(::app::dispatch::MSG value) {
  assert(::app::dispatch::MSG_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// required fixed32 sequence = 2;
inline bool Message::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Message::sequence() const {
  return sequence_;
}
inline void Message::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional fixed32 session_id = 3;
inline bool Message::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Message::session_id() const {
  return session_id_;
}
inline void Message::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .app.dispatch.Request request = 4;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::app::dispatch::Request::Clear();
  clear_has_request();
}
inline const ::app::dispatch::Request& Message::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::app::dispatch::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::app::dispatch::Request;
  return request_;
}
inline ::app::dispatch::Request* Message::release_request() {
  clear_has_request();
  ::app::dispatch::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Message::set_allocated_request(::app::dispatch::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .app.dispatch.Response response = 5;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::app::dispatch::Response::Clear();
  clear_has_response();
}
inline const ::app::dispatch::Response& Message::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::app::dispatch::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::app::dispatch::Response;
  return response_;
}
inline ::app::dispatch::Response* Message::release_response() {
  clear_has_response();
  ::app::dispatch::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::app::dispatch::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .app.dispatch.Indication indication = 6;
inline bool Message::has_indication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_indication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_indication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_indication() {
  if (indication_ != NULL) indication_->::app::dispatch::Indication::Clear();
  clear_has_indication();
}
inline const ::app::dispatch::Indication& Message::indication() const {
  return indication_ != NULL ? *indication_ : *default_instance_->indication_;
}
inline ::app::dispatch::Indication* Message::mutable_indication() {
  set_has_indication();
  if (indication_ == NULL) indication_ = new ::app::dispatch::Indication;
  return indication_;
}
inline ::app::dispatch::Indication* Message::release_indication() {
  clear_has_indication();
  ::app::dispatch::Indication* temp = indication_;
  indication_ = NULL;
  return temp;
}
inline void Message::set_allocated_indication(::app::dispatch::Indication* indication) {
  delete indication_;
  indication_ = indication;
  if (indication) {
    set_has_indication();
  } else {
    clear_has_indication();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dispatch
}  // namespace app

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::dispatch::MSG>() {
  return ::app::dispatch::MSG_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_app_2edispatch_2eproto__INCLUDED
