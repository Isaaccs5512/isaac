// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AppData.proto

#ifndef PROTOBUF_AppData_2eproto__INCLUDED
#define PROTOBUF_AppData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pbmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AppData_2eproto();
void protobuf_AssignDesc_AppData_2eproto();
void protobuf_ShutdownFile_AppData_2eproto();

class Address;
class Entity;
class Unit;
class Account;
class User;
class Organization;
class Participant;
class Group;
class Alert;
class Gateway;

enum AlertStatus {
  AlertActive = 0,
  AlertOver = 1
};
bool AlertStatus_IsValid(int value);
const AlertStatus AlertStatus_MIN = AlertActive;
const AlertStatus AlertStatus_MAX = AlertOver;
const int AlertStatus_ARRAYSIZE = AlertStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlertStatus_descriptor();
inline const ::std::string& AlertStatus_Name(AlertStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlertStatus_descriptor(), value);
}
inline bool AlertStatus_Parse(
    const ::std::string& name, AlertStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlertStatus>(
    AlertStatus_descriptor(), name, value);
}
enum AlertLevel {
  Exigency = 0,
  Importance = 1,
  Subordination = 2,
  Ordinary = 3
};
bool AlertLevel_IsValid(int value);
const AlertLevel AlertLevel_MIN = Exigency;
const AlertLevel AlertLevel_MAX = Ordinary;
const int AlertLevel_ARRAYSIZE = AlertLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlertLevel_descriptor();
inline const ::std::string& AlertLevel_Name(AlertLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlertLevel_descriptor(), value);
}
inline bool AlertLevel_Parse(
    const ::std::string& name, AlertLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlertLevel>(
    AlertLevel_descriptor(), name, value);
}
enum SessionStatus {
  IDLE = 0,
  InGroup = 1,
  Talking = 2
};
bool SessionStatus_IsValid(int value);
const SessionStatus SessionStatus_MIN = IDLE;
const SessionStatus SessionStatus_MAX = Talking;
const int SessionStatus_ARRAYSIZE = SessionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionStatus_descriptor();
inline const ::std::string& SessionStatus_Name(SessionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionStatus_descriptor(), value);
}
inline bool SessionStatus_Parse(
    const ::std::string& name, SessionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionStatus>(
    SessionStatus_descriptor(), name, value);
}
enum RecordType {
  DontRecord = 0,
  AutoRecord = 1,
  ManualRecord = 2
};
bool RecordType_IsValid(int value);
const RecordType RecordType_MIN = DontRecord;
const RecordType RecordType_MAX = ManualRecord;
const int RecordType_ARRAYSIZE = RecordType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordType_descriptor();
inline const ::std::string& RecordType_Name(RecordType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordType_descriptor(), value);
}
inline bool RecordType_Parse(
    const ::std::string& name, RecordType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordType>(
    RecordType_descriptor(), name, value);
}
enum AccountServiceStatus {
  AccountStop = 0,
  AccountActive = 1
};
bool AccountServiceStatus_IsValid(int value);
const AccountServiceStatus AccountServiceStatus_MIN = AccountStop;
const AccountServiceStatus AccountServiceStatus_MAX = AccountActive;
const int AccountServiceStatus_ARRAYSIZE = AccountServiceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountServiceStatus_descriptor();
inline const ::std::string& AccountServiceStatus_Name(AccountServiceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountServiceStatus_descriptor(), value);
}
inline bool AccountServiceStatus_Parse(
    const ::std::string& name, AccountServiceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountServiceStatus>(
    AccountServiceStatus_descriptor(), name, value);
}
enum CallPrivilege {
  CallForbid = 0,
  CallFreedom = 1,
  CallPolicy = 2
};
bool CallPrivilege_IsValid(int value);
const CallPrivilege CallPrivilege_MIN = CallForbid;
const CallPrivilege CallPrivilege_MAX = CallPolicy;
const int CallPrivilege_ARRAYSIZE = CallPrivilege_MAX + 1;

const ::google::protobuf::EnumDescriptor* CallPrivilege_descriptor();
inline const ::std::string& CallPrivilege_Name(CallPrivilege value) {
  return ::google::protobuf::internal::NameOfEnum(
    CallPrivilege_descriptor(), value);
}
inline bool CallPrivilege_Parse(
    const ::std::string& name, CallPrivilege* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CallPrivilege>(
    CallPrivilege_descriptor(), name, value);
}
enum CustomStatus {
  Standby = 0,
  Duty = 1,
  Turnout = 2,
  Training = 3
};
bool CustomStatus_IsValid(int value);
const CustomStatus CustomStatus_MIN = Standby;
const CustomStatus CustomStatus_MAX = Training;
const int CustomStatus_ARRAYSIZE = CustomStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustomStatus_descriptor();
inline const ::std::string& CustomStatus_Name(CustomStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustomStatus_descriptor(), value);
}
inline bool CustomStatus_Parse(
    const ::std::string& name, CustomStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustomStatus>(
    CustomStatus_descriptor(), name, value);
}
enum RegisterStatus {
  OffLine = 0,
  OnLine = 1
};
bool RegisterStatus_IsValid(int value);
const RegisterStatus RegisterStatus_MIN = OffLine;
const RegisterStatus RegisterStatus_MAX = OnLine;
const int RegisterStatus_ARRAYSIZE = RegisterStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterStatus_descriptor();
inline const ::std::string& RegisterStatus_Name(RegisterStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterStatus_descriptor(), value);
}
inline bool RegisterStatus_Parse(
    const ::std::string& name, RegisterStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterStatus>(
    RegisterStatus_descriptor(), name, value);
}
enum EntityType {
  UNIT = 0,
  ACCOUNT = 1,
  USER = 2,
  GROUP = 3,
  GATEWAY = 4,
  ORGANIZATION = 5,
  ALERT = 6,
  HISTORY_ALERT = 7
};
bool EntityType_IsValid(int value);
const EntityType EntityType_MIN = UNIT;
const EntityType EntityType_MAX = HISTORY_ALERT;
const int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityType_descriptor();
inline const ::std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityType_descriptor(), value);
}
inline bool EntityType_Parse(
    const ::std::string& name, EntityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum UserType {
  Admin = 0,
  Operator = 1
};
bool UserType_IsValid(int value);
const UserType UserType_MIN = Admin;
const UserType UserType_MAX = Operator;
const int UserType_ARRAYSIZE = UserType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserType_descriptor();
inline const ::std::string& UserType_Name(UserType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserType_descriptor(), value);
}
inline bool UserType_Parse(
    const ::std::string& name, UserType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserType>(
    UserType_descriptor(), name, value);
}
enum MessageType {
  Text = 0,
  Picture = 1,
  TextPictureMix = 2
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = Text;
const MessageType MessageType_MAX = TextPictureMix;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum TokenPrivilege {
  TokenForbid = 0,
  TokenFreedom = 1,
  TokenPolicy = 2
};
bool TokenPrivilege_IsValid(int value);
const TokenPrivilege TokenPrivilege_MIN = TokenForbid;
const TokenPrivilege TokenPrivilege_MAX = TokenPolicy;
const int TokenPrivilege_ARRAYSIZE = TokenPrivilege_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenPrivilege_descriptor();
inline const ::std::string& TokenPrivilege_Name(TokenPrivilege value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenPrivilege_descriptor(), value);
}
inline bool TokenPrivilege_Parse(
    const ::std::string& name, TokenPrivilege* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenPrivilege>(
    TokenPrivilege_descriptor(), name, value);
}
enum AccountType {
  Dispatcher = 0,
  Terminal = 1,
  Record = 2,
  MediaGateway = 3
};
bool AccountType_IsValid(int value);
const AccountType AccountType_MIN = Dispatcher;
const AccountType AccountType_MAX = MediaGateway;
const int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountType_descriptor();
inline const ::std::string& AccountType_Name(AccountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountType_descriptor(), value);
}
inline bool AccountType_Parse(
    const ::std::string& name, AccountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
enum GpsReportMode {
  GpsManualPull = 0,
  GpsManualPush = 1,
  GpsAutoPush = 2
};
bool GpsReportMode_IsValid(int value);
const GpsReportMode GpsReportMode_MIN = GpsManualPull;
const GpsReportMode GpsReportMode_MAX = GpsAutoPush;
const int GpsReportMode_ARRAYSIZE = GpsReportMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpsReportMode_descriptor();
inline const ::std::string& GpsReportMode_Name(GpsReportMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpsReportMode_descriptor(), value);
}
inline bool GpsReportMode_Parse(
    const ::std::string& name, GpsReportMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpsReportMode>(
    GpsReportMode_descriptor(), name, value);
}
enum RecordStatus {
  RecordStop = 0,
  RecordStart = 1
};
bool RecordStatus_IsValid(int value);
const RecordStatus RecordStatus_MIN = RecordStop;
const RecordStatus RecordStatus_MAX = RecordStart;
const int RecordStatus_ARRAYSIZE = RecordStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordStatus_descriptor();
inline const ::std::string& RecordStatus_Name(RecordStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordStatus_descriptor(), value);
}
inline bool RecordStatus_Parse(
    const ::std::string& name, RecordStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordStatus>(
    RecordStatus_descriptor(), name, value);
}
// ===================================================================

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional fixed32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pbmsg.Address)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pbmsg.EntityType entity_type = 3;
  inline bool has_entity_type() const;
  inline void clear_entity_type();
  static const int kEntityTypeFieldNumber = 3;
  inline ::pbmsg::EntityType entity_type() const;
  inline void set_entity_type(::pbmsg::EntityType value);

  // optional .pbmsg.Entity parent = 4;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 4;
  inline const ::pbmsg::Entity& parent() const;
  inline ::pbmsg::Entity* mutable_parent();
  inline ::pbmsg::Entity* release_parent();
  inline void set_allocated_parent(::pbmsg::Entity* parent);

  // @@protoc_insertion_point(class_scope:pbmsg.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_entity_type();
  inline void clear_has_entity_type();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  int entity_type_;
  ::pbmsg::Entity* parent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class Unit : public ::google::protobuf::Message {
 public:
  Unit();
  virtual ~Unit();

  Unit(const Unit& from);

  inline Unit& operator=(const Unit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unit& default_instance();

  void Swap(Unit* other);

  // implements Message ----------------------------------------------

  Unit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Unit& from);
  void MergeFrom(const Unit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional bool include_members = 2;
  inline bool has_include_members() const;
  inline void clear_include_members();
  static const int kIncludeMembersFieldNumber = 2;
  inline bool include_members() const;
  inline void set_include_members(bool value);

  // repeated .pbmsg.Entity members = 3;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 3;
  inline const ::pbmsg::Entity& members(int index) const;
  inline ::pbmsg::Entity* mutable_members(int index);
  inline ::pbmsg::Entity* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:pbmsg.Unit)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_include_members();
  inline void clear_has_include_members();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > members_;
  bool include_members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Unit* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional .pbmsg.AccountType account_type = 2;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 2;
  inline ::pbmsg::AccountType account_type() const;
  inline void set_account_type(::pbmsg::AccountType value);

  // optional bytes number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const void* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional bytes short_number = 4;
  inline bool has_short_number() const;
  inline void clear_short_number();
  static const int kShortNumberFieldNumber = 4;
  inline const ::std::string& short_number() const;
  inline void set_short_number(const ::std::string& value);
  inline void set_short_number(const char* value);
  inline void set_short_number(const void* value, size_t size);
  inline ::std::string* mutable_short_number();
  inline ::std::string* release_short_number();
  inline void set_allocated_short_number(::std::string* short_number);

  // optional bytes password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .pbmsg.AccountServiceStatus service_status = 6;
  inline bool has_service_status() const;
  inline void clear_service_status();
  static const int kServiceStatusFieldNumber = 6;
  inline ::pbmsg::AccountServiceStatus service_status() const;
  inline void set_service_status(::pbmsg::AccountServiceStatus value);

  // optional fixed32 priority = 7;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 7;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional .pbmsg.CallPrivilege call_privilege = 8;
  inline bool has_call_privilege() const;
  inline void clear_call_privilege();
  static const int kCallPrivilegeFieldNumber = 8;
  inline ::pbmsg::CallPrivilege call_privilege() const;
  inline void set_call_privilege(::pbmsg::CallPrivilege value);

  // optional .pbmsg.TokenPrivilege token_privilege = 9;
  inline bool has_token_privilege() const;
  inline void clear_token_privilege();
  static const int kTokenPrivilegeFieldNumber = 9;
  inline ::pbmsg::TokenPrivilege token_privilege() const;
  inline void set_token_privilege(::pbmsg::TokenPrivilege value);

  // optional .pbmsg.GpsReportMode gps_report_mode = 10;
  inline bool has_gps_report_mode() const;
  inline void clear_gps_report_mode();
  static const int kGpsReportModeFieldNumber = 10;
  inline ::pbmsg::GpsReportMode gps_report_mode() const;
  inline void set_gps_report_mode(::pbmsg::GpsReportMode value);

  // optional fixed32 ttl = 11;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 11;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // optional fixed32 gps_ttl = 12;
  inline bool has_gps_ttl() const;
  inline void clear_gps_ttl();
  static const int kGpsTtlFieldNumber = 12;
  inline ::google::protobuf::uint32 gps_ttl() const;
  inline void set_gps_ttl(::google::protobuf::uint32 value);

  // optional .pbmsg.RegisterStatus status = 13;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 13;
  inline ::pbmsg::RegisterStatus status() const;
  inline void set_status(::pbmsg::RegisterStatus value);

  // optional .pbmsg.RegisterStatus sip_status = 14;
  inline bool has_sip_status() const;
  inline void clear_sip_status();
  static const int kSipStatusFieldNumber = 14;
  inline ::pbmsg::RegisterStatus sip_status() const;
  inline void set_sip_status(::pbmsg::RegisterStatus value);

  // optional .pbmsg.Address address = 15;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 15;
  inline const ::pbmsg::Address& address() const;
  inline ::pbmsg::Address* mutable_address();
  inline ::pbmsg::Address* release_address();
  inline void set_allocated_address(::pbmsg::Address* address);

  // optional bool binding = 16;
  inline bool has_binding() const;
  inline void clear_binding();
  static const int kBindingFieldNumber = 16;
  inline bool binding() const;
  inline void set_binding(bool value);

  // optional bool subscribing = 17;
  inline bool has_subscribing() const;
  inline void clear_subscribing();
  static const int kSubscribingFieldNumber = 17;
  inline bool subscribing() const;
  inline void set_subscribing(bool value);

  // optional double latitude = 18;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 18;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional double longitude = 19;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 19;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional bytes timestamp = 20;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 20;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const void* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional bool participant_subscribing = 21;
  inline bool has_participant_subscribing() const;
  inline void clear_participant_subscribing();
  static const int kParticipantSubscribingFieldNumber = 21;
  inline bool participant_subscribing() const;
  inline void set_participant_subscribing(bool value);

  // optional bool message_subscribing = 22;
  inline bool has_message_subscribing() const;
  inline void clear_message_subscribing();
  static const int kMessageSubscribingFieldNumber = 22;
  inline bool message_subscribing() const;
  inline void set_message_subscribing(bool value);

  // optional .pbmsg.CustomStatus custom_status = 23;
  inline bool has_custom_status() const;
  inline void clear_custom_status();
  static const int kCustomStatusFieldNumber = 23;
  inline ::pbmsg::CustomStatus custom_status() const;
  inline void set_custom_status(::pbmsg::CustomStatus value);

  // @@protoc_insertion_point(class_scope:pbmsg.Account)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_short_number();
  inline void clear_has_short_number();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_service_status();
  inline void clear_has_service_status();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_call_privilege();
  inline void clear_has_call_privilege();
  inline void set_has_token_privilege();
  inline void clear_has_token_privilege();
  inline void set_has_gps_report_mode();
  inline void clear_has_gps_report_mode();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_gps_ttl();
  inline void clear_has_gps_ttl();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sip_status();
  inline void clear_has_sip_status();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_binding();
  inline void clear_has_binding();
  inline void set_has_subscribing();
  inline void clear_has_subscribing();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_participant_subscribing();
  inline void clear_has_participant_subscribing();
  inline void set_has_message_subscribing();
  inline void clear_has_message_subscribing();
  inline void set_has_custom_status();
  inline void clear_has_custom_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::std::string* number_;
  ::std::string* short_number_;
  int account_type_;
  int service_status_;
  ::std::string* password_;
  ::google::protobuf::uint32 priority_;
  int call_privilege_;
  int token_privilege_;
  int gps_report_mode_;
  ::google::protobuf::uint32 ttl_;
  ::google::protobuf::uint32 gps_ttl_;
  int status_;
  int sip_status_;
  ::pbmsg::Address* address_;
  double latitude_;
  double longitude_;
  bool binding_;
  bool subscribing_;
  bool participant_subscribing_;
  bool message_subscribing_;
  int custom_status_;
  ::std::string* timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .pbmsg.UserType user_type = 3;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 3;
  inline ::pbmsg::UserType user_type() const;
  inline void set_user_type(::pbmsg::UserType value);

  // optional .pbmsg.Entity account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::pbmsg::Entity& account() const;
  inline ::pbmsg::Entity* mutable_account();
  inline ::pbmsg::Entity* release_account();
  inline void set_allocated_account(::pbmsg::Entity* account);

  // optional .pbmsg.RegisterStatus status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::pbmsg::RegisterStatus status() const;
  inline void set_status(::pbmsg::RegisterStatus value);

  // optional .pbmsg.Address address = 6;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 6;
  inline const ::pbmsg::Address& address() const;
  inline ::pbmsg::Address* mutable_address();
  inline ::pbmsg::Address* release_address();
  inline void set_allocated_address(::pbmsg::Address* address);

  // @@protoc_insertion_point(class_scope:pbmsg.User)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::std::string* password_;
  ::pbmsg::Entity* account_;
  int user_type_;
  int status_;
  ::pbmsg::Address* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Organization : public ::google::protobuf::Message {
 public:
  Organization();
  virtual ~Organization();

  Organization(const Organization& from);

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Organization& default_instance();

  void Swap(Organization* other);

  // implements Message ----------------------------------------------

  Organization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Organization& from);
  void MergeFrom(const Organization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional bool include_members = 2;
  inline bool has_include_members() const;
  inline void clear_include_members();
  static const int kIncludeMembersFieldNumber = 2;
  inline bool include_members() const;
  inline void set_include_members(bool value);

  // repeated .pbmsg.Entity members = 3;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 3;
  inline const ::pbmsg::Entity& members(int index) const;
  inline ::pbmsg::Entity* mutable_members(int index);
  inline ::pbmsg::Entity* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:pbmsg.Organization)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_include_members();
  inline void clear_has_include_members();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > members_;
  bool include_members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Organization* default_instance_;
};
// -------------------------------------------------------------------

class Participant : public ::google::protobuf::Message {
 public:
  Participant();
  virtual ~Participant();

  Participant(const Participant& from);

  inline Participant& operator=(const Participant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Participant& default_instance();

  void Swap(Participant* other);

  // implements Message ----------------------------------------------

  Participant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Participant& from);
  void MergeFrom(const Participant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .pbmsg.Entity group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::pbmsg::Entity& group() const;
  inline ::pbmsg::Entity* mutable_group();
  inline ::pbmsg::Entity* release_group();
  inline void set_allocated_group(::pbmsg::Entity* group);

  // optional .pbmsg.Entity account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::pbmsg::Entity& account() const;
  inline ::pbmsg::Entity* mutable_account();
  inline ::pbmsg::Entity* release_account();
  inline void set_allocated_account(::pbmsg::Entity* account);

  // optional fixed32 priority = 4;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 4;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional .pbmsg.CallPrivilege call_privilege = 5;
  inline bool has_call_privilege() const;
  inline void clear_call_privilege();
  static const int kCallPrivilegeFieldNumber = 5;
  inline ::pbmsg::CallPrivilege call_privilege() const;
  inline void set_call_privilege(::pbmsg::CallPrivilege value);

  // optional .pbmsg.TokenPrivilege token_privilege = 6;
  inline bool has_token_privilege() const;
  inline void clear_token_privilege();
  static const int kTokenPrivilegeFieldNumber = 6;
  inline ::pbmsg::TokenPrivilege token_privilege() const;
  inline void set_token_privilege(::pbmsg::TokenPrivilege value);

  // optional bytes join_timestamp = 7;
  inline bool has_join_timestamp() const;
  inline void clear_join_timestamp();
  static const int kJoinTimestampFieldNumber = 7;
  inline const ::std::string& join_timestamp() const;
  inline void set_join_timestamp(const ::std::string& value);
  inline void set_join_timestamp(const char* value);
  inline void set_join_timestamp(const void* value, size_t size);
  inline ::std::string* mutable_join_timestamp();
  inline ::std::string* release_join_timestamp();
  inline void set_allocated_join_timestamp(::std::string* join_timestamp);

  // optional .pbmsg.SessionStatus status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::pbmsg::SessionStatus status() const;
  inline void set_status(::pbmsg::SessionStatus value);

  // optional bool participant_subscribing = 9;
  inline bool has_participant_subscribing() const;
  inline void clear_participant_subscribing();
  static const int kParticipantSubscribingFieldNumber = 9;
  inline bool participant_subscribing() const;
  inline void set_participant_subscribing(bool value);

  // optional bool message_subscribing = 10;
  inline bool has_message_subscribing() const;
  inline void clear_message_subscribing();
  static const int kMessageSubscribingFieldNumber = 10;
  inline bool message_subscribing() const;
  inline void set_message_subscribing(bool value);

  // @@protoc_insertion_point(class_scope:pbmsg.Participant)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_call_privilege();
  inline void clear_has_call_privilege();
  inline void set_has_token_privilege();
  inline void clear_has_token_privilege();
  inline void set_has_join_timestamp();
  inline void clear_has_join_timestamp();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_participant_subscribing();
  inline void clear_has_participant_subscribing();
  inline void set_has_message_subscribing();
  inline void clear_has_message_subscribing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* group_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 priority_;
  ::pbmsg::Entity* account_;
  int call_privilege_;
  int token_privilege_;
  ::std::string* join_timestamp_;
  int status_;
  bool participant_subscribing_;
  bool message_subscribing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Participant* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional .pbmsg.Entity owner = 2;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 2;
  inline const ::pbmsg::Entity& owner() const;
  inline ::pbmsg::Entity* mutable_owner();
  inline ::pbmsg::Entity* release_owner();
  inline void set_allocated_owner(::pbmsg::Entity* owner);

  // optional bytes number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const void* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional bytes short_number = 4;
  inline bool has_short_number() const;
  inline void clear_short_number();
  static const int kShortNumberFieldNumber = 4;
  inline const ::std::string& short_number() const;
  inline void set_short_number(const ::std::string& value);
  inline void set_short_number(const char* value);
  inline void set_short_number(const void* value, size_t size);
  inline ::std::string* mutable_short_number();
  inline ::std::string* release_short_number();
  inline void set_allocated_short_number(::std::string* short_number);

  // optional bool sealed = 5;
  inline bool has_sealed() const;
  inline void clear_sealed();
  static const int kSealedFieldNumber = 5;
  inline bool sealed() const;
  inline void set_sealed(bool value);

  // optional bool include_participants = 6;
  inline bool has_include_participants() const;
  inline void clear_include_participants();
  static const int kIncludeParticipantsFieldNumber = 6;
  inline bool include_participants() const;
  inline void set_include_participants(bool value);

  // repeated .pbmsg.Participant participants = 7;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 7;
  inline const ::pbmsg::Participant& participants(int index) const;
  inline ::pbmsg::Participant* mutable_participants(int index);
  inline ::pbmsg::Participant* add_participants();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
      participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
      mutable_participants();

  // optional .pbmsg.RecordType record_type = 8;
  inline bool has_record_type() const;
  inline void clear_record_type();
  static const int kRecordTypeFieldNumber = 8;
  inline ::pbmsg::RecordType record_type() const;
  inline void set_record_type(::pbmsg::RecordType value);

  // optional .pbmsg.Entity recorder = 9;
  inline bool has_recorder() const;
  inline void clear_recorder();
  static const int kRecorderFieldNumber = 9;
  inline const ::pbmsg::Entity& recorder() const;
  inline ::pbmsg::Entity* mutable_recorder();
  inline ::pbmsg::Entity* release_recorder();
  inline void set_allocated_recorder(::pbmsg::Entity* recorder);

  // optional .pbmsg.RecordStatus record_status = 10;
  inline bool has_record_status() const;
  inline void clear_record_status();
  static const int kRecordStatusFieldNumber = 10;
  inline ::pbmsg::RecordStatus record_status() const;
  inline void set_record_status(::pbmsg::RecordStatus value);

  // optional .pbmsg.Entity record_server = 11;
  inline bool has_record_server() const;
  inline void clear_record_server();
  static const int kRecordServerFieldNumber = 11;
  inline const ::pbmsg::Entity& record_server() const;
  inline ::pbmsg::Entity* mutable_record_server();
  inline ::pbmsg::Entity* release_record_server();
  inline void set_allocated_record_server(::pbmsg::Entity* record_server);

  // optional bool include_listen_users = 12;
  inline bool has_include_listen_users() const;
  inline void clear_include_listen_users();
  static const int kIncludeListenUsersFieldNumber = 12;
  inline bool include_listen_users() const;
  inline void set_include_listen_users(bool value);

  // repeated .pbmsg.Entity listen_users = 13;
  inline int listen_users_size() const;
  inline void clear_listen_users();
  static const int kListenUsersFieldNumber = 13;
  inline const ::pbmsg::Entity& listen_users(int index) const;
  inline ::pbmsg::Entity* mutable_listen_users(int index);
  inline ::pbmsg::Entity* add_listen_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      listen_users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_listen_users();

  // @@protoc_insertion_point(class_scope:pbmsg.Group)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_short_number();
  inline void clear_has_short_number();
  inline void set_has_sealed();
  inline void clear_has_sealed();
  inline void set_has_include_participants();
  inline void clear_has_include_participants();
  inline void set_has_record_type();
  inline void clear_has_record_type();
  inline void set_has_recorder();
  inline void clear_has_recorder();
  inline void set_has_record_status();
  inline void clear_has_record_status();
  inline void set_has_record_server();
  inline void clear_has_record_server();
  inline void set_has_include_listen_users();
  inline void clear_has_include_listen_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::pbmsg::Entity* owner_;
  ::std::string* number_;
  ::std::string* short_number_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant > participants_;
  bool sealed_;
  bool include_participants_;
  bool include_listen_users_;
  int record_type_;
  ::pbmsg::Entity* recorder_;
  ::pbmsg::Entity* record_server_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > listen_users_;
  int record_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::Message {
 public:
  Alert();
  virtual ~Alert();

  Alert(const Alert& from);

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alert& default_instance();

  void Swap(Alert* other);

  // implements Message ----------------------------------------------

  Alert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional .pbmsg.Entity group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::pbmsg::Entity& group() const;
  inline ::pbmsg::Entity* mutable_group();
  inline ::pbmsg::Entity* release_group();
  inline void set_allocated_group(::pbmsg::Entity* group);

  // optional bytes describe = 3;
  inline bool has_describe() const;
  inline void clear_describe();
  static const int kDescribeFieldNumber = 3;
  inline const ::std::string& describe() const;
  inline void set_describe(const ::std::string& value);
  inline void set_describe(const char* value);
  inline void set_describe(const void* value, size_t size);
  inline ::std::string* mutable_describe();
  inline ::std::string* release_describe();
  inline void set_allocated_describe(::std::string* describe);

  // optional .pbmsg.AlertLevel level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::pbmsg::AlertLevel level() const;
  inline void set_level(::pbmsg::AlertLevel value);

  // optional bytes alram_time = 5;
  inline bool has_alram_time() const;
  inline void clear_alram_time();
  static const int kAlramTimeFieldNumber = 5;
  inline const ::std::string& alram_time() const;
  inline void set_alram_time(const ::std::string& value);
  inline void set_alram_time(const char* value);
  inline void set_alram_time(const void* value, size_t size);
  inline ::std::string* mutable_alram_time();
  inline ::std::string* release_alram_time();
  inline void set_allocated_alram_time(::std::string* alram_time);

  // optional fixed32 use_cars = 6;
  inline bool has_use_cars() const;
  inline void clear_use_cars();
  static const int kUseCarsFieldNumber = 6;
  inline ::google::protobuf::uint32 use_cars() const;
  inline void set_use_cars(::google::protobuf::uint32 value);

  // optional bytes create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline const ::std::string& create_time() const;
  inline void set_create_time(const ::std::string& value);
  inline void set_create_time(const char* value);
  inline void set_create_time(const void* value, size_t size);
  inline ::std::string* mutable_create_time();
  inline ::std::string* release_create_time();
  inline void set_allocated_create_time(::std::string* create_time);

  // @@protoc_insertion_point(class_scope:pbmsg.Alert)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_describe();
  inline void clear_has_describe();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_alram_time();
  inline void clear_has_alram_time();
  inline void set_has_use_cars();
  inline void clear_has_use_cars();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::pbmsg::Entity* group_;
  ::std::string* describe_;
  ::std::string* alram_time_;
  int level_;
  ::google::protobuf::uint32 use_cars_;
  ::std::string* create_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Alert* default_instance_;
};
// -------------------------------------------------------------------

class Gateway : public ::google::protobuf::Message {
 public:
  Gateway();
  virtual ~Gateway();

  Gateway(const Gateway& from);

  inline Gateway& operator=(const Gateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gateway& default_instance();

  void Swap(Gateway* other);

  // implements Message ----------------------------------------------

  Gateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gateway& from);
  void MergeFrom(const Gateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::pbmsg::Entity& base() const;
  inline ::pbmsg::Entity* mutable_base();
  inline ::pbmsg::Entity* release_base();
  inline void set_allocated_base(::pbmsg::Entity* base);

  // optional .pbmsg.Address address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::pbmsg::Address& address() const;
  inline ::pbmsg::Address* mutable_address();
  inline ::pbmsg::Address* release_address();
  inline void set_allocated_address(::pbmsg::Address* address);

  // optional bool include_allocate_counts = 3;
  inline bool has_include_allocate_counts() const;
  inline void clear_include_allocate_counts();
  static const int kIncludeAllocateCountsFieldNumber = 3;
  inline bool include_allocate_counts() const;
  inline void set_include_allocate_counts(bool value);

  // repeated .pbmsg.Entity allocate_counts = 4;
  inline int allocate_counts_size() const;
  inline void clear_allocate_counts();
  static const int kAllocateCountsFieldNumber = 4;
  inline const ::pbmsg::Entity& allocate_counts(int index) const;
  inline ::pbmsg::Entity* mutable_allocate_counts(int index);
  inline ::pbmsg::Entity* add_allocate_counts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      allocate_counts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_allocate_counts();

  // optional bool include_active_counts = 5;
  inline bool has_include_active_counts() const;
  inline void clear_include_active_counts();
  static const int kIncludeActiveCountsFieldNumber = 5;
  inline bool include_active_counts() const;
  inline void set_include_active_counts(bool value);

  // repeated .pbmsg.Entity active_counts = 6;
  inline int active_counts_size() const;
  inline void clear_active_counts();
  static const int kActiveCountsFieldNumber = 6;
  inline const ::pbmsg::Entity& active_counts(int index) const;
  inline ::pbmsg::Entity* mutable_active_counts(int index);
  inline ::pbmsg::Entity* add_active_counts();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      active_counts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_active_counts();

  // optional bool include_recordings = 7;
  inline bool has_include_recordings() const;
  inline void clear_include_recordings();
  static const int kIncludeRecordingsFieldNumber = 7;
  inline bool include_recordings() const;
  inline void set_include_recordings(bool value);

  // repeated .pbmsg.Entity recordings = 8;
  inline int recordings_size() const;
  inline void clear_recordings();
  static const int kRecordingsFieldNumber = 8;
  inline const ::pbmsg::Entity& recordings(int index) const;
  inline ::pbmsg::Entity* mutable_recordings(int index);
  inline ::pbmsg::Entity* add_recordings();
  inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
      recordings() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
      mutable_recordings();

  // optional .pbmsg.RegisterStatus status = 9;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 9;
  inline ::pbmsg::RegisterStatus status() const;
  inline void set_status(::pbmsg::RegisterStatus value);

  // @@protoc_insertion_point(class_scope:pbmsg.Gateway)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_include_allocate_counts();
  inline void clear_has_include_allocate_counts();
  inline void set_has_include_active_counts();
  inline void clear_has_include_active_counts();
  inline void set_has_include_recordings();
  inline void clear_has_include_recordings();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* base_;
  ::pbmsg::Address* address_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > allocate_counts_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > active_counts_;
  bool include_allocate_counts_;
  bool include_active_counts_;
  bool include_recordings_;
  int status_;
  ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity > recordings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_AppData_2eproto();
  friend void protobuf_AssignDesc_AppData_2eproto();
  friend void protobuf_ShutdownFile_AppData_2eproto();

  void InitAsDefaultInstance();
  static Gateway* default_instance_;
};
// ===================================================================


// ===================================================================

// Address

// optional bytes ip = 1;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Address::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 port = 2;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 Address::port() const {
  return port_;
}
inline void Address::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Entity

// optional fixed32 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Entity::id() const {
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes name = 2;
inline bool Entity::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Entity::name() const {
  return *name_;
}
inline void Entity::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Entity::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Entity::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Entity::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entity::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pbmsg.EntityType entity_type = 3;
inline bool Entity::has_entity_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_entity_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_entity_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_entity_type() {
  entity_type_ = 0;
  clear_has_entity_type();
}
inline ::pbmsg::EntityType Entity::entity_type() const {
  return static_cast< ::pbmsg::EntityType >(entity_type_);
}
inline void Entity::set_entity_type(::pbmsg::EntityType value) {
  assert(::pbmsg::EntityType_IsValid(value));
  set_has_entity_type();
  entity_type_ = value;
}

// optional .pbmsg.Entity parent = 4;
inline bool Entity::has_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_parent() {
  if (parent_ != NULL) parent_->::pbmsg::Entity::Clear();
  clear_has_parent();
}
inline const ::pbmsg::Entity& Entity::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::pbmsg::Entity* Entity::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::pbmsg::Entity;
  return parent_;
}
inline ::pbmsg::Entity* Entity::release_parent() {
  clear_has_parent();
  ::pbmsg::Entity* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Entity::set_allocated_parent(::pbmsg::Entity* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
}

// -------------------------------------------------------------------

// Unit

// required .pbmsg.Entity base = 1;
inline bool Unit::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unit::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unit::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Unit::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Unit::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Unit::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Unit::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Unit::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional bool include_members = 2;
inline bool Unit::has_include_members() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Unit::set_has_include_members() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Unit::clear_has_include_members() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Unit::clear_include_members() {
  include_members_ = false;
  clear_has_include_members();
}
inline bool Unit::include_members() const {
  return include_members_;
}
inline void Unit::set_include_members(bool value) {
  set_has_include_members();
  include_members_ = value;
}

// repeated .pbmsg.Entity members = 3;
inline int Unit::members_size() const {
  return members_.size();
}
inline void Unit::clear_members() {
  members_.Clear();
}
inline const ::pbmsg::Entity& Unit::members(int index) const {
  return members_.Get(index);
}
inline ::pbmsg::Entity* Unit::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pbmsg::Entity* Unit::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Unit::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Unit::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// Account

// required .pbmsg.Entity base = 1;
inline bool Account::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Account::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Account::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Account::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Account::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .pbmsg.AccountType account_type = 2;
inline bool Account::has_account_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_account_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_account_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::pbmsg::AccountType Account::account_type() const {
  return static_cast< ::pbmsg::AccountType >(account_type_);
}
inline void Account::set_account_type(::pbmsg::AccountType value) {
  assert(::pbmsg::AccountType_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional bytes number = 3;
inline bool Account::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& Account::number() const {
  return *number_;
}
inline void Account::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Account::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Account::set_number(const void* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* Account::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes short_number = 4;
inline bool Account::has_short_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_short_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_short_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_short_number() {
  if (short_number_ != &::google::protobuf::internal::kEmptyString) {
    short_number_->clear();
  }
  clear_has_short_number();
}
inline const ::std::string& Account::short_number() const {
  return *short_number_;
}
inline void Account::set_short_number(const ::std::string& value) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(value);
}
inline void Account::set_short_number(const char* value) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(value);
}
inline void Account::set_short_number(const void* value, size_t size) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_short_number() {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  return short_number_;
}
inline ::std::string* Account::release_short_number() {
  clear_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_number_;
    short_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_short_number(::std::string* short_number) {
  if (short_number_ != &::google::protobuf::internal::kEmptyString) {
    delete short_number_;
  }
  if (short_number) {
    set_has_short_number();
    short_number_ = short_number;
  } else {
    clear_has_short_number();
    short_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes password = 5;
inline bool Account::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Account::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Account::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Account::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Account::password() const {
  return *password_;
}
inline void Account::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Account::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Account::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Account::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pbmsg.AccountServiceStatus service_status = 6;
inline bool Account::has_service_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Account::set_has_service_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Account::clear_has_service_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Account::clear_service_status() {
  service_status_ = 0;
  clear_has_service_status();
}
inline ::pbmsg::AccountServiceStatus Account::service_status() const {
  return static_cast< ::pbmsg::AccountServiceStatus >(service_status_);
}
inline void Account::set_service_status(::pbmsg::AccountServiceStatus value) {
  assert(::pbmsg::AccountServiceStatus_IsValid(value));
  set_has_service_status();
  service_status_ = value;
}

// optional fixed32 priority = 7;
inline bool Account::has_priority() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Account::set_has_priority() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Account::clear_has_priority() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Account::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 Account::priority() const {
  return priority_;
}
inline void Account::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional .pbmsg.CallPrivilege call_privilege = 8;
inline bool Account::has_call_privilege() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Account::set_has_call_privilege() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Account::clear_has_call_privilege() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Account::clear_call_privilege() {
  call_privilege_ = 0;
  clear_has_call_privilege();
}
inline ::pbmsg::CallPrivilege Account::call_privilege() const {
  return static_cast< ::pbmsg::CallPrivilege >(call_privilege_);
}
inline void Account::set_call_privilege(::pbmsg::CallPrivilege value) {
  assert(::pbmsg::CallPrivilege_IsValid(value));
  set_has_call_privilege();
  call_privilege_ = value;
}

// optional .pbmsg.TokenPrivilege token_privilege = 9;
inline bool Account::has_token_privilege() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Account::set_has_token_privilege() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Account::clear_has_token_privilege() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Account::clear_token_privilege() {
  token_privilege_ = 0;
  clear_has_token_privilege();
}
inline ::pbmsg::TokenPrivilege Account::token_privilege() const {
  return static_cast< ::pbmsg::TokenPrivilege >(token_privilege_);
}
inline void Account::set_token_privilege(::pbmsg::TokenPrivilege value) {
  assert(::pbmsg::TokenPrivilege_IsValid(value));
  set_has_token_privilege();
  token_privilege_ = value;
}

// optional .pbmsg.GpsReportMode gps_report_mode = 10;
inline bool Account::has_gps_report_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Account::set_has_gps_report_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Account::clear_has_gps_report_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Account::clear_gps_report_mode() {
  gps_report_mode_ = 0;
  clear_has_gps_report_mode();
}
inline ::pbmsg::GpsReportMode Account::gps_report_mode() const {
  return static_cast< ::pbmsg::GpsReportMode >(gps_report_mode_);
}
inline void Account::set_gps_report_mode(::pbmsg::GpsReportMode value) {
  assert(::pbmsg::GpsReportMode_IsValid(value));
  set_has_gps_report_mode();
  gps_report_mode_ = value;
}

// optional fixed32 ttl = 11;
inline bool Account::has_ttl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Account::set_has_ttl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Account::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Account::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 Account::ttl() const {
  return ttl_;
}
inline void Account::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional fixed32 gps_ttl = 12;
inline bool Account::has_gps_ttl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Account::set_has_gps_ttl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Account::clear_has_gps_ttl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Account::clear_gps_ttl() {
  gps_ttl_ = 0u;
  clear_has_gps_ttl();
}
inline ::google::protobuf::uint32 Account::gps_ttl() const {
  return gps_ttl_;
}
inline void Account::set_gps_ttl(::google::protobuf::uint32 value) {
  set_has_gps_ttl();
  gps_ttl_ = value;
}

// optional .pbmsg.RegisterStatus status = 13;
inline bool Account::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Account::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Account::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Account::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::RegisterStatus Account::status() const {
  return static_cast< ::pbmsg::RegisterStatus >(status_);
}
inline void Account::set_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .pbmsg.RegisterStatus sip_status = 14;
inline bool Account::has_sip_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Account::set_has_sip_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Account::clear_has_sip_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Account::clear_sip_status() {
  sip_status_ = 0;
  clear_has_sip_status();
}
inline ::pbmsg::RegisterStatus Account::sip_status() const {
  return static_cast< ::pbmsg::RegisterStatus >(sip_status_);
}
inline void Account::set_sip_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_sip_status();
  sip_status_ = value;
}

// optional .pbmsg.Address address = 15;
inline bool Account::has_address() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Account::set_has_address() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Account::clear_has_address() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Account::clear_address() {
  if (address_ != NULL) address_->::pbmsg::Address::Clear();
  clear_has_address();
}
inline const ::pbmsg::Address& Account::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::pbmsg::Address* Account::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::pbmsg::Address;
  return address_;
}
inline ::pbmsg::Address* Account::release_address() {
  clear_has_address();
  ::pbmsg::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Account::set_allocated_address(::pbmsg::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// optional bool binding = 16;
inline bool Account::has_binding() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Account::set_has_binding() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Account::clear_has_binding() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Account::clear_binding() {
  binding_ = false;
  clear_has_binding();
}
inline bool Account::binding() const {
  return binding_;
}
inline void Account::set_binding(bool value) {
  set_has_binding();
  binding_ = value;
}

// optional bool subscribing = 17;
inline bool Account::has_subscribing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Account::set_has_subscribing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Account::clear_has_subscribing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Account::clear_subscribing() {
  subscribing_ = false;
  clear_has_subscribing();
}
inline bool Account::subscribing() const {
  return subscribing_;
}
inline void Account::set_subscribing(bool value) {
  set_has_subscribing();
  subscribing_ = value;
}

// optional double latitude = 18;
inline bool Account::has_latitude() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Account::set_has_latitude() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Account::clear_has_latitude() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Account::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Account::latitude() const {
  return latitude_;
}
inline void Account::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double longitude = 19;
inline bool Account::has_longitude() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Account::set_has_longitude() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Account::clear_has_longitude() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Account::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Account::longitude() const {
  return longitude_;
}
inline void Account::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional bytes timestamp = 20;
inline bool Account::has_timestamp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Account::set_has_timestamp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Account::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Account::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& Account::timestamp() const {
  return *timestamp_;
}
inline void Account::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Account::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Account::set_timestamp(const void* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* Account::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool participant_subscribing = 21;
inline bool Account::has_participant_subscribing() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Account::set_has_participant_subscribing() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Account::clear_has_participant_subscribing() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Account::clear_participant_subscribing() {
  participant_subscribing_ = false;
  clear_has_participant_subscribing();
}
inline bool Account::participant_subscribing() const {
  return participant_subscribing_;
}
inline void Account::set_participant_subscribing(bool value) {
  set_has_participant_subscribing();
  participant_subscribing_ = value;
}

// optional bool message_subscribing = 22;
inline bool Account::has_message_subscribing() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Account::set_has_message_subscribing() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Account::clear_has_message_subscribing() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Account::clear_message_subscribing() {
  message_subscribing_ = false;
  clear_has_message_subscribing();
}
inline bool Account::message_subscribing() const {
  return message_subscribing_;
}
inline void Account::set_message_subscribing(bool value) {
  set_has_message_subscribing();
  message_subscribing_ = value;
}

// optional .pbmsg.CustomStatus custom_status = 23;
inline bool Account::has_custom_status() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Account::set_has_custom_status() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Account::clear_has_custom_status() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Account::clear_custom_status() {
  custom_status_ = 0;
  clear_has_custom_status();
}
inline ::pbmsg::CustomStatus Account::custom_status() const {
  return static_cast< ::pbmsg::CustomStatus >(custom_status_);
}
inline void Account::set_custom_status(::pbmsg::CustomStatus value) {
  assert(::pbmsg::CustomStatus_IsValid(value));
  set_has_custom_status();
  custom_status_ = value;
}

// -------------------------------------------------------------------

// User

// required .pbmsg.Entity base = 1;
inline bool User::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& User::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* User::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* User::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void User::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional bytes password = 2;
inline bool User::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& User::password() const {
  return *password_;
}
inline void User::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* User::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pbmsg.UserType user_type = 3;
inline bool User::has_user_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_user_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_user_type() {
  user_type_ = 0;
  clear_has_user_type();
}
inline ::pbmsg::UserType User::user_type() const {
  return static_cast< ::pbmsg::UserType >(user_type_);
}
inline void User::set_user_type(::pbmsg::UserType value) {
  assert(::pbmsg::UserType_IsValid(value));
  set_has_user_type();
  user_type_ = value;
}

// optional .pbmsg.Entity account = 4;
inline bool User::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_account() {
  if (account_ != NULL) account_->::pbmsg::Entity::Clear();
  clear_has_account();
}
inline const ::pbmsg::Entity& User::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::pbmsg::Entity* User::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::pbmsg::Entity;
  return account_;
}
inline ::pbmsg::Entity* User::release_account() {
  clear_has_account();
  ::pbmsg::Entity* temp = account_;
  account_ = NULL;
  return temp;
}
inline void User::set_allocated_account(::pbmsg::Entity* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// optional .pbmsg.RegisterStatus status = 5;
inline bool User::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::RegisterStatus User::status() const {
  return static_cast< ::pbmsg::RegisterStatus >(status_);
}
inline void User::set_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .pbmsg.Address address = 6;
inline bool User::has_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_address() {
  if (address_ != NULL) address_->::pbmsg::Address::Clear();
  clear_has_address();
}
inline const ::pbmsg::Address& User::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::pbmsg::Address* User::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::pbmsg::Address;
  return address_;
}
inline ::pbmsg::Address* User::release_address() {
  clear_has_address();
  ::pbmsg::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void User::set_allocated_address(::pbmsg::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// -------------------------------------------------------------------

// Organization

// required .pbmsg.Entity base = 1;
inline bool Organization::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Organization::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Organization::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Organization::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Organization::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Organization::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Organization::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Organization::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional bool include_members = 2;
inline bool Organization::has_include_members() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Organization::set_has_include_members() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Organization::clear_has_include_members() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Organization::clear_include_members() {
  include_members_ = false;
  clear_has_include_members();
}
inline bool Organization::include_members() const {
  return include_members_;
}
inline void Organization::set_include_members(bool value) {
  set_has_include_members();
  include_members_ = value;
}

// repeated .pbmsg.Entity members = 3;
inline int Organization::members_size() const {
  return members_.size();
}
inline void Organization::clear_members() {
  members_.Clear();
}
inline const ::pbmsg::Entity& Organization::members(int index) const {
  return members_.Get(index);
}
inline ::pbmsg::Entity* Organization::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pbmsg::Entity* Organization::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Organization::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Organization::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// Participant

// optional fixed32 id = 1;
inline bool Participant::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Participant::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Participant::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Participant::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Participant::id() const {
  return id_;
}
inline void Participant::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .pbmsg.Entity group = 2;
inline bool Participant::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Participant::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Participant::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Participant::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Entity::Clear();
  clear_has_group();
}
inline const ::pbmsg::Entity& Participant::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Entity* Participant::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Entity;
  return group_;
}
inline ::pbmsg::Entity* Participant::release_group() {
  clear_has_group();
  ::pbmsg::Entity* temp = group_;
  group_ = NULL;
  return temp;
}
inline void Participant::set_allocated_group(::pbmsg::Entity* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// optional .pbmsg.Entity account = 3;
inline bool Participant::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Participant::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Participant::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Participant::clear_account() {
  if (account_ != NULL) account_->::pbmsg::Entity::Clear();
  clear_has_account();
}
inline const ::pbmsg::Entity& Participant::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::pbmsg::Entity* Participant::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::pbmsg::Entity;
  return account_;
}
inline ::pbmsg::Entity* Participant::release_account() {
  clear_has_account();
  ::pbmsg::Entity* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Participant::set_allocated_account(::pbmsg::Entity* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// optional fixed32 priority = 4;
inline bool Participant::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Participant::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Participant::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Participant::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 Participant::priority() const {
  return priority_;
}
inline void Participant::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional .pbmsg.CallPrivilege call_privilege = 5;
inline bool Participant::has_call_privilege() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Participant::set_has_call_privilege() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Participant::clear_has_call_privilege() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Participant::clear_call_privilege() {
  call_privilege_ = 0;
  clear_has_call_privilege();
}
inline ::pbmsg::CallPrivilege Participant::call_privilege() const {
  return static_cast< ::pbmsg::CallPrivilege >(call_privilege_);
}
inline void Participant::set_call_privilege(::pbmsg::CallPrivilege value) {
  assert(::pbmsg::CallPrivilege_IsValid(value));
  set_has_call_privilege();
  call_privilege_ = value;
}

// optional .pbmsg.TokenPrivilege token_privilege = 6;
inline bool Participant::has_token_privilege() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Participant::set_has_token_privilege() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Participant::clear_has_token_privilege() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Participant::clear_token_privilege() {
  token_privilege_ = 0;
  clear_has_token_privilege();
}
inline ::pbmsg::TokenPrivilege Participant::token_privilege() const {
  return static_cast< ::pbmsg::TokenPrivilege >(token_privilege_);
}
inline void Participant::set_token_privilege(::pbmsg::TokenPrivilege value) {
  assert(::pbmsg::TokenPrivilege_IsValid(value));
  set_has_token_privilege();
  token_privilege_ = value;
}

// optional bytes join_timestamp = 7;
inline bool Participant::has_join_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Participant::set_has_join_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Participant::clear_has_join_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Participant::clear_join_timestamp() {
  if (join_timestamp_ != &::google::protobuf::internal::kEmptyString) {
    join_timestamp_->clear();
  }
  clear_has_join_timestamp();
}
inline const ::std::string& Participant::join_timestamp() const {
  return *join_timestamp_;
}
inline void Participant::set_join_timestamp(const ::std::string& value) {
  set_has_join_timestamp();
  if (join_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    join_timestamp_ = new ::std::string;
  }
  join_timestamp_->assign(value);
}
inline void Participant::set_join_timestamp(const char* value) {
  set_has_join_timestamp();
  if (join_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    join_timestamp_ = new ::std::string;
  }
  join_timestamp_->assign(value);
}
inline void Participant::set_join_timestamp(const void* value, size_t size) {
  set_has_join_timestamp();
  if (join_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    join_timestamp_ = new ::std::string;
  }
  join_timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Participant::mutable_join_timestamp() {
  set_has_join_timestamp();
  if (join_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    join_timestamp_ = new ::std::string;
  }
  return join_timestamp_;
}
inline ::std::string* Participant::release_join_timestamp() {
  clear_has_join_timestamp();
  if (join_timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = join_timestamp_;
    join_timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Participant::set_allocated_join_timestamp(::std::string* join_timestamp) {
  if (join_timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete join_timestamp_;
  }
  if (join_timestamp) {
    set_has_join_timestamp();
    join_timestamp_ = join_timestamp;
  } else {
    clear_has_join_timestamp();
    join_timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pbmsg.SessionStatus status = 8;
inline bool Participant::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Participant::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Participant::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Participant::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::SessionStatus Participant::status() const {
  return static_cast< ::pbmsg::SessionStatus >(status_);
}
inline void Participant::set_status(::pbmsg::SessionStatus value) {
  assert(::pbmsg::SessionStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional bool participant_subscribing = 9;
inline bool Participant::has_participant_subscribing() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Participant::set_has_participant_subscribing() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Participant::clear_has_participant_subscribing() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Participant::clear_participant_subscribing() {
  participant_subscribing_ = false;
  clear_has_participant_subscribing();
}
inline bool Participant::participant_subscribing() const {
  return participant_subscribing_;
}
inline void Participant::set_participant_subscribing(bool value) {
  set_has_participant_subscribing();
  participant_subscribing_ = value;
}

// optional bool message_subscribing = 10;
inline bool Participant::has_message_subscribing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Participant::set_has_message_subscribing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Participant::clear_has_message_subscribing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Participant::clear_message_subscribing() {
  message_subscribing_ = false;
  clear_has_message_subscribing();
}
inline bool Participant::message_subscribing() const {
  return message_subscribing_;
}
inline void Participant::set_message_subscribing(bool value) {
  set_has_message_subscribing();
  message_subscribing_ = value;
}

// -------------------------------------------------------------------

// Group

// required .pbmsg.Entity base = 1;
inline bool Group::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Group::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Group::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Group::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Group::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .pbmsg.Entity owner = 2;
inline bool Group::has_owner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_owner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_owner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_owner() {
  if (owner_ != NULL) owner_->::pbmsg::Entity::Clear();
  clear_has_owner();
}
inline const ::pbmsg::Entity& Group::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::pbmsg::Entity* Group::mutable_owner() {
  set_has_owner();
  if (owner_ == NULL) owner_ = new ::pbmsg::Entity;
  return owner_;
}
inline ::pbmsg::Entity* Group::release_owner() {
  clear_has_owner();
  ::pbmsg::Entity* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline void Group::set_allocated_owner(::pbmsg::Entity* owner) {
  delete owner_;
  owner_ = owner;
  if (owner) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
}

// optional bytes number = 3;
inline bool Group::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_number() {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& Group::number() const {
  return *number_;
}
inline void Group::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Group::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(value);
}
inline void Group::set_number(const void* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Group::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    number_ = new ::std::string;
  }
  return number_;
}
inline ::std::string* Group::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Group::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::kEmptyString) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes short_number = 4;
inline bool Group::has_short_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Group::set_has_short_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Group::clear_has_short_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Group::clear_short_number() {
  if (short_number_ != &::google::protobuf::internal::kEmptyString) {
    short_number_->clear();
  }
  clear_has_short_number();
}
inline const ::std::string& Group::short_number() const {
  return *short_number_;
}
inline void Group::set_short_number(const ::std::string& value) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(value);
}
inline void Group::set_short_number(const char* value) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(value);
}
inline void Group::set_short_number(const void* value, size_t size) {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  short_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Group::mutable_short_number() {
  set_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    short_number_ = new ::std::string;
  }
  return short_number_;
}
inline ::std::string* Group::release_short_number() {
  clear_has_short_number();
  if (short_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_number_;
    short_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Group::set_allocated_short_number(::std::string* short_number) {
  if (short_number_ != &::google::protobuf::internal::kEmptyString) {
    delete short_number_;
  }
  if (short_number) {
    set_has_short_number();
    short_number_ = short_number;
  } else {
    clear_has_short_number();
    short_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool sealed = 5;
inline bool Group::has_sealed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Group::set_has_sealed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Group::clear_has_sealed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Group::clear_sealed() {
  sealed_ = false;
  clear_has_sealed();
}
inline bool Group::sealed() const {
  return sealed_;
}
inline void Group::set_sealed(bool value) {
  set_has_sealed();
  sealed_ = value;
}

// optional bool include_participants = 6;
inline bool Group::has_include_participants() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Group::set_has_include_participants() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Group::clear_has_include_participants() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Group::clear_include_participants() {
  include_participants_ = false;
  clear_has_include_participants();
}
inline bool Group::include_participants() const {
  return include_participants_;
}
inline void Group::set_include_participants(bool value) {
  set_has_include_participants();
  include_participants_ = value;
}

// repeated .pbmsg.Participant participants = 7;
inline int Group::participants_size() const {
  return participants_.size();
}
inline void Group::clear_participants() {
  participants_.Clear();
}
inline const ::pbmsg::Participant& Group::participants(int index) const {
  return participants_.Get(index);
}
inline ::pbmsg::Participant* Group::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline ::pbmsg::Participant* Group::add_participants() {
  return participants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >&
Group::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Participant >*
Group::mutable_participants() {
  return &participants_;
}

// optional .pbmsg.RecordType record_type = 8;
inline bool Group::has_record_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Group::set_has_record_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Group::clear_has_record_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Group::clear_record_type() {
  record_type_ = 0;
  clear_has_record_type();
}
inline ::pbmsg::RecordType Group::record_type() const {
  return static_cast< ::pbmsg::RecordType >(record_type_);
}
inline void Group::set_record_type(::pbmsg::RecordType value) {
  assert(::pbmsg::RecordType_IsValid(value));
  set_has_record_type();
  record_type_ = value;
}

// optional .pbmsg.Entity recorder = 9;
inline bool Group::has_recorder() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Group::set_has_recorder() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Group::clear_has_recorder() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Group::clear_recorder() {
  if (recorder_ != NULL) recorder_->::pbmsg::Entity::Clear();
  clear_has_recorder();
}
inline const ::pbmsg::Entity& Group::recorder() const {
  return recorder_ != NULL ? *recorder_ : *default_instance_->recorder_;
}
inline ::pbmsg::Entity* Group::mutable_recorder() {
  set_has_recorder();
  if (recorder_ == NULL) recorder_ = new ::pbmsg::Entity;
  return recorder_;
}
inline ::pbmsg::Entity* Group::release_recorder() {
  clear_has_recorder();
  ::pbmsg::Entity* temp = recorder_;
  recorder_ = NULL;
  return temp;
}
inline void Group::set_allocated_recorder(::pbmsg::Entity* recorder) {
  delete recorder_;
  recorder_ = recorder;
  if (recorder) {
    set_has_recorder();
  } else {
    clear_has_recorder();
  }
}

// optional .pbmsg.RecordStatus record_status = 10;
inline bool Group::has_record_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Group::set_has_record_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Group::clear_has_record_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Group::clear_record_status() {
  record_status_ = 0;
  clear_has_record_status();
}
inline ::pbmsg::RecordStatus Group::record_status() const {
  return static_cast< ::pbmsg::RecordStatus >(record_status_);
}
inline void Group::set_record_status(::pbmsg::RecordStatus value) {
  assert(::pbmsg::RecordStatus_IsValid(value));
  set_has_record_status();
  record_status_ = value;
}

// optional .pbmsg.Entity record_server = 11;
inline bool Group::has_record_server() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Group::set_has_record_server() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Group::clear_has_record_server() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Group::clear_record_server() {
  if (record_server_ != NULL) record_server_->::pbmsg::Entity::Clear();
  clear_has_record_server();
}
inline const ::pbmsg::Entity& Group::record_server() const {
  return record_server_ != NULL ? *record_server_ : *default_instance_->record_server_;
}
inline ::pbmsg::Entity* Group::mutable_record_server() {
  set_has_record_server();
  if (record_server_ == NULL) record_server_ = new ::pbmsg::Entity;
  return record_server_;
}
inline ::pbmsg::Entity* Group::release_record_server() {
  clear_has_record_server();
  ::pbmsg::Entity* temp = record_server_;
  record_server_ = NULL;
  return temp;
}
inline void Group::set_allocated_record_server(::pbmsg::Entity* record_server) {
  delete record_server_;
  record_server_ = record_server;
  if (record_server) {
    set_has_record_server();
  } else {
    clear_has_record_server();
  }
}

// optional bool include_listen_users = 12;
inline bool Group::has_include_listen_users() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Group::set_has_include_listen_users() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Group::clear_has_include_listen_users() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Group::clear_include_listen_users() {
  include_listen_users_ = false;
  clear_has_include_listen_users();
}
inline bool Group::include_listen_users() const {
  return include_listen_users_;
}
inline void Group::set_include_listen_users(bool value) {
  set_has_include_listen_users();
  include_listen_users_ = value;
}

// repeated .pbmsg.Entity listen_users = 13;
inline int Group::listen_users_size() const {
  return listen_users_.size();
}
inline void Group::clear_listen_users() {
  listen_users_.Clear();
}
inline const ::pbmsg::Entity& Group::listen_users(int index) const {
  return listen_users_.Get(index);
}
inline ::pbmsg::Entity* Group::mutable_listen_users(int index) {
  return listen_users_.Mutable(index);
}
inline ::pbmsg::Entity* Group::add_listen_users() {
  return listen_users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Group::listen_users() const {
  return listen_users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Group::mutable_listen_users() {
  return &listen_users_;
}

// -------------------------------------------------------------------

// Alert

// required .pbmsg.Entity base = 1;
inline bool Alert::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Alert::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Alert::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Alert::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Alert::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Alert::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Alert::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Alert::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .pbmsg.Entity group = 2;
inline bool Alert::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Alert::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Alert::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Alert::clear_group() {
  if (group_ != NULL) group_->::pbmsg::Entity::Clear();
  clear_has_group();
}
inline const ::pbmsg::Entity& Alert::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pbmsg::Entity* Alert::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pbmsg::Entity;
  return group_;
}
inline ::pbmsg::Entity* Alert::release_group() {
  clear_has_group();
  ::pbmsg::Entity* temp = group_;
  group_ = NULL;
  return temp;
}
inline void Alert::set_allocated_group(::pbmsg::Entity* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// optional bytes describe = 3;
inline bool Alert::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alert::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alert::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alert::clear_describe() {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    describe_->clear();
  }
  clear_has_describe();
}
inline const ::std::string& Alert::describe() const {
  return *describe_;
}
inline void Alert::set_describe(const ::std::string& value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void Alert::set_describe(const char* value) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(value);
}
inline void Alert::set_describe(const void* value, size_t size) {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_describe() {
  set_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    describe_ = new ::std::string;
  }
  return describe_;
}
inline ::std::string* Alert::release_describe() {
  clear_has_describe();
  if (describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describe_;
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_describe(::std::string* describe) {
  if (describe_ != &::google::protobuf::internal::kEmptyString) {
    delete describe_;
  }
  if (describe) {
    set_has_describe();
    describe_ = describe;
  } else {
    clear_has_describe();
    describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pbmsg.AlertLevel level = 4;
inline bool Alert::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alert::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alert::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alert::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::pbmsg::AlertLevel Alert::level() const {
  return static_cast< ::pbmsg::AlertLevel >(level_);
}
inline void Alert::set_level(::pbmsg::AlertLevel value) {
  assert(::pbmsg::AlertLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// optional bytes alram_time = 5;
inline bool Alert::has_alram_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alert::set_has_alram_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alert::clear_has_alram_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alert::clear_alram_time() {
  if (alram_time_ != &::google::protobuf::internal::kEmptyString) {
    alram_time_->clear();
  }
  clear_has_alram_time();
}
inline const ::std::string& Alert::alram_time() const {
  return *alram_time_;
}
inline void Alert::set_alram_time(const ::std::string& value) {
  set_has_alram_time();
  if (alram_time_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_ = new ::std::string;
  }
  alram_time_->assign(value);
}
inline void Alert::set_alram_time(const char* value) {
  set_has_alram_time();
  if (alram_time_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_ = new ::std::string;
  }
  alram_time_->assign(value);
}
inline void Alert::set_alram_time(const void* value, size_t size) {
  set_has_alram_time();
  if (alram_time_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_ = new ::std::string;
  }
  alram_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_alram_time() {
  set_has_alram_time();
  if (alram_time_ == &::google::protobuf::internal::kEmptyString) {
    alram_time_ = new ::std::string;
  }
  return alram_time_;
}
inline ::std::string* Alert::release_alram_time() {
  clear_has_alram_time();
  if (alram_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alram_time_;
    alram_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_alram_time(::std::string* alram_time) {
  if (alram_time_ != &::google::protobuf::internal::kEmptyString) {
    delete alram_time_;
  }
  if (alram_time) {
    set_has_alram_time();
    alram_time_ = alram_time;
  } else {
    clear_has_alram_time();
    alram_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 use_cars = 6;
inline bool Alert::has_use_cars() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alert::set_has_use_cars() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alert::clear_has_use_cars() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alert::clear_use_cars() {
  use_cars_ = 0u;
  clear_has_use_cars();
}
inline ::google::protobuf::uint32 Alert::use_cars() const {
  return use_cars_;
}
inline void Alert::set_use_cars(::google::protobuf::uint32 value) {
  set_has_use_cars();
  use_cars_ = value;
}

// optional bytes create_time = 7;
inline bool Alert::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Alert::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Alert::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Alert::clear_create_time() {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    create_time_->clear();
  }
  clear_has_create_time();
}
inline const ::std::string& Alert::create_time() const {
  return *create_time_;
}
inline void Alert::set_create_time(const ::std::string& value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void Alert::set_create_time(const char* value) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(value);
}
inline void Alert::set_create_time(const void* value, size_t size) {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  create_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Alert::mutable_create_time() {
  set_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    create_time_ = new ::std::string;
  }
  return create_time_;
}
inline ::std::string* Alert::release_create_time() {
  clear_has_create_time();
  if (create_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = create_time_;
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Alert::set_allocated_create_time(::std::string* create_time) {
  if (create_time_ != &::google::protobuf::internal::kEmptyString) {
    delete create_time_;
  }
  if (create_time) {
    set_has_create_time();
    create_time_ = create_time;
  } else {
    clear_has_create_time();
    create_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Gateway

// required .pbmsg.Entity base = 1;
inline bool Gateway::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gateway::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gateway::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gateway::clear_base() {
  if (base_ != NULL) base_->::pbmsg::Entity::Clear();
  clear_has_base();
}
inline const ::pbmsg::Entity& Gateway::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::pbmsg::Entity* Gateway::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::pbmsg::Entity;
  return base_;
}
inline ::pbmsg::Entity* Gateway::release_base() {
  clear_has_base();
  ::pbmsg::Entity* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Gateway::set_allocated_base(::pbmsg::Entity* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .pbmsg.Address address = 2;
inline bool Gateway::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gateway::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gateway::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gateway::clear_address() {
  if (address_ != NULL) address_->::pbmsg::Address::Clear();
  clear_has_address();
}
inline const ::pbmsg::Address& Gateway::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::pbmsg::Address* Gateway::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::pbmsg::Address;
  return address_;
}
inline ::pbmsg::Address* Gateway::release_address() {
  clear_has_address();
  ::pbmsg::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Gateway::set_allocated_address(::pbmsg::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// optional bool include_allocate_counts = 3;
inline bool Gateway::has_include_allocate_counts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gateway::set_has_include_allocate_counts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gateway::clear_has_include_allocate_counts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gateway::clear_include_allocate_counts() {
  include_allocate_counts_ = false;
  clear_has_include_allocate_counts();
}
inline bool Gateway::include_allocate_counts() const {
  return include_allocate_counts_;
}
inline void Gateway::set_include_allocate_counts(bool value) {
  set_has_include_allocate_counts();
  include_allocate_counts_ = value;
}

// repeated .pbmsg.Entity allocate_counts = 4;
inline int Gateway::allocate_counts_size() const {
  return allocate_counts_.size();
}
inline void Gateway::clear_allocate_counts() {
  allocate_counts_.Clear();
}
inline const ::pbmsg::Entity& Gateway::allocate_counts(int index) const {
  return allocate_counts_.Get(index);
}
inline ::pbmsg::Entity* Gateway::mutable_allocate_counts(int index) {
  return allocate_counts_.Mutable(index);
}
inline ::pbmsg::Entity* Gateway::add_allocate_counts() {
  return allocate_counts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Gateway::allocate_counts() const {
  return allocate_counts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Gateway::mutable_allocate_counts() {
  return &allocate_counts_;
}

// optional bool include_active_counts = 5;
inline bool Gateway::has_include_active_counts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gateway::set_has_include_active_counts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gateway::clear_has_include_active_counts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gateway::clear_include_active_counts() {
  include_active_counts_ = false;
  clear_has_include_active_counts();
}
inline bool Gateway::include_active_counts() const {
  return include_active_counts_;
}
inline void Gateway::set_include_active_counts(bool value) {
  set_has_include_active_counts();
  include_active_counts_ = value;
}

// repeated .pbmsg.Entity active_counts = 6;
inline int Gateway::active_counts_size() const {
  return active_counts_.size();
}
inline void Gateway::clear_active_counts() {
  active_counts_.Clear();
}
inline const ::pbmsg::Entity& Gateway::active_counts(int index) const {
  return active_counts_.Get(index);
}
inline ::pbmsg::Entity* Gateway::mutable_active_counts(int index) {
  return active_counts_.Mutable(index);
}
inline ::pbmsg::Entity* Gateway::add_active_counts() {
  return active_counts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Gateway::active_counts() const {
  return active_counts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Gateway::mutable_active_counts() {
  return &active_counts_;
}

// optional bool include_recordings = 7;
inline bool Gateway::has_include_recordings() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gateway::set_has_include_recordings() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gateway::clear_has_include_recordings() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gateway::clear_include_recordings() {
  include_recordings_ = false;
  clear_has_include_recordings();
}
inline bool Gateway::include_recordings() const {
  return include_recordings_;
}
inline void Gateway::set_include_recordings(bool value) {
  set_has_include_recordings();
  include_recordings_ = value;
}

// repeated .pbmsg.Entity recordings = 8;
inline int Gateway::recordings_size() const {
  return recordings_.size();
}
inline void Gateway::clear_recordings() {
  recordings_.Clear();
}
inline const ::pbmsg::Entity& Gateway::recordings(int index) const {
  return recordings_.Get(index);
}
inline ::pbmsg::Entity* Gateway::mutable_recordings(int index) {
  return recordings_.Mutable(index);
}
inline ::pbmsg::Entity* Gateway::add_recordings() {
  return recordings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >&
Gateway::recordings() const {
  return recordings_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbmsg::Entity >*
Gateway::mutable_recordings() {
  return &recordings_;
}

// optional .pbmsg.RegisterStatus status = 9;
inline bool Gateway::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Gateway::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Gateway::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Gateway::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::pbmsg::RegisterStatus Gateway::status() const {
  return static_cast< ::pbmsg::RegisterStatus >(status_);
}
inline void Gateway::set_status(::pbmsg::RegisterStatus value) {
  assert(::pbmsg::RegisterStatus_IsValid(value));
  set_has_status();
  status_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbmsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::AlertStatus>() {
  return ::pbmsg::AlertStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::AlertLevel>() {
  return ::pbmsg::AlertLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::SessionStatus>() {
  return ::pbmsg::SessionStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::RecordType>() {
  return ::pbmsg::RecordType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::AccountServiceStatus>() {
  return ::pbmsg::AccountServiceStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::CallPrivilege>() {
  return ::pbmsg::CallPrivilege_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::CustomStatus>() {
  return ::pbmsg::CustomStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::RegisterStatus>() {
  return ::pbmsg::RegisterStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::EntityType>() {
  return ::pbmsg::EntityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::UserType>() {
  return ::pbmsg::UserType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::MessageType>() {
  return ::pbmsg::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::TokenPrivilege>() {
  return ::pbmsg::TokenPrivilege_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::AccountType>() {
  return ::pbmsg::AccountType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::GpsReportMode>() {
  return ::pbmsg::GpsReportMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbmsg::RecordStatus>() {
  return ::pbmsg::RecordStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AppData_2eproto__INCLUDED
