// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: app.admin.proto

#ifndef PROTOBUF_app_2eadmin_2eproto__INCLUDED
#define PROTOBUF_app_2eadmin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AppData.pb.h"
#include "EntityData.pb.h"
#include "Configure.pb.h"
// @@protoc_insertion_point(includes)

namespace app {
namespace admin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_app_2eadmin_2eproto();
void protobuf_AssignDesc_app_2eadmin_2eproto();
void protobuf_ShutdownFile_app_2eadmin_2eproto();

class LoginRequest;
class LoginResponse;
class AppendEntityRequest;
class AppendEntityResponse;
class ModifyEntityRequest;
class DeleteEntityRequest;
class EntityRequest;
class EntityResponse;
class EntityNotification;
class GetSystemConfigureResponse;
class SetSystemConfigureRequest;
class Request;
class Response;
class Indication;
class Message;

enum MSG {
  Login_Request = 100001,
  Login_Response = 100002,
  Logout_Request = 100003,
  Logout_Response = 100004,
  Keepalive_Request = 100005,
  Keepalive_Response = 100006,
  Append_Entity_Request = 100007,
  Append_Entity_Response = 100008,
  Modify_Entity_Request = 100009,
  Modify_Entity_Response = 100010,
  Delete_Entity_Request = 100011,
  Delete_Entity_Response = 100012,
  Entity_Request = 100013,
  Entity_Response = 100014,
  Get_System_Configure_Request = 100015,
  Get_System_Configure_Response = 100016,
  Set_System_Configure_Request = 100017,
  Set_System_Configure_Response = 100018,
  Entity_Notification = 110001
};
bool MSG_IsValid(int value);
const MSG MSG_MIN = Login_Request;
const MSG MSG_MAX = Entity_Notification;
const int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_descriptor();
inline const ::std::string& MSG_Name(MSG value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_descriptor(), value);
}
inline bool MSG_Parse(
    const ::std::string& name, MSG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:app.admin.LoginRequest)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .pbmsg.User self = 2;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 2;
  inline const ::pbmsg::User& self() const;
  inline ::pbmsg::User* mutable_self();
  inline ::pbmsg::User* release_self();
  inline void set_allocated_self(::pbmsg::User* self);

  // required fixed32 ttl = 3;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 3;
  inline ::google::protobuf::uint32 ttl() const;
  inline void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:app.admin.LoginResponse)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::User* self_;
  ::google::protobuf::uint32 session_id_;
  ::google::protobuf::uint32 ttl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class AppendEntityRequest : public ::google::protobuf::Message {
 public:
  AppendEntityRequest();
  virtual ~AppendEntityRequest();

  AppendEntityRequest(const AppendEntityRequest& from);

  inline AppendEntityRequest& operator=(const AppendEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntityRequest& default_instance();

  void Swap(AppendEntityRequest* other);

  // implements Message ----------------------------------------------

  AppendEntityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendEntityRequest& from);
  void MergeFrom(const AppendEntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.admin.AppendEntityRequest)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static AppendEntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppendEntityResponse : public ::google::protobuf::Message {
 public:
  AppendEntityResponse();
  virtual ~AppendEntityResponse();

  AppendEntityResponse(const AppendEntityResponse& from);

  inline AppendEntityResponse& operator=(const AppendEntityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntityResponse& default_instance();

  void Swap(AppendEntityResponse* other);

  // implements Message ----------------------------------------------

  AppendEntityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendEntityResponse& from);
  void MergeFrom(const AppendEntityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.admin.AppendEntityResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static AppendEntityResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyEntityRequest : public ::google::protobuf::Message {
 public:
  ModifyEntityRequest();
  virtual ~ModifyEntityRequest();

  ModifyEntityRequest(const ModifyEntityRequest& from);

  inline ModifyEntityRequest& operator=(const ModifyEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyEntityRequest& default_instance();

  void Swap(ModifyEntityRequest* other);

  // implements Message ----------------------------------------------

  ModifyEntityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyEntityRequest& from);
  void MergeFrom(const ModifyEntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.admin.ModifyEntityRequest)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static ModifyEntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteEntityRequest : public ::google::protobuf::Message {
 public:
  DeleteEntityRequest();
  virtual ~DeleteEntityRequest();

  DeleteEntityRequest(const DeleteEntityRequest& from);

  inline DeleteEntityRequest& operator=(const DeleteEntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteEntityRequest& default_instance();

  void Swap(DeleteEntityRequest* other);

  // implements Message ----------------------------------------------

  DeleteEntityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteEntityRequest& from);
  void MergeFrom(const DeleteEntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // @@protoc_insertion_point(class_scope:app.admin.DeleteEntityRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static DeleteEntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntityRequest : public ::google::protobuf::Message {
 public:
  EntityRequest();
  virtual ~EntityRequest();

  EntityRequest(const EntityRequest& from);

  inline EntityRequest& operator=(const EntityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityRequest& default_instance();

  void Swap(EntityRequest* other);

  // implements Message ----------------------------------------------

  EntityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityRequest& from);
  void MergeFrom(const EntityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Entity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pbmsg::Entity& id() const;
  inline ::pbmsg::Entity* mutable_id();
  inline ::pbmsg::Entity* release_id();
  inline void set_allocated_id(::pbmsg::Entity* id);

  // @@protoc_insertion_point(class_scope:app.admin.EntityRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Entity* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static EntityRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntityResponse : public ::google::protobuf::Message {
 public:
  EntityResponse();
  virtual ~EntityResponse();

  EntityResponse(const EntityResponse& from);

  inline EntityResponse& operator=(const EntityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityResponse& default_instance();

  void Swap(EntityResponse* other);

  // implements Message ----------------------------------------------

  EntityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityResponse& from);
  void MergeFrom(const EntityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.admin.EntityResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static EntityResponse* default_instance_;
};
// -------------------------------------------------------------------

class EntityNotification : public ::google::protobuf::Message {
 public:
  EntityNotification();
  virtual ~EntityNotification();

  EntityNotification(const EntityNotification& from);

  inline EntityNotification& operator=(const EntityNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityNotification& default_instance();

  void Swap(EntityNotification* other);

  // implements Message ----------------------------------------------

  EntityNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityNotification& from);
  void MergeFrom(const EntityNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.EntityNotifyType notify_type = 1;
  inline bool has_notify_type() const;
  inline void clear_notify_type();
  static const int kNotifyTypeFieldNumber = 1;
  inline ::pbmsg::EntityNotifyType notify_type() const;
  inline void set_notify_type(::pbmsg::EntityNotifyType value);

  // required .pbmsg.EntityData data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::pbmsg::EntityData& data() const;
  inline ::pbmsg::EntityData* mutable_data();
  inline ::pbmsg::EntityData* release_data();
  inline void set_allocated_data(::pbmsg::EntityData* data);

  // @@protoc_insertion_point(class_scope:app.admin.EntityNotification)
 private:
  inline void set_has_notify_type();
  inline void clear_has_notify_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::EntityData* data_;
  int notify_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static EntityNotification* default_instance_;
};
// -------------------------------------------------------------------

class GetSystemConfigureResponse : public ::google::protobuf::Message {
 public:
  GetSystemConfigureResponse();
  virtual ~GetSystemConfigureResponse();

  GetSystemConfigureResponse(const GetSystemConfigureResponse& from);

  inline GetSystemConfigureResponse& operator=(const GetSystemConfigureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSystemConfigureResponse& default_instance();

  void Swap(GetSystemConfigureResponse* other);

  // implements Message ----------------------------------------------

  GetSystemConfigureResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSystemConfigureResponse& from);
  void MergeFrom(const GetSystemConfigureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Configure configure = 1;
  inline bool has_configure() const;
  inline void clear_configure();
  static const int kConfigureFieldNumber = 1;
  inline const ::pbmsg::Configure& configure() const;
  inline ::pbmsg::Configure* mutable_configure();
  inline ::pbmsg::Configure* release_configure();
  inline void set_allocated_configure(::pbmsg::Configure* configure);

  // @@protoc_insertion_point(class_scope:app.admin.GetSystemConfigureResponse)
 private:
  inline void set_has_configure();
  inline void clear_has_configure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Configure* configure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static GetSystemConfigureResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetSystemConfigureRequest : public ::google::protobuf::Message {
 public:
  SetSystemConfigureRequest();
  virtual ~SetSystemConfigureRequest();

  SetSystemConfigureRequest(const SetSystemConfigureRequest& from);

  inline SetSystemConfigureRequest& operator=(const SetSystemConfigureRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetSystemConfigureRequest& default_instance();

  void Swap(SetSystemConfigureRequest* other);

  // implements Message ----------------------------------------------

  SetSystemConfigureRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetSystemConfigureRequest& from);
  void MergeFrom(const SetSystemConfigureRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pbmsg.Configure configure = 1;
  inline bool has_configure() const;
  inline void clear_configure();
  static const int kConfigureFieldNumber = 1;
  inline const ::pbmsg::Configure& configure() const;
  inline ::pbmsg::Configure* mutable_configure();
  inline ::pbmsg::Configure* release_configure();
  inline void set_allocated_configure(::pbmsg::Configure* configure);

  // @@protoc_insertion_point(class_scope:app.admin.SetSystemConfigureRequest)
 private:
  inline void set_has_configure();
  inline void clear_has_configure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pbmsg::Configure* configure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static SetSystemConfigureRequest* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.admin.LoginRequest login = 1;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 1;
  inline const ::app::admin::LoginRequest& login() const;
  inline ::app::admin::LoginRequest* mutable_login();
  inline ::app::admin::LoginRequest* release_login();
  inline void set_allocated_login(::app::admin::LoginRequest* login);

  // optional .app.admin.AppendEntityRequest append_entity = 2;
  inline bool has_append_entity() const;
  inline void clear_append_entity();
  static const int kAppendEntityFieldNumber = 2;
  inline const ::app::admin::AppendEntityRequest& append_entity() const;
  inline ::app::admin::AppendEntityRequest* mutable_append_entity();
  inline ::app::admin::AppendEntityRequest* release_append_entity();
  inline void set_allocated_append_entity(::app::admin::AppendEntityRequest* append_entity);

  // optional .app.admin.ModifyEntityRequest modify_entity = 3;
  inline bool has_modify_entity() const;
  inline void clear_modify_entity();
  static const int kModifyEntityFieldNumber = 3;
  inline const ::app::admin::ModifyEntityRequest& modify_entity() const;
  inline ::app::admin::ModifyEntityRequest* mutable_modify_entity();
  inline ::app::admin::ModifyEntityRequest* release_modify_entity();
  inline void set_allocated_modify_entity(::app::admin::ModifyEntityRequest* modify_entity);

  // optional .app.admin.DeleteEntityRequest delete_entity = 4;
  inline bool has_delete_entity() const;
  inline void clear_delete_entity();
  static const int kDeleteEntityFieldNumber = 4;
  inline const ::app::admin::DeleteEntityRequest& delete_entity() const;
  inline ::app::admin::DeleteEntityRequest* mutable_delete_entity();
  inline ::app::admin::DeleteEntityRequest* release_delete_entity();
  inline void set_allocated_delete_entity(::app::admin::DeleteEntityRequest* delete_entity);

  // optional .app.admin.EntityRequest entity = 5;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 5;
  inline const ::app::admin::EntityRequest& entity() const;
  inline ::app::admin::EntityRequest* mutable_entity();
  inline ::app::admin::EntityRequest* release_entity();
  inline void set_allocated_entity(::app::admin::EntityRequest* entity);

  // optional .app.admin.SetSystemConfigureRequest set_system_configure = 6;
  inline bool has_set_system_configure() const;
  inline void clear_set_system_configure();
  static const int kSetSystemConfigureFieldNumber = 6;
  inline const ::app::admin::SetSystemConfigureRequest& set_system_configure() const;
  inline ::app::admin::SetSystemConfigureRequest* mutable_set_system_configure();
  inline ::app::admin::SetSystemConfigureRequest* release_set_system_configure();
  inline void set_allocated_set_system_configure(::app::admin::SetSystemConfigureRequest* set_system_configure);

  // @@protoc_insertion_point(class_scope:app.admin.Request)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_append_entity();
  inline void clear_has_append_entity();
  inline void set_has_modify_entity();
  inline void clear_has_modify_entity();
  inline void set_has_delete_entity();
  inline void clear_has_delete_entity();
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_set_system_configure();
  inline void clear_has_set_system_configure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::admin::LoginRequest* login_;
  ::app::admin::AppendEntityRequest* append_entity_;
  ::app::admin::ModifyEntityRequest* modify_entity_;
  ::app::admin::DeleteEntityRequest* delete_entity_;
  ::app::admin::EntityRequest* entity_;
  ::app::admin::SetSystemConfigureRequest* set_system_configure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // required bool last_response = 2;
  inline bool has_last_response() const;
  inline void clear_last_response();
  static const int kLastResponseFieldNumber = 2;
  inline bool last_response() const;
  inline void set_last_response(bool value);

  // optional bytes error_describe = 3;
  inline bool has_error_describe() const;
  inline void clear_error_describe();
  static const int kErrorDescribeFieldNumber = 3;
  inline const ::std::string& error_describe() const;
  inline void set_error_describe(const ::std::string& value);
  inline void set_error_describe(const char* value);
  inline void set_error_describe(const void* value, size_t size);
  inline ::std::string* mutable_error_describe();
  inline ::std::string* release_error_describe();
  inline void set_allocated_error_describe(::std::string* error_describe);

  // optional .app.admin.LoginResponse login = 4;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 4;
  inline const ::app::admin::LoginResponse& login() const;
  inline ::app::admin::LoginResponse* mutable_login();
  inline ::app::admin::LoginResponse* release_login();
  inline void set_allocated_login(::app::admin::LoginResponse* login);

  // optional .app.admin.AppendEntityResponse append_entity = 5;
  inline bool has_append_entity() const;
  inline void clear_append_entity();
  static const int kAppendEntityFieldNumber = 5;
  inline const ::app::admin::AppendEntityResponse& append_entity() const;
  inline ::app::admin::AppendEntityResponse* mutable_append_entity();
  inline ::app::admin::AppendEntityResponse* release_append_entity();
  inline void set_allocated_append_entity(::app::admin::AppendEntityResponse* append_entity);

  // optional .app.admin.EntityResponse entity = 6;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 6;
  inline const ::app::admin::EntityResponse& entity() const;
  inline ::app::admin::EntityResponse* mutable_entity();
  inline ::app::admin::EntityResponse* release_entity();
  inline void set_allocated_entity(::app::admin::EntityResponse* entity);

  // optional .app.admin.GetSystemConfigureResponse get_system_configure = 7;
  inline bool has_get_system_configure() const;
  inline void clear_get_system_configure();
  static const int kGetSystemConfigureFieldNumber = 7;
  inline const ::app::admin::GetSystemConfigureResponse& get_system_configure() const;
  inline ::app::admin::GetSystemConfigureResponse* mutable_get_system_configure();
  inline ::app::admin::GetSystemConfigureResponse* release_get_system_configure();
  inline void set_allocated_get_system_configure(::app::admin::GetSystemConfigureResponse* get_system_configure);

  // @@protoc_insertion_point(class_scope:app.admin.Response)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_last_response();
  inline void clear_has_last_response();
  inline void set_has_error_describe();
  inline void clear_has_error_describe();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_append_entity();
  inline void clear_has_append_entity();
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_get_system_configure();
  inline void clear_has_get_system_configure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_describe_;
  ::app::admin::LoginResponse* login_;
  ::app::admin::AppendEntityResponse* append_entity_;
  ::app::admin::EntityResponse* entity_;
  ::app::admin::GetSystemConfigureResponse* get_system_configure_;
  bool result_;
  bool last_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Indication : public ::google::protobuf::Message {
 public:
  Indication();
  virtual ~Indication();

  Indication(const Indication& from);

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Indication& default_instance();

  void Swap(Indication* other);

  // implements Message ----------------------------------------------

  Indication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Indication& from);
  void MergeFrom(const Indication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .app.admin.EntityNotification entity = 1;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::app::admin::EntityNotification& entity() const;
  inline ::app::admin::EntityNotification* mutable_entity();
  inline ::app::admin::EntityNotification* release_entity();
  inline void set_allocated_entity(::app::admin::EntityNotification* entity);

  // @@protoc_insertion_point(class_scope:app.admin.Indication)
 private:
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::app::admin::EntityNotification* entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static Indication* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .app.admin.MSG msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::app::admin::MSG msg_type() const;
  inline void set_msg_type(::app::admin::MSG value);

  // required fixed32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional fixed32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional .app.admin.Request request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::app::admin::Request& request() const;
  inline ::app::admin::Request* mutable_request();
  inline ::app::admin::Request* release_request();
  inline void set_allocated_request(::app::admin::Request* request);

  // optional .app.admin.Response response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline const ::app::admin::Response& response() const;
  inline ::app::admin::Response* mutable_response();
  inline ::app::admin::Response* release_response();
  inline void set_allocated_response(::app::admin::Response* response);

  // optional .app.admin.Indication indication = 6;
  inline bool has_indication() const;
  inline void clear_indication();
  static const int kIndicationFieldNumber = 6;
  inline const ::app::admin::Indication& indication() const;
  inline ::app::admin::Indication* mutable_indication();
  inline ::app::admin::Indication* release_indication();
  inline void set_allocated_indication(::app::admin::Indication* indication);

  // @@protoc_insertion_point(class_scope:app.admin.Message)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_indication();
  inline void clear_has_indication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int msg_type_;
  ::google::protobuf::uint32 sequence_;
  ::app::admin::Request* request_;
  ::app::admin::Response* response_;
  ::app::admin::Indication* indication_;
  ::google::protobuf::uint32 session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_app_2eadmin_2eproto();
  friend void protobuf_AssignDesc_app_2eadmin_2eproto();
  friend void protobuf_ShutdownFile_app_2eadmin_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required bytes username = 1;
inline bool LoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginRequest::username() const {
  return *username_;
}
inline void LoginRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginRequest::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginRequest::password() const {
  return *password_;
}
inline void LoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required fixed32 session_id = 1;
inline bool LoginResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 LoginResponse::session_id() const {
  return session_id_;
}
inline void LoginResponse::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// required .pbmsg.User self = 2;
inline bool LoginResponse::has_self() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_self() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_self() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_self() {
  if (self_ != NULL) self_->::pbmsg::User::Clear();
  clear_has_self();
}
inline const ::pbmsg::User& LoginResponse::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::pbmsg::User* LoginResponse::mutable_self() {
  set_has_self();
  if (self_ == NULL) self_ = new ::pbmsg::User;
  return self_;
}
inline ::pbmsg::User* LoginResponse::release_self() {
  clear_has_self();
  ::pbmsg::User* temp = self_;
  self_ = NULL;
  return temp;
}
inline void LoginResponse::set_allocated_self(::pbmsg::User* self) {
  delete self_;
  self_ = self;
  if (self) {
    set_has_self();
  } else {
    clear_has_self();
  }
}

// required fixed32 ttl = 3;
inline bool LoginResponse::has_ttl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_ttl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_ttl() {
  ttl_ = 0u;
  clear_has_ttl();
}
inline ::google::protobuf::uint32 LoginResponse::ttl() const {
  return ttl_;
}
inline void LoginResponse::set_ttl(::google::protobuf::uint32 value) {
  set_has_ttl();
  ttl_ = value;
}

// -------------------------------------------------------------------

// AppendEntityRequest

// required .pbmsg.EntityData data = 1;
inline bool AppendEntityRequest::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntityRequest::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntityRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntityRequest::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& AppendEntityRequest::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* AppendEntityRequest::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* AppendEntityRequest::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void AppendEntityRequest::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// AppendEntityResponse

// required .pbmsg.EntityData data = 1;
inline bool AppendEntityResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntityResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntityResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntityResponse::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& AppendEntityResponse::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* AppendEntityResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* AppendEntityResponse::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void AppendEntityResponse::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// ModifyEntityRequest

// required .pbmsg.EntityData data = 1;
inline bool ModifyEntityRequest::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyEntityRequest::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyEntityRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyEntityRequest::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& ModifyEntityRequest::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* ModifyEntityRequest::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* ModifyEntityRequest::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void ModifyEntityRequest::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// DeleteEntityRequest

// required .pbmsg.Entity id = 1;
inline bool DeleteEntityRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteEntityRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteEntityRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteEntityRequest::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& DeleteEntityRequest::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* DeleteEntityRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* DeleteEntityRequest::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void DeleteEntityRequest::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// -------------------------------------------------------------------

// EntityRequest

// required .pbmsg.Entity id = 1;
inline bool EntityRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityRequest::clear_id() {
  if (id_ != NULL) id_->::pbmsg::Entity::Clear();
  clear_has_id();
}
inline const ::pbmsg::Entity& EntityRequest::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pbmsg::Entity* EntityRequest::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pbmsg::Entity;
  return id_;
}
inline ::pbmsg::Entity* EntityRequest::release_id() {
  clear_has_id();
  ::pbmsg::Entity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void EntityRequest::set_allocated_id(::pbmsg::Entity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// -------------------------------------------------------------------

// EntityResponse

// required .pbmsg.EntityData data = 1;
inline bool EntityResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityResponse::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& EntityResponse::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* EntityResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* EntityResponse::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void EntityResponse::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// EntityNotification

// required .pbmsg.EntityNotifyType notify_type = 1;
inline bool EntityNotification::has_notify_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityNotification::set_has_notify_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityNotification::clear_has_notify_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityNotification::clear_notify_type() {
  notify_type_ = 0;
  clear_has_notify_type();
}
inline ::pbmsg::EntityNotifyType EntityNotification::notify_type() const {
  return static_cast< ::pbmsg::EntityNotifyType >(notify_type_);
}
inline void EntityNotification::set_notify_type(::pbmsg::EntityNotifyType value) {
  assert(::pbmsg::EntityNotifyType_IsValid(value));
  set_has_notify_type();
  notify_type_ = value;
}

// required .pbmsg.EntityData data = 2;
inline bool EntityNotification::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityNotification::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityNotification::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityNotification::clear_data() {
  if (data_ != NULL) data_->::pbmsg::EntityData::Clear();
  clear_has_data();
}
inline const ::pbmsg::EntityData& EntityNotification::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::pbmsg::EntityData* EntityNotification::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::pbmsg::EntityData;
  return data_;
}
inline ::pbmsg::EntityData* EntityNotification::release_data() {
  clear_has_data();
  ::pbmsg::EntityData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void EntityNotification::set_allocated_data(::pbmsg::EntityData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// GetSystemConfigureResponse

// required .pbmsg.Configure configure = 1;
inline bool GetSystemConfigureResponse::has_configure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSystemConfigureResponse::set_has_configure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSystemConfigureResponse::clear_has_configure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSystemConfigureResponse::clear_configure() {
  if (configure_ != NULL) configure_->::pbmsg::Configure::Clear();
  clear_has_configure();
}
inline const ::pbmsg::Configure& GetSystemConfigureResponse::configure() const {
  return configure_ != NULL ? *configure_ : *default_instance_->configure_;
}
inline ::pbmsg::Configure* GetSystemConfigureResponse::mutable_configure() {
  set_has_configure();
  if (configure_ == NULL) configure_ = new ::pbmsg::Configure;
  return configure_;
}
inline ::pbmsg::Configure* GetSystemConfigureResponse::release_configure() {
  clear_has_configure();
  ::pbmsg::Configure* temp = configure_;
  configure_ = NULL;
  return temp;
}
inline void GetSystemConfigureResponse::set_allocated_configure(::pbmsg::Configure* configure) {
  delete configure_;
  configure_ = configure;
  if (configure) {
    set_has_configure();
  } else {
    clear_has_configure();
  }
}

// -------------------------------------------------------------------

// SetSystemConfigureRequest

// required .pbmsg.Configure configure = 1;
inline bool SetSystemConfigureRequest::has_configure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetSystemConfigureRequest::set_has_configure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetSystemConfigureRequest::clear_has_configure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetSystemConfigureRequest::clear_configure() {
  if (configure_ != NULL) configure_->::pbmsg::Configure::Clear();
  clear_has_configure();
}
inline const ::pbmsg::Configure& SetSystemConfigureRequest::configure() const {
  return configure_ != NULL ? *configure_ : *default_instance_->configure_;
}
inline ::pbmsg::Configure* SetSystemConfigureRequest::mutable_configure() {
  set_has_configure();
  if (configure_ == NULL) configure_ = new ::pbmsg::Configure;
  return configure_;
}
inline ::pbmsg::Configure* SetSystemConfigureRequest::release_configure() {
  clear_has_configure();
  ::pbmsg::Configure* temp = configure_;
  configure_ = NULL;
  return temp;
}
inline void SetSystemConfigureRequest::set_allocated_configure(::pbmsg::Configure* configure) {
  delete configure_;
  configure_ = configure;
  if (configure) {
    set_has_configure();
  } else {
    clear_has_configure();
  }
}

// -------------------------------------------------------------------

// Request

// optional .app.admin.LoginRequest login = 1;
inline bool Request::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_login() {
  if (login_ != NULL) login_->::app::admin::LoginRequest::Clear();
  clear_has_login();
}
inline const ::app::admin::LoginRequest& Request::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::admin::LoginRequest* Request::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::admin::LoginRequest;
  return login_;
}
inline ::app::admin::LoginRequest* Request::release_login() {
  clear_has_login();
  ::app::admin::LoginRequest* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Request::set_allocated_login(::app::admin::LoginRequest* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.admin.AppendEntityRequest append_entity = 2;
inline bool Request::has_append_entity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_append_entity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_append_entity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_append_entity() {
  if (append_entity_ != NULL) append_entity_->::app::admin::AppendEntityRequest::Clear();
  clear_has_append_entity();
}
inline const ::app::admin::AppendEntityRequest& Request::append_entity() const {
  return append_entity_ != NULL ? *append_entity_ : *default_instance_->append_entity_;
}
inline ::app::admin::AppendEntityRequest* Request::mutable_append_entity() {
  set_has_append_entity();
  if (append_entity_ == NULL) append_entity_ = new ::app::admin::AppendEntityRequest;
  return append_entity_;
}
inline ::app::admin::AppendEntityRequest* Request::release_append_entity() {
  clear_has_append_entity();
  ::app::admin::AppendEntityRequest* temp = append_entity_;
  append_entity_ = NULL;
  return temp;
}
inline void Request::set_allocated_append_entity(::app::admin::AppendEntityRequest* append_entity) {
  delete append_entity_;
  append_entity_ = append_entity;
  if (append_entity) {
    set_has_append_entity();
  } else {
    clear_has_append_entity();
  }
}

// optional .app.admin.ModifyEntityRequest modify_entity = 3;
inline bool Request::has_modify_entity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_modify_entity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_modify_entity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_modify_entity() {
  if (modify_entity_ != NULL) modify_entity_->::app::admin::ModifyEntityRequest::Clear();
  clear_has_modify_entity();
}
inline const ::app::admin::ModifyEntityRequest& Request::modify_entity() const {
  return modify_entity_ != NULL ? *modify_entity_ : *default_instance_->modify_entity_;
}
inline ::app::admin::ModifyEntityRequest* Request::mutable_modify_entity() {
  set_has_modify_entity();
  if (modify_entity_ == NULL) modify_entity_ = new ::app::admin::ModifyEntityRequest;
  return modify_entity_;
}
inline ::app::admin::ModifyEntityRequest* Request::release_modify_entity() {
  clear_has_modify_entity();
  ::app::admin::ModifyEntityRequest* temp = modify_entity_;
  modify_entity_ = NULL;
  return temp;
}
inline void Request::set_allocated_modify_entity(::app::admin::ModifyEntityRequest* modify_entity) {
  delete modify_entity_;
  modify_entity_ = modify_entity;
  if (modify_entity) {
    set_has_modify_entity();
  } else {
    clear_has_modify_entity();
  }
}

// optional .app.admin.DeleteEntityRequest delete_entity = 4;
inline bool Request::has_delete_entity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_delete_entity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_delete_entity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_delete_entity() {
  if (delete_entity_ != NULL) delete_entity_->::app::admin::DeleteEntityRequest::Clear();
  clear_has_delete_entity();
}
inline const ::app::admin::DeleteEntityRequest& Request::delete_entity() const {
  return delete_entity_ != NULL ? *delete_entity_ : *default_instance_->delete_entity_;
}
inline ::app::admin::DeleteEntityRequest* Request::mutable_delete_entity() {
  set_has_delete_entity();
  if (delete_entity_ == NULL) delete_entity_ = new ::app::admin::DeleteEntityRequest;
  return delete_entity_;
}
inline ::app::admin::DeleteEntityRequest* Request::release_delete_entity() {
  clear_has_delete_entity();
  ::app::admin::DeleteEntityRequest* temp = delete_entity_;
  delete_entity_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_entity(::app::admin::DeleteEntityRequest* delete_entity) {
  delete delete_entity_;
  delete_entity_ = delete_entity;
  if (delete_entity) {
    set_has_delete_entity();
  } else {
    clear_has_delete_entity();
  }
}

// optional .app.admin.EntityRequest entity = 5;
inline bool Request::has_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_entity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_entity() {
  if (entity_ != NULL) entity_->::app::admin::EntityRequest::Clear();
  clear_has_entity();
}
inline const ::app::admin::EntityRequest& Request::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::admin::EntityRequest* Request::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::admin::EntityRequest;
  return entity_;
}
inline ::app::admin::EntityRequest* Request::release_entity() {
  clear_has_entity();
  ::app::admin::EntityRequest* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Request::set_allocated_entity(::app::admin::EntityRequest* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional .app.admin.SetSystemConfigureRequest set_system_configure = 6;
inline bool Request::has_set_system_configure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_set_system_configure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_set_system_configure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_set_system_configure() {
  if (set_system_configure_ != NULL) set_system_configure_->::app::admin::SetSystemConfigureRequest::Clear();
  clear_has_set_system_configure();
}
inline const ::app::admin::SetSystemConfigureRequest& Request::set_system_configure() const {
  return set_system_configure_ != NULL ? *set_system_configure_ : *default_instance_->set_system_configure_;
}
inline ::app::admin::SetSystemConfigureRequest* Request::mutable_set_system_configure() {
  set_has_set_system_configure();
  if (set_system_configure_ == NULL) set_system_configure_ = new ::app::admin::SetSystemConfigureRequest;
  return set_system_configure_;
}
inline ::app::admin::SetSystemConfigureRequest* Request::release_set_system_configure() {
  clear_has_set_system_configure();
  ::app::admin::SetSystemConfigureRequest* temp = set_system_configure_;
  set_system_configure_ = NULL;
  return temp;
}
inline void Request::set_allocated_set_system_configure(::app::admin::SetSystemConfigureRequest* set_system_configure) {
  delete set_system_configure_;
  set_system_configure_ = set_system_configure;
  if (set_system_configure) {
    set_has_set_system_configure();
  } else {
    clear_has_set_system_configure();
  }
}

// -------------------------------------------------------------------

// Response

// required bool result = 1;
inline bool Response::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool Response::result() const {
  return result_;
}
inline void Response::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required bool last_response = 2;
inline bool Response::has_last_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_last_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_last_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_last_response() {
  last_response_ = false;
  clear_has_last_response();
}
inline bool Response::last_response() const {
  return last_response_;
}
inline void Response::set_last_response(bool value) {
  set_has_last_response();
  last_response_ = value;
}

// optional bytes error_describe = 3;
inline bool Response::has_error_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_error_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_error_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_error_describe() {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    error_describe_->clear();
  }
  clear_has_error_describe();
}
inline const ::std::string& Response::error_describe() const {
  return *error_describe_;
}
inline void Response::set_error_describe(const ::std::string& value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const char* value) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(value);
}
inline void Response::set_error_describe(const void* value, size_t size) {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  error_describe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_error_describe() {
  set_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    error_describe_ = new ::std::string;
  }
  return error_describe_;
}
inline ::std::string* Response::release_error_describe() {
  clear_has_error_describe();
  if (error_describe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_describe_;
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_error_describe(::std::string* error_describe) {
  if (error_describe_ != &::google::protobuf::internal::kEmptyString) {
    delete error_describe_;
  }
  if (error_describe) {
    set_has_error_describe();
    error_describe_ = error_describe;
  } else {
    clear_has_error_describe();
    error_describe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .app.admin.LoginResponse login = 4;
inline bool Response::has_login() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_login() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_login() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_login() {
  if (login_ != NULL) login_->::app::admin::LoginResponse::Clear();
  clear_has_login();
}
inline const ::app::admin::LoginResponse& Response::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::app::admin::LoginResponse* Response::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::app::admin::LoginResponse;
  return login_;
}
inline ::app::admin::LoginResponse* Response::release_login() {
  clear_has_login();
  ::app::admin::LoginResponse* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Response::set_allocated_login(::app::admin::LoginResponse* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .app.admin.AppendEntityResponse append_entity = 5;
inline bool Response::has_append_entity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_append_entity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_append_entity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_append_entity() {
  if (append_entity_ != NULL) append_entity_->::app::admin::AppendEntityResponse::Clear();
  clear_has_append_entity();
}
inline const ::app::admin::AppendEntityResponse& Response::append_entity() const {
  return append_entity_ != NULL ? *append_entity_ : *default_instance_->append_entity_;
}
inline ::app::admin::AppendEntityResponse* Response::mutable_append_entity() {
  set_has_append_entity();
  if (append_entity_ == NULL) append_entity_ = new ::app::admin::AppendEntityResponse;
  return append_entity_;
}
inline ::app::admin::AppendEntityResponse* Response::release_append_entity() {
  clear_has_append_entity();
  ::app::admin::AppendEntityResponse* temp = append_entity_;
  append_entity_ = NULL;
  return temp;
}
inline void Response::set_allocated_append_entity(::app::admin::AppendEntityResponse* append_entity) {
  delete append_entity_;
  append_entity_ = append_entity;
  if (append_entity) {
    set_has_append_entity();
  } else {
    clear_has_append_entity();
  }
}

// optional .app.admin.EntityResponse entity = 6;
inline bool Response::has_entity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_entity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_entity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_entity() {
  if (entity_ != NULL) entity_->::app::admin::EntityResponse::Clear();
  clear_has_entity();
}
inline const ::app::admin::EntityResponse& Response::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::admin::EntityResponse* Response::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::admin::EntityResponse;
  return entity_;
}
inline ::app::admin::EntityResponse* Response::release_entity() {
  clear_has_entity();
  ::app::admin::EntityResponse* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Response::set_allocated_entity(::app::admin::EntityResponse* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional .app.admin.GetSystemConfigureResponse get_system_configure = 7;
inline bool Response::has_get_system_configure() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_get_system_configure() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_get_system_configure() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_get_system_configure() {
  if (get_system_configure_ != NULL) get_system_configure_->::app::admin::GetSystemConfigureResponse::Clear();
  clear_has_get_system_configure();
}
inline const ::app::admin::GetSystemConfigureResponse& Response::get_system_configure() const {
  return get_system_configure_ != NULL ? *get_system_configure_ : *default_instance_->get_system_configure_;
}
inline ::app::admin::GetSystemConfigureResponse* Response::mutable_get_system_configure() {
  set_has_get_system_configure();
  if (get_system_configure_ == NULL) get_system_configure_ = new ::app::admin::GetSystemConfigureResponse;
  return get_system_configure_;
}
inline ::app::admin::GetSystemConfigureResponse* Response::release_get_system_configure() {
  clear_has_get_system_configure();
  ::app::admin::GetSystemConfigureResponse* temp = get_system_configure_;
  get_system_configure_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_system_configure(::app::admin::GetSystemConfigureResponse* get_system_configure) {
  delete get_system_configure_;
  get_system_configure_ = get_system_configure;
  if (get_system_configure) {
    set_has_get_system_configure();
  } else {
    clear_has_get_system_configure();
  }
}

// -------------------------------------------------------------------

// Indication

// optional .app.admin.EntityNotification entity = 1;
inline bool Indication::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Indication::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Indication::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Indication::clear_entity() {
  if (entity_ != NULL) entity_->::app::admin::EntityNotification::Clear();
  clear_has_entity();
}
inline const ::app::admin::EntityNotification& Indication::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::app::admin::EntityNotification* Indication::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::app::admin::EntityNotification;
  return entity_;
}
inline ::app::admin::EntityNotification* Indication::release_entity() {
  clear_has_entity();
  ::app::admin::EntityNotification* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void Indication::set_allocated_entity(::app::admin::EntityNotification* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// -------------------------------------------------------------------

// Message

// required .app.admin.MSG msg_type = 1;
inline bool Message::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msg_type() {
  msg_type_ = 100001;
  clear_has_msg_type();
}
inline ::app::admin::MSG Message::msg_type() const {
  return static_cast< ::app::admin::MSG >(msg_type_);
}
inline void Message::set_msg_type(::app::admin::MSG value) {
  assert(::app::admin::MSG_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// required fixed32 sequence = 2;
inline bool Message::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Message::sequence() const {
  return sequence_;
}
inline void Message::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional fixed32 session_id = 3;
inline bool Message::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 Message::session_id() const {
  return session_id_;
}
inline void Message::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional .app.admin.Request request = 4;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::app::admin::Request::Clear();
  clear_has_request();
}
inline const ::app::admin::Request& Message::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::app::admin::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::app::admin::Request;
  return request_;
}
inline ::app::admin::Request* Message::release_request() {
  clear_has_request();
  ::app::admin::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Message::set_allocated_request(::app::admin::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .app.admin.Response response = 5;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::app::admin::Response::Clear();
  clear_has_response();
}
inline const ::app::admin::Response& Message::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::app::admin::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::app::admin::Response;
  return response_;
}
inline ::app::admin::Response* Message::release_response() {
  clear_has_response();
  ::app::admin::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::app::admin::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .app.admin.Indication indication = 6;
inline bool Message::has_indication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_indication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_indication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_indication() {
  if (indication_ != NULL) indication_->::app::admin::Indication::Clear();
  clear_has_indication();
}
inline const ::app::admin::Indication& Message::indication() const {
  return indication_ != NULL ? *indication_ : *default_instance_->indication_;
}
inline ::app::admin::Indication* Message::mutable_indication() {
  set_has_indication();
  if (indication_ == NULL) indication_ = new ::app::admin::Indication;
  return indication_;
}
inline ::app::admin::Indication* Message::release_indication() {
  clear_has_indication();
  ::app::admin::Indication* temp = indication_;
  indication_ = NULL;
  return temp;
}
inline void Message::set_allocated_indication(::app::admin::Indication* indication) {
  delete indication_;
  indication_ = indication;
  if (indication) {
    set_has_indication();
  } else {
    clear_has_indication();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace admin
}  // namespace app

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::app::admin::MSG>() {
  return ::app::admin::MSG_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_app_2eadmin_2eproto__INCLUDED
