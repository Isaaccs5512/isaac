/* soapC.cpp
   Generated by gSOAP 2.8.17r from webservice.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2014-04-18 02:14:05 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_uint32:
		return soap_in_uint32(soap, NULL, NULL, "uint32");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns__EntityNotifyType:
		return soap_in_ns__EntityNotifyType(soap, NULL, NULL, "ns:EntityNotifyType");
	case SOAP_TYPE_ns__AlertLevel:
		return soap_in_ns__AlertLevel(soap, NULL, NULL, "ns:AlertLevel");
	case SOAP_TYPE_ns__AlertStatus:
		return soap_in_ns__AlertStatus(soap, NULL, NULL, "ns:AlertStatus");
	case SOAP_TYPE_ns__RecordStatus:
		return soap_in_ns__RecordStatus(soap, NULL, NULL, "ns:RecordStatus");
	case SOAP_TYPE_ns__RecordType:
		return soap_in_ns__RecordType(soap, NULL, NULL, "ns:RecordType");
	case SOAP_TYPE_ns__SessionStatus:
		return soap_in_ns__SessionStatus(soap, NULL, NULL, "ns:SessionStatus");
	case SOAP_TYPE_ns__GpsReportMode:
		return soap_in_ns__GpsReportMode(soap, NULL, NULL, "ns:GpsReportMode");
	case SOAP_TYPE_ns__TokenPrivilege:
		return soap_in_ns__TokenPrivilege(soap, NULL, NULL, "ns:TokenPrivilege");
	case SOAP_TYPE_ns__CallPrivilege:
		return soap_in_ns__CallPrivilege(soap, NULL, NULL, "ns:CallPrivilege");
	case SOAP_TYPE_ns__AccountServiceStatus:
		return soap_in_ns__AccountServiceStatus(soap, NULL, NULL, "ns:AccountServiceStatus");
	case SOAP_TYPE_ns__AccountType:
		return soap_in_ns__AccountType(soap, NULL, NULL, "ns:AccountType");
	case SOAP_TYPE_ns__ListModifyType:
		return soap_in_ns__ListModifyType(soap, NULL, NULL, "ns:ListModifyType");
	case SOAP_TYPE_ns__EntityType:
		return soap_in_ns__EntityType(soap, NULL, NULL, "ns:EntityType");
	case SOAP_TYPE_ns__UserType:
		return soap_in_ns__UserType(soap, NULL, NULL, "ns:UserType");
	case SOAP_TYPE_ns__RegisterStatus:
		return soap_in_ns__RegisterStatus(soap, NULL, NULL, "ns:RegisterStatus");
	case SOAP_TYPE_ns__Dispatch_Record_Status:
		return soap_in_ns__Dispatch_Record_Status(soap, NULL, NULL, "ns:Dispatch-Record-Status");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message:
		return soap_in_ns__Dispatch_History_Alert_Message(soap, NULL, NULL, "ns:Dispatch-History-Alert-Message");
	case SOAP_TYPE_ns__HistoryAlert:
		return soap_in_ns__HistoryAlert(soap, NULL, NULL, "ns:HistoryAlert");
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response:
		return soap_in_ns__Dispatch_Account_Location_Notification_Response(soap, NULL, NULL, "ns:Dispatch-Account-Location-Notification-Response");
	case SOAP_TYPE_ns__Session_Status_Notification:
		return soap_in_ns__Session_Status_Notification(soap, NULL, NULL, "ns:Session-Status-Notification");
	case SOAP_TYPE_ns__Participant_Connect_Request_Notification:
		return soap_in_ns__Participant_Connect_Request_Notification(soap, NULL, NULL, "ns:Participant-Connect-Request-Notification");
	case SOAP_TYPE_ns__Media_Message_Notification:
		return soap_in_ns__Media_Message_Notification(soap, NULL, NULL, "ns:Media-Message-Notification");
	case SOAP_TYPE_ns__Media_Message:
		return soap_in_ns__Media_Message(soap, NULL, NULL, "ns:Media-Message");
	case SOAP_TYPE_ns__MediaMessage:
		return soap_in_ns__MediaMessage(soap, NULL, NULL, "ns:MediaMessage");
	case SOAP_TYPE_ns__Participant_Status_Notification:
		return soap_in_ns__Participant_Status_Notification(soap, NULL, NULL, "ns:Participant-Status-Notification");
	case SOAP_TYPE_ns__Join_Group_Request_Nofitication:
		return soap_in_ns__Join_Group_Request_Nofitication(soap, NULL, NULL, "ns:Join-Group-Request-Nofitication");
	case SOAP_TYPE_ns__Modify_Participant:
		return soap_in_ns__Modify_Participant(soap, NULL, NULL, "ns:Modify-Participant");
	case SOAP_TYPE_ns__Entity_Status_Notification:
		return soap_in_ns__Entity_Status_Notification(soap, NULL, NULL, "ns:Entity-Status-Notification");
	case SOAP_TYPE_ns__Entity_Nofitication_Response:
		return soap_in_ns__Entity_Nofitication_Response(soap, NULL, NULL, "ns:Entity-Nofitication-Response");
	case SOAP_TYPE_ns__EntityData:
		return soap_in_ns__EntityData(soap, NULL, NULL, "ns:EntityData");
	case SOAP_TYPE_ns__Organization:
		return soap_in_ns__Organization(soap, NULL, NULL, "ns:Organization");
	case SOAP_TYPE_ns__Alert:
		return soap_in_ns__Alert(soap, NULL, NULL, "ns:Alert");
	case SOAP_TYPE_ns__Gateway:
		return soap_in_ns__Gateway(soap, NULL, NULL, "ns:Gateway");
	case SOAP_TYPE_ns__Group:
		return soap_in_ns__Group(soap, NULL, NULL, "ns:Group");
	case SOAP_TYPE_ns__Participant:
		return soap_in_ns__Participant(soap, NULL, NULL, "ns:Participant");
	case SOAP_TYPE_ns__Unit:
		return soap_in_ns__Unit(soap, NULL, NULL, "ns:Unit");
	case SOAP_TYPE_ns__Login_Response:
		return soap_in_ns__Login_Response(soap, NULL, NULL, "ns:Login-Response");
	case SOAP_TYPE_ns__Account:
		return soap_in_ns__Account(soap, NULL, NULL, "ns:Account");
	case SOAP_TYPE_ns__User:
		return soap_in_ns__User(soap, NULL, NULL, "ns:User");
	case SOAP_TYPE_ns__Address:
		return soap_in_ns__Address(soap, NULL, NULL, "ns:Address");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__Entity:
		return soap_in_ns__Entity(soap, NULL, NULL, "ns:Entity");
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request:
		return soap_in_ns__Dispatch_Delete_History_Alert_Request(soap, NULL, NULL, "ns:Dispatch-Delete-History-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response:
		return soap_in_ns__Dispatch_Delete_History_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Delete-History-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request:
		return soap_in_ns__Dispatch_History_Alert_Message_Request(soap, NULL, NULL, "ns:Dispatch-History-Alert-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Alert_Request:
		return soap_in_ns__Dispatch_Alert_Request(soap, NULL, NULL, "ns:Dispatch-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Request:
		return soap_in_ns__Dispatch_History_Alert_Request(soap, NULL, NULL, "ns:Dispatch-History-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse:
		return soap_in_ns__Dispatch_History_Alert_RequestResponse(soap, NULL, NULL, "ns:Dispatch-History-Alert-RequestResponse");
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification:
		return soap_in_ns__Dispatch_Alert_Overed_Notification(soap, NULL, NULL, "ns:Dispatch-Alert-Overed-Notification");
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response:
		return soap_in_ns__Dispatch_Alert_Overed_Notification_Response(soap, NULL, NULL, "ns:Dispatch-Alert-Overed-Notification-Response");
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request:
		return soap_in_ns__Dispatch_Stop_Alert_Request(soap, NULL, NULL, "ns:Dispatch-Stop-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response:
		return soap_in_ns__Dispatch_Stop_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Stop-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request:
		return soap_in_ns__Dispatch_Modify_Alert_Request(soap, NULL, NULL, "ns:Dispatch-Modify-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response:
		return soap_in_ns__Dispatch_Modify_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Modify-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Append_Alert_Request:
		return soap_in_ns__Dispatch_Append_Alert_Request(soap, NULL, NULL, "ns:Dispatch-Append-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification:
		return soap_in_ns__Dispatch_Account_Location_Notification(soap, NULL, NULL, "ns:Dispatch-Account-Location-Notification");
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request:
		return soap_in_ns__Dispatch_Subscribe_Account_Location_Request(soap, NULL, NULL, "ns:Dispatch-Subscribe-Account-Location-Request");
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response:
		return soap_in_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, NULL, NULL, "ns:Dispatch-Subscribe-Account-Location-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Record_Status_Notification:
		return soap_in_ns__Dispatch_Record_Status_Notification(soap, NULL, NULL, "ns:Dispatch-Record-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request:
		return soap_in_ns__Dispatch_Stop_Record_Request(soap, NULL, NULL, "ns:Dispatch-Stop-Record-Request");
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response:
		return soap_in_ns__Dispatch_Stop_Record_Request_Response(soap, NULL, NULL, "ns:Dispatch-Stop-Record-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request:
		return soap_in_ns__Dispatch_Start_Record_Request(soap, NULL, NULL, "ns:Dispatch-Start-Record-Request");
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response:
		return soap_in_ns__Dispatch_Start_Record_Request_Response(soap, NULL, NULL, "ns:Dispatch-Start-Record-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request:
		return soap_in_ns__Dispatch_Kick_Participant_Request(soap, NULL, NULL, "ns:Dispatch-Kick-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response:
		return soap_in_ns__Dispatch_Kick_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Kick-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request:
		return soap_in_ns__Dispatch_Send_Message_Request(soap, NULL, NULL, "ns:Dispatch-Send-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response:
		return soap_in_ns__Dispatch_Send_Message_Request_Response(soap, NULL, NULL, "ns:Dispatch-Send-Message-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Session_Status_Notification:
		return soap_in_ns__Dispatch_Session_Status_Notification(soap, NULL, NULL, "ns:Dispatch-Session-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request:
		return soap_in_ns__Dispatch_Leave_Group_Request(soap, NULL, NULL, "ns:Dispatch-Leave-Group-Request");
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response:
		return soap_in_ns__Dispatch_Leave_Group_Request_Response(soap, NULL, NULL, "ns:Dispatch-Leave-Group-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request:
		return soap_in_ns__Dispatch_Jion_Group_Request(soap, NULL, NULL, "ns:Dispatch-Jion-Group-Request");
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response:
		return soap_in_ns__Dispatch_Jion_Group_Request_Response(soap, NULL, NULL, "ns:Dispatch-Jion-Group-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request:
		return soap_in_ns__Dispatch_Appoint_Participant_Speak_Request(soap, NULL, NULL, "ns:Dispatch-Appoint-Participant-Speak-Request");
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response:
		return soap_in_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, NULL, NULL, "ns:Dispatch-Appoint-Participant-Speak-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request:
		return soap_in_ns__Dispatch_Release_Participant_Token_Request(soap, NULL, NULL, "ns:Dispatch-Release-Participant-Token-Request");
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response:
		return soap_in_ns__Dispatch_Release_Participant_Token_Request_Response(soap, NULL, NULL, "ns:Dispatch-Release-Participant-Token-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request:
		return soap_in_ns__Dispatch_Drop_Participant_Request(soap, NULL, NULL, "ns:Dispatch-Drop-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response:
		return soap_in_ns__Dispatch_Drop_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Drop-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request:
		return soap_in_ns__Dispatch_Invite_Participant_Request(soap, NULL, NULL, "ns:Dispatch-Invite-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response:
		return soap_in_ns__Dispatch_Invite_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Invite-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification:
		return soap_in_ns__Dispatch_Participant_Speak_Request_Notification(soap, NULL, NULL, "ns:Dispatch-Participant-Speak-Request-Notification");
	case SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification:
		return soap_in_ns__Dispatch_Participant_Connect_Request_Notification(soap, NULL, NULL, "ns:Dispatch-Participant-Connect-Request-Notification");
	case SOAP_TYPE_ns__Dispatch_Media_Message_Notification:
		return soap_in_ns__Dispatch_Media_Message_Notification(soap, NULL, NULL, "ns:Dispatch-Media-Message-Notification");
	case SOAP_TYPE_ns__Dispatch_Media_Message_Request:
		return soap_in_ns__Dispatch_Media_Message_Request(soap, NULL, NULL, "ns:Dispatch-Media-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Participant_Status_Notification:
		return soap_in_ns__Dispatch_Participant_Status_Notification(soap, NULL, NULL, "ns:Dispatch-Participant-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication:
		return soap_in_ns__Dispatch_Join_Group_Request_Nofitication(soap, NULL, NULL, "ns:Dispatch-Join-Group-Request-Nofitication");
	case SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification:
		return soap_in_ns__Dispatch_Dispatch_Participants_Notification(soap, NULL, NULL, "ns:Dispatch-Dispatch-Participants-Notification");
	case SOAP_TYPE_ns__Dispatch_Delete_Group:
		return soap_in_ns__Dispatch_Delete_Group(soap, NULL, NULL, "ns:Dispatch-Delete-Group");
	case SOAP_TYPE_ns__Delete_Group_Response:
		return soap_in_ns__Delete_Group_Response(soap, NULL, NULL, "ns:Delete-Group-Response");
	case SOAP_TYPE_ns__Dispatch_Modify_Participants:
		return soap_in_ns__Dispatch_Modify_Participants(soap, NULL, NULL, "ns:Dispatch-Modify-Participants");
	case SOAP_TYPE_ns__Dispatch_Modify_Group:
		return soap_in_ns__Dispatch_Modify_Group(soap, NULL, NULL, "ns:Dispatch-Modify-Group");
	case SOAP_TYPE_ns__Dispatch_Append_Group:
		return soap_in_ns__Dispatch_Append_Group(soap, NULL, NULL, "ns:Dispatch-Append-Group");
	case SOAP_TYPE_ns__Dispatch_Entity_Status_Notification:
		return soap_in_ns__Dispatch_Entity_Status_Notification(soap, NULL, NULL, "ns:Dispatch-Entity-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Entity_Nofitication:
		return soap_in_ns__Dispatch_Entity_Nofitication(soap, NULL, NULL, "ns:Dispatch-Entity-Nofitication");
	case SOAP_TYPE_ns__Dispatch_Entity_Request:
		return soap_in_ns__Dispatch_Entity_Request(soap, NULL, NULL, "ns:Dispatch-Entity-Request");
	case SOAP_TYPE_ns__Dispatch_Keepalive:
		return soap_in_ns__Dispatch_Keepalive(soap, NULL, NULL, "ns:Dispatch-Keepalive");
	case SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response:
		return soap_in_ns__Dispatch_Keepalive_Request_Response(soap, NULL, NULL, "ns:Dispatch-Keepalive-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Logout:
		return soap_in_ns__Dispatch_Logout(soap, NULL, NULL, "ns:Dispatch-Logout");
	case SOAP_TYPE_ns__LogOutResponse:
		return soap_in_ns__LogOutResponse(soap, NULL, NULL, "ns:LogOutResponse");
	case SOAP_TYPE_ns__Dispatch_Login:
		return soap_in_ns__Dispatch_Login(soap, NULL, NULL, "ns:Dispatch-Login");
	case SOAP_TYPE_PointerTons__Dispatch_Delete_History_Alert_Request_Response:
		return soap_in_PointerTons__Dispatch_Delete_History_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Delete-History-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Alert_Overed_Notification_Response:
		return soap_in_PointerTons__Dispatch_Alert_Overed_Notification_Response(soap, NULL, NULL, "ns:Dispatch-Alert-Overed-Notification-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Alert_Request_Response:
		return soap_in_PointerTons__Dispatch_Stop_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Stop-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Modify_Alert_Request_Response:
		return soap_in_PointerTons__Dispatch_Modify_Alert_Request_Response(soap, NULL, NULL, "ns:Dispatch-Modify-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response:
		return soap_in_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(soap, NULL, NULL, "ns:Dispatch-Subscribe-Account-Location-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Record_Request_Response:
		return soap_in_PointerTons__Dispatch_Stop_Record_Request_Response(soap, NULL, NULL, "ns:Dispatch-Stop-Record-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Start_Record_Request_Response:
		return soap_in_PointerTons__Dispatch_Start_Record_Request_Response(soap, NULL, NULL, "ns:Dispatch-Start-Record-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Kick_Participant_Request_Response:
		return soap_in_PointerTons__Dispatch_Kick_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Kick-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Send_Message_Request_Response:
		return soap_in_PointerTons__Dispatch_Send_Message_Request_Response(soap, NULL, NULL, "ns:Dispatch-Send-Message-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Leave_Group_Request_Response:
		return soap_in_PointerTons__Dispatch_Leave_Group_Request_Response(soap, NULL, NULL, "ns:Dispatch-Leave-Group-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Jion_Group_Request_Response:
		return soap_in_PointerTons__Dispatch_Jion_Group_Request_Response(soap, NULL, NULL, "ns:Dispatch-Jion-Group-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response:
		return soap_in_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(soap, NULL, NULL, "ns:Dispatch-Appoint-Participant-Speak-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Release_Participant_Token_Request_Response:
		return soap_in_PointerTons__Dispatch_Release_Participant_Token_Request_Response(soap, NULL, NULL, "ns:Dispatch-Release-Participant-Token-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Drop_Participant_Request_Response:
		return soap_in_PointerTons__Dispatch_Drop_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Drop-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Invite_Participant_Request_Response:
		return soap_in_PointerTons__Dispatch_Invite_Participant_Request_Response(soap, NULL, NULL, "ns:Dispatch-Invite-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Delete_Group_Response:
		return soap_in_PointerTons__Delete_Group_Response(soap, NULL, NULL, "ns:Delete-Group-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Keepalive_Request_Response:
		return soap_in_PointerTons__Dispatch_Keepalive_Request_Response(soap, NULL, NULL, "ns:Dispatch-Keepalive-Request-Response");
	case SOAP_TYPE_PointerTons__LogOutResponse:
		return soap_in_PointerTons__LogOutResponse(soap, NULL, NULL, "ns:LogOutResponse");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns:Dispatch-Record-Status"))
		{	*type = SOAP_TYPE_ns__Dispatch_Record_Status;
			return soap_in_ns__Dispatch_Record_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-History-Alert-Message"))
		{	*type = SOAP_TYPE_ns__Dispatch_History_Alert_Message;
			return soap_in_ns__Dispatch_History_Alert_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:HistoryAlert"))
		{	*type = SOAP_TYPE_ns__HistoryAlert;
			return soap_in_ns__HistoryAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Account-Location-Notification-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response;
			return soap_in_ns__Dispatch_Account_Location_Notification_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Session-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Session_Status_Notification;
			return soap_in_ns__Session_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Participant-Connect-Request-Notification"))
		{	*type = SOAP_TYPE_ns__Participant_Connect_Request_Notification;
			return soap_in_ns__Participant_Connect_Request_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Media-Message-Notification"))
		{	*type = SOAP_TYPE_ns__Media_Message_Notification;
			return soap_in_ns__Media_Message_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Media-Message"))
		{	*type = SOAP_TYPE_ns__Media_Message;
			return soap_in_ns__Media_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:MediaMessage"))
		{	*type = SOAP_TYPE_ns__MediaMessage;
			return soap_in_ns__MediaMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Participant-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Participant_Status_Notification;
			return soap_in_ns__Participant_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Join-Group-Request-Nofitication"))
		{	*type = SOAP_TYPE_ns__Join_Group_Request_Nofitication;
			return soap_in_ns__Join_Group_Request_Nofitication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Modify-Participant"))
		{	*type = SOAP_TYPE_ns__Modify_Participant;
			return soap_in_ns__Modify_Participant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Entity-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Entity_Status_Notification;
			return soap_in_ns__Entity_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Entity-Nofitication-Response"))
		{	*type = SOAP_TYPE_ns__Entity_Nofitication_Response;
			return soap_in_ns__Entity_Nofitication_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:EntityData"))
		{	*type = SOAP_TYPE_ns__EntityData;
			return soap_in_ns__EntityData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Organization"))
		{	*type = SOAP_TYPE_ns__Organization;
			return soap_in_ns__Organization(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Alert"))
		{	*type = SOAP_TYPE_ns__Alert;
			return soap_in_ns__Alert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Gateway"))
		{	*type = SOAP_TYPE_ns__Gateway;
			return soap_in_ns__Gateway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Group"))
		{	*type = SOAP_TYPE_ns__Group;
			return soap_in_ns__Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Participant"))
		{	*type = SOAP_TYPE_ns__Participant;
			return soap_in_ns__Participant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Unit"))
		{	*type = SOAP_TYPE_ns__Unit;
			return soap_in_ns__Unit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Login-Response"))
		{	*type = SOAP_TYPE_ns__Login_Response;
			return soap_in_ns__Login_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Account"))
		{	*type = SOAP_TYPE_ns__Account;
			return soap_in_ns__Account(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:User"))
		{	*type = SOAP_TYPE_ns__User;
			return soap_in_ns__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Address"))
		{	*type = SOAP_TYPE_ns__Address;
			return soap_in_ns__Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Entity"))
		{	*type = SOAP_TYPE_ns__Entity;
			return soap_in_ns__Entity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uint32"))
		{	*type = SOAP_TYPE_uint32;
			return soap_in_uint32(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:EntityNotifyType"))
		{	*type = SOAP_TYPE_ns__EntityNotifyType;
			return soap_in_ns__EntityNotifyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AlertLevel"))
		{	*type = SOAP_TYPE_ns__AlertLevel;
			return soap_in_ns__AlertLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AlertStatus"))
		{	*type = SOAP_TYPE_ns__AlertStatus;
			return soap_in_ns__AlertStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:RecordStatus"))
		{	*type = SOAP_TYPE_ns__RecordStatus;
			return soap_in_ns__RecordStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:RecordType"))
		{	*type = SOAP_TYPE_ns__RecordType;
			return soap_in_ns__RecordType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SessionStatus"))
		{	*type = SOAP_TYPE_ns__SessionStatus;
			return soap_in_ns__SessionStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GpsReportMode"))
		{	*type = SOAP_TYPE_ns__GpsReportMode;
			return soap_in_ns__GpsReportMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:TokenPrivilege"))
		{	*type = SOAP_TYPE_ns__TokenPrivilege;
			return soap_in_ns__TokenPrivilege(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:CallPrivilege"))
		{	*type = SOAP_TYPE_ns__CallPrivilege;
			return soap_in_ns__CallPrivilege(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AccountServiceStatus"))
		{	*type = SOAP_TYPE_ns__AccountServiceStatus;
			return soap_in_ns__AccountServiceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AccountType"))
		{	*type = SOAP_TYPE_ns__AccountType;
			return soap_in_ns__AccountType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ListModifyType"))
		{	*type = SOAP_TYPE_ns__ListModifyType;
			return soap_in_ns__ListModifyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:EntityType"))
		{	*type = SOAP_TYPE_ns__EntityType;
			return soap_in_ns__EntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserType"))
		{	*type = SOAP_TYPE_ns__UserType;
			return soap_in_ns__UserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:RegisterStatus"))
		{	*type = SOAP_TYPE_ns__RegisterStatus;
			return soap_in_ns__RegisterStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Delete-History-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request;
			return soap_in_ns__Dispatch_Delete_History_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Delete-History-Alert-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response;
			return soap_in_ns__Dispatch_Delete_History_Alert_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-History-Alert-Message-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request;
			return soap_in_ns__Dispatch_History_Alert_Message_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Alert_Request;
			return soap_in_ns__Dispatch_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-History-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_History_Alert_Request;
			return soap_in_ns__Dispatch_History_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-History-Alert-RequestResponse"))
		{	*type = SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse;
			return soap_in_ns__Dispatch_History_Alert_RequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Alert-Overed-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification;
			return soap_in_ns__Dispatch_Alert_Overed_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Alert-Overed-Notification-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response;
			return soap_in_ns__Dispatch_Alert_Overed_Notification_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Stop-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Stop_Alert_Request;
			return soap_in_ns__Dispatch_Stop_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Stop-Alert-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response;
			return soap_in_ns__Dispatch_Stop_Alert_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Modify-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Modify_Alert_Request;
			return soap_in_ns__Dispatch_Modify_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Modify-Alert-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response;
			return soap_in_ns__Dispatch_Modify_Alert_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Append-Alert-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Append_Alert_Request;
			return soap_in_ns__Dispatch_Append_Alert_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Account-Location-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Account_Location_Notification;
			return soap_in_ns__Dispatch_Account_Location_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Subscribe-Account-Location-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request;
			return soap_in_ns__Dispatch_Subscribe_Account_Location_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Subscribe-Account-Location-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response;
			return soap_in_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Record-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Record_Status_Notification;
			return soap_in_ns__Dispatch_Record_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Stop-Record-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Stop_Record_Request;
			return soap_in_ns__Dispatch_Stop_Record_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Stop-Record-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response;
			return soap_in_ns__Dispatch_Stop_Record_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Start-Record-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Start_Record_Request;
			return soap_in_ns__Dispatch_Start_Record_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Start-Record-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response;
			return soap_in_ns__Dispatch_Start_Record_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Kick-Participant-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Kick_Participant_Request;
			return soap_in_ns__Dispatch_Kick_Participant_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Kick-Participant-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response;
			return soap_in_ns__Dispatch_Kick_Participant_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Send-Message-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Send_Message_Request;
			return soap_in_ns__Dispatch_Send_Message_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Send-Message-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response;
			return soap_in_ns__Dispatch_Send_Message_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Session-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Session_Status_Notification;
			return soap_in_ns__Dispatch_Session_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Leave-Group-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Leave_Group_Request;
			return soap_in_ns__Dispatch_Leave_Group_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Leave-Group-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response;
			return soap_in_ns__Dispatch_Leave_Group_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Jion-Group-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Jion_Group_Request;
			return soap_in_ns__Dispatch_Jion_Group_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Jion-Group-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response;
			return soap_in_ns__Dispatch_Jion_Group_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Appoint-Participant-Speak-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request;
			return soap_in_ns__Dispatch_Appoint_Participant_Speak_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Appoint-Participant-Speak-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response;
			return soap_in_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Release-Participant-Token-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request;
			return soap_in_ns__Dispatch_Release_Participant_Token_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Release-Participant-Token-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response;
			return soap_in_ns__Dispatch_Release_Participant_Token_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Drop-Participant-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Drop_Participant_Request;
			return soap_in_ns__Dispatch_Drop_Participant_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Drop-Participant-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response;
			return soap_in_ns__Dispatch_Drop_Participant_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Invite-Participant-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Invite_Participant_Request;
			return soap_in_ns__Dispatch_Invite_Participant_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Invite-Participant-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response;
			return soap_in_ns__Dispatch_Invite_Participant_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Participant-Speak-Request-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification;
			return soap_in_ns__Dispatch_Participant_Speak_Request_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Participant-Connect-Request-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification;
			return soap_in_ns__Dispatch_Participant_Connect_Request_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Media-Message-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Media_Message_Notification;
			return soap_in_ns__Dispatch_Media_Message_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Media-Message-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Media_Message_Request;
			return soap_in_ns__Dispatch_Media_Message_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Participant-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Participant_Status_Notification;
			return soap_in_ns__Dispatch_Participant_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Join-Group-Request-Nofitication"))
		{	*type = SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication;
			return soap_in_ns__Dispatch_Join_Group_Request_Nofitication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Dispatch-Participants-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification;
			return soap_in_ns__Dispatch_Dispatch_Participants_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Delete-Group"))
		{	*type = SOAP_TYPE_ns__Dispatch_Delete_Group;
			return soap_in_ns__Dispatch_Delete_Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Delete-Group-Response"))
		{	*type = SOAP_TYPE_ns__Delete_Group_Response;
			return soap_in_ns__Delete_Group_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Modify-Participants"))
		{	*type = SOAP_TYPE_ns__Dispatch_Modify_Participants;
			return soap_in_ns__Dispatch_Modify_Participants(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Modify-Group"))
		{	*type = SOAP_TYPE_ns__Dispatch_Modify_Group;
			return soap_in_ns__Dispatch_Modify_Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Append-Group"))
		{	*type = SOAP_TYPE_ns__Dispatch_Append_Group;
			return soap_in_ns__Dispatch_Append_Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Entity-Status-Notification"))
		{	*type = SOAP_TYPE_ns__Dispatch_Entity_Status_Notification;
			return soap_in_ns__Dispatch_Entity_Status_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Entity-Nofitication"))
		{	*type = SOAP_TYPE_ns__Dispatch_Entity_Nofitication;
			return soap_in_ns__Dispatch_Entity_Nofitication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Entity-Request"))
		{	*type = SOAP_TYPE_ns__Dispatch_Entity_Request;
			return soap_in_ns__Dispatch_Entity_Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Keepalive"))
		{	*type = SOAP_TYPE_ns__Dispatch_Keepalive;
			return soap_in_ns__Dispatch_Keepalive(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Keepalive-Request-Response"))
		{	*type = SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response;
			return soap_in_ns__Dispatch_Keepalive_Request_Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Logout"))
		{	*type = SOAP_TYPE_ns__Dispatch_Logout;
			return soap_in_ns__Dispatch_Logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:LogOutResponse"))
		{	*type = SOAP_TYPE_ns__LogOutResponse;
			return soap_in_ns__LogOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Dispatch-Login"))
		{	*type = SOAP_TYPE_ns__Dispatch_Login;
			return soap_in_ns__Dispatch_Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_uint32:
		return soap_out_uint32(soap, tag, id, (const unsigned long *)ptr, "uint32");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns__EntityNotifyType:
		return soap_out_ns__EntityNotifyType(soap, tag, id, (const enum ns__EntityNotifyType *)ptr, "ns:EntityNotifyType");
	case SOAP_TYPE_ns__AlertLevel:
		return soap_out_ns__AlertLevel(soap, tag, id, (const enum ns__AlertLevel *)ptr, "ns:AlertLevel");
	case SOAP_TYPE_ns__AlertStatus:
		return soap_out_ns__AlertStatus(soap, tag, id, (const enum ns__AlertStatus *)ptr, "ns:AlertStatus");
	case SOAP_TYPE_ns__RecordStatus:
		return soap_out_ns__RecordStatus(soap, tag, id, (const enum ns__RecordStatus *)ptr, "ns:RecordStatus");
	case SOAP_TYPE_ns__RecordType:
		return soap_out_ns__RecordType(soap, tag, id, (const enum ns__RecordType *)ptr, "ns:RecordType");
	case SOAP_TYPE_ns__SessionStatus:
		return soap_out_ns__SessionStatus(soap, tag, id, (const enum ns__SessionStatus *)ptr, "ns:SessionStatus");
	case SOAP_TYPE_ns__GpsReportMode:
		return soap_out_ns__GpsReportMode(soap, tag, id, (const enum ns__GpsReportMode *)ptr, "ns:GpsReportMode");
	case SOAP_TYPE_ns__TokenPrivilege:
		return soap_out_ns__TokenPrivilege(soap, tag, id, (const enum ns__TokenPrivilege *)ptr, "ns:TokenPrivilege");
	case SOAP_TYPE_ns__CallPrivilege:
		return soap_out_ns__CallPrivilege(soap, tag, id, (const enum ns__CallPrivilege *)ptr, "ns:CallPrivilege");
	case SOAP_TYPE_ns__AccountServiceStatus:
		return soap_out_ns__AccountServiceStatus(soap, tag, id, (const enum ns__AccountServiceStatus *)ptr, "ns:AccountServiceStatus");
	case SOAP_TYPE_ns__AccountType:
		return soap_out_ns__AccountType(soap, tag, id, (const enum ns__AccountType *)ptr, "ns:AccountType");
	case SOAP_TYPE_ns__ListModifyType:
		return soap_out_ns__ListModifyType(soap, tag, id, (const enum ns__ListModifyType *)ptr, "ns:ListModifyType");
	case SOAP_TYPE_ns__EntityType:
		return soap_out_ns__EntityType(soap, tag, id, (const enum ns__EntityType *)ptr, "ns:EntityType");
	case SOAP_TYPE_ns__UserType:
		return soap_out_ns__UserType(soap, tag, id, (const enum ns__UserType *)ptr, "ns:UserType");
	case SOAP_TYPE_ns__RegisterStatus:
		return soap_out_ns__RegisterStatus(soap, tag, id, (const enum ns__RegisterStatus *)ptr, "ns:RegisterStatus");
	case SOAP_TYPE_ns__Dispatch_Record_Status:
		return ((ns__Dispatch_Record_Status *)ptr)->soap_out(soap, tag, id, "ns:Dispatch-Record-Status");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message:
		return ((ns__Dispatch_History_Alert_Message *)ptr)->soap_out(soap, tag, id, "ns:Dispatch-History-Alert-Message");
	case SOAP_TYPE_ns__HistoryAlert:
		return ((ns__HistoryAlert *)ptr)->soap_out(soap, tag, id, "ns:HistoryAlert");
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response:
		return ((ns__Dispatch_Account_Location_Notification_Response *)ptr)->soap_out(soap, tag, id, "ns:Dispatch-Account-Location-Notification-Response");
	case SOAP_TYPE_ns__Session_Status_Notification:
		return ((ns__Session_Status_Notification *)ptr)->soap_out(soap, tag, id, "ns:Session-Status-Notification");
	case SOAP_TYPE_ns__Participant_Connect_Request_Notification:
		return ((ns__Participant_Connect_Request_Notification *)ptr)->soap_out(soap, tag, id, "ns:Participant-Connect-Request-Notification");
	case SOAP_TYPE_ns__Media_Message_Notification:
		return ((ns__Media_Message_Notification *)ptr)->soap_out(soap, tag, id, "ns:Media-Message-Notification");
	case SOAP_TYPE_ns__Media_Message:
		return ((ns__Media_Message *)ptr)->soap_out(soap, tag, id, "ns:Media-Message");
	case SOAP_TYPE_ns__MediaMessage:
		return ((ns__MediaMessage *)ptr)->soap_out(soap, tag, id, "ns:MediaMessage");
	case SOAP_TYPE_ns__Participant_Status_Notification:
		return ((ns__Participant_Status_Notification *)ptr)->soap_out(soap, tag, id, "ns:Participant-Status-Notification");
	case SOAP_TYPE_ns__Join_Group_Request_Nofitication:
		return ((ns__Join_Group_Request_Nofitication *)ptr)->soap_out(soap, tag, id, "ns:Join-Group-Request-Nofitication");
	case SOAP_TYPE_ns__Modify_Participant:
		return ((ns__Modify_Participant *)ptr)->soap_out(soap, tag, id, "ns:Modify-Participant");
	case SOAP_TYPE_ns__Entity_Status_Notification:
		return ((ns__Entity_Status_Notification *)ptr)->soap_out(soap, tag, id, "ns:Entity-Status-Notification");
	case SOAP_TYPE_ns__Entity_Nofitication_Response:
		return ((ns__Entity_Nofitication_Response *)ptr)->soap_out(soap, tag, id, "ns:Entity-Nofitication-Response");
	case SOAP_TYPE_ns__EntityData:
		return ((ns__EntityData *)ptr)->soap_out(soap, tag, id, "ns:EntityData");
	case SOAP_TYPE_ns__Organization:
		return ((ns__Organization *)ptr)->soap_out(soap, tag, id, "ns:Organization");
	case SOAP_TYPE_ns__Alert:
		return ((ns__Alert *)ptr)->soap_out(soap, tag, id, "ns:Alert");
	case SOAP_TYPE_ns__Gateway:
		return ((ns__Gateway *)ptr)->soap_out(soap, tag, id, "ns:Gateway");
	case SOAP_TYPE_ns__Group:
		return ((ns__Group *)ptr)->soap_out(soap, tag, id, "ns:Group");
	case SOAP_TYPE_ns__Participant:
		return ((ns__Participant *)ptr)->soap_out(soap, tag, id, "ns:Participant");
	case SOAP_TYPE_ns__Unit:
		return ((ns__Unit *)ptr)->soap_out(soap, tag, id, "ns:Unit");
	case SOAP_TYPE_ns__Login_Response:
		return ((ns__Login_Response *)ptr)->soap_out(soap, tag, id, "ns:Login-Response");
	case SOAP_TYPE_ns__Account:
		return ((ns__Account *)ptr)->soap_out(soap, tag, id, "ns:Account");
	case SOAP_TYPE_ns__User:
		return ((ns__User *)ptr)->soap_out(soap, tag, id, "ns:User");
	case SOAP_TYPE_ns__Address:
		return ((ns__Address *)ptr)->soap_out(soap, tag, id, "ns:Address");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__Entity:
		return ((ns__Entity *)ptr)->soap_out(soap, tag, id, "ns:Entity");
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request:
		return soap_out_ns__Dispatch_Delete_History_Alert_Request(soap, tag, id, (const struct ns__Dispatch_Delete_History_Alert_Request *)ptr, "ns:Dispatch-Delete-History-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response:
		return soap_out_ns__Dispatch_Delete_History_Alert_Request_Response(soap, tag, id, (const struct ns__Dispatch_Delete_History_Alert_Request_Response *)ptr, "ns:Dispatch-Delete-History-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request:
		return soap_out_ns__Dispatch_History_Alert_Message_Request(soap, tag, id, (const struct ns__Dispatch_History_Alert_Message_Request *)ptr, "ns:Dispatch-History-Alert-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Alert_Request:
		return soap_out_ns__Dispatch_Alert_Request(soap, tag, id, (const struct ns__Dispatch_Alert_Request *)ptr, "ns:Dispatch-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_History_Alert_Request:
		return soap_out_ns__Dispatch_History_Alert_Request(soap, tag, id, (const struct ns__Dispatch_History_Alert_Request *)ptr, "ns:Dispatch-History-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse:
		return soap_out_ns__Dispatch_History_Alert_RequestResponse(soap, tag, id, (const struct ns__Dispatch_History_Alert_RequestResponse *)ptr, "ns:Dispatch-History-Alert-RequestResponse");
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification:
		return soap_out_ns__Dispatch_Alert_Overed_Notification(soap, tag, id, (const struct ns__Dispatch_Alert_Overed_Notification *)ptr, "ns:Dispatch-Alert-Overed-Notification");
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response:
		return soap_out_ns__Dispatch_Alert_Overed_Notification_Response(soap, tag, id, (const struct ns__Dispatch_Alert_Overed_Notification_Response *)ptr, "ns:Dispatch-Alert-Overed-Notification-Response");
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request:
		return soap_out_ns__Dispatch_Stop_Alert_Request(soap, tag, id, (const struct ns__Dispatch_Stop_Alert_Request *)ptr, "ns:Dispatch-Stop-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response:
		return soap_out_ns__Dispatch_Stop_Alert_Request_Response(soap, tag, id, (const struct ns__Dispatch_Stop_Alert_Request_Response *)ptr, "ns:Dispatch-Stop-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request:
		return soap_out_ns__Dispatch_Modify_Alert_Request(soap, tag, id, (const struct ns__Dispatch_Modify_Alert_Request *)ptr, "ns:Dispatch-Modify-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response:
		return soap_out_ns__Dispatch_Modify_Alert_Request_Response(soap, tag, id, (const struct ns__Dispatch_Modify_Alert_Request_Response *)ptr, "ns:Dispatch-Modify-Alert-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Append_Alert_Request:
		return soap_out_ns__Dispatch_Append_Alert_Request(soap, tag, id, (const struct ns__Dispatch_Append_Alert_Request *)ptr, "ns:Dispatch-Append-Alert-Request");
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification:
		return soap_out_ns__Dispatch_Account_Location_Notification(soap, tag, id, (const struct ns__Dispatch_Account_Location_Notification *)ptr, "ns:Dispatch-Account-Location-Notification");
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request:
		return soap_out_ns__Dispatch_Subscribe_Account_Location_Request(soap, tag, id, (const struct ns__Dispatch_Subscribe_Account_Location_Request *)ptr, "ns:Dispatch-Subscribe-Account-Location-Request");
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response:
		return soap_out_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, id, (const struct ns__Dispatch_Subscribe_Account_Location_Request_Response *)ptr, "ns:Dispatch-Subscribe-Account-Location-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Record_Status_Notification:
		return soap_out_ns__Dispatch_Record_Status_Notification(soap, tag, id, (const struct ns__Dispatch_Record_Status_Notification *)ptr, "ns:Dispatch-Record-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request:
		return soap_out_ns__Dispatch_Stop_Record_Request(soap, tag, id, (const struct ns__Dispatch_Stop_Record_Request *)ptr, "ns:Dispatch-Stop-Record-Request");
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response:
		return soap_out_ns__Dispatch_Stop_Record_Request_Response(soap, tag, id, (const struct ns__Dispatch_Stop_Record_Request_Response *)ptr, "ns:Dispatch-Stop-Record-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request:
		return soap_out_ns__Dispatch_Start_Record_Request(soap, tag, id, (const struct ns__Dispatch_Start_Record_Request *)ptr, "ns:Dispatch-Start-Record-Request");
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response:
		return soap_out_ns__Dispatch_Start_Record_Request_Response(soap, tag, id, (const struct ns__Dispatch_Start_Record_Request_Response *)ptr, "ns:Dispatch-Start-Record-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request:
		return soap_out_ns__Dispatch_Kick_Participant_Request(soap, tag, id, (const struct ns__Dispatch_Kick_Participant_Request *)ptr, "ns:Dispatch-Kick-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response:
		return soap_out_ns__Dispatch_Kick_Participant_Request_Response(soap, tag, id, (const struct ns__Dispatch_Kick_Participant_Request_Response *)ptr, "ns:Dispatch-Kick-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request:
		return soap_out_ns__Dispatch_Send_Message_Request(soap, tag, id, (const struct ns__Dispatch_Send_Message_Request *)ptr, "ns:Dispatch-Send-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response:
		return soap_out_ns__Dispatch_Send_Message_Request_Response(soap, tag, id, (const struct ns__Dispatch_Send_Message_Request_Response *)ptr, "ns:Dispatch-Send-Message-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Session_Status_Notification:
		return soap_out_ns__Dispatch_Session_Status_Notification(soap, tag, id, (const struct ns__Dispatch_Session_Status_Notification *)ptr, "ns:Dispatch-Session-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request:
		return soap_out_ns__Dispatch_Leave_Group_Request(soap, tag, id, (const struct ns__Dispatch_Leave_Group_Request *)ptr, "ns:Dispatch-Leave-Group-Request");
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response:
		return soap_out_ns__Dispatch_Leave_Group_Request_Response(soap, tag, id, (const struct ns__Dispatch_Leave_Group_Request_Response *)ptr, "ns:Dispatch-Leave-Group-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request:
		return soap_out_ns__Dispatch_Jion_Group_Request(soap, tag, id, (const struct ns__Dispatch_Jion_Group_Request *)ptr, "ns:Dispatch-Jion-Group-Request");
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response:
		return soap_out_ns__Dispatch_Jion_Group_Request_Response(soap, tag, id, (const struct ns__Dispatch_Jion_Group_Request_Response *)ptr, "ns:Dispatch-Jion-Group-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request:
		return soap_out_ns__Dispatch_Appoint_Participant_Speak_Request(soap, tag, id, (const struct ns__Dispatch_Appoint_Participant_Speak_Request *)ptr, "ns:Dispatch-Appoint-Participant-Speak-Request");
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response:
		return soap_out_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, id, (const struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *)ptr, "ns:Dispatch-Appoint-Participant-Speak-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request:
		return soap_out_ns__Dispatch_Release_Participant_Token_Request(soap, tag, id, (const struct ns__Dispatch_Release_Participant_Token_Request *)ptr, "ns:Dispatch-Release-Participant-Token-Request");
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response:
		return soap_out_ns__Dispatch_Release_Participant_Token_Request_Response(soap, tag, id, (const struct ns__Dispatch_Release_Participant_Token_Request_Response *)ptr, "ns:Dispatch-Release-Participant-Token-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request:
		return soap_out_ns__Dispatch_Drop_Participant_Request(soap, tag, id, (const struct ns__Dispatch_Drop_Participant_Request *)ptr, "ns:Dispatch-Drop-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response:
		return soap_out_ns__Dispatch_Drop_Participant_Request_Response(soap, tag, id, (const struct ns__Dispatch_Drop_Participant_Request_Response *)ptr, "ns:Dispatch-Drop-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request:
		return soap_out_ns__Dispatch_Invite_Participant_Request(soap, tag, id, (const struct ns__Dispatch_Invite_Participant_Request *)ptr, "ns:Dispatch-Invite-Participant-Request");
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response:
		return soap_out_ns__Dispatch_Invite_Participant_Request_Response(soap, tag, id, (const struct ns__Dispatch_Invite_Participant_Request_Response *)ptr, "ns:Dispatch-Invite-Participant-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification:
		return soap_out_ns__Dispatch_Participant_Speak_Request_Notification(soap, tag, id, (const struct ns__Dispatch_Participant_Speak_Request_Notification *)ptr, "ns:Dispatch-Participant-Speak-Request-Notification");
	case SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification:
		return soap_out_ns__Dispatch_Participant_Connect_Request_Notification(soap, tag, id, (const struct ns__Dispatch_Participant_Connect_Request_Notification *)ptr, "ns:Dispatch-Participant-Connect-Request-Notification");
	case SOAP_TYPE_ns__Dispatch_Media_Message_Notification:
		return soap_out_ns__Dispatch_Media_Message_Notification(soap, tag, id, (const struct ns__Dispatch_Media_Message_Notification *)ptr, "ns:Dispatch-Media-Message-Notification");
	case SOAP_TYPE_ns__Dispatch_Media_Message_Request:
		return soap_out_ns__Dispatch_Media_Message_Request(soap, tag, id, (const struct ns__Dispatch_Media_Message_Request *)ptr, "ns:Dispatch-Media-Message-Request");
	case SOAP_TYPE_ns__Dispatch_Participant_Status_Notification:
		return soap_out_ns__Dispatch_Participant_Status_Notification(soap, tag, id, (const struct ns__Dispatch_Participant_Status_Notification *)ptr, "ns:Dispatch-Participant-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication:
		return soap_out_ns__Dispatch_Join_Group_Request_Nofitication(soap, tag, id, (const struct ns__Dispatch_Join_Group_Request_Nofitication *)ptr, "ns:Dispatch-Join-Group-Request-Nofitication");
	case SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification:
		return soap_out_ns__Dispatch_Dispatch_Participants_Notification(soap, tag, id, (const struct ns__Dispatch_Dispatch_Participants_Notification *)ptr, "ns:Dispatch-Dispatch-Participants-Notification");
	case SOAP_TYPE_ns__Dispatch_Delete_Group:
		return soap_out_ns__Dispatch_Delete_Group(soap, tag, id, (const struct ns__Dispatch_Delete_Group *)ptr, "ns:Dispatch-Delete-Group");
	case SOAP_TYPE_ns__Delete_Group_Response:
		return soap_out_ns__Delete_Group_Response(soap, tag, id, (const struct ns__Delete_Group_Response *)ptr, "ns:Delete-Group-Response");
	case SOAP_TYPE_ns__Dispatch_Modify_Participants:
		return soap_out_ns__Dispatch_Modify_Participants(soap, tag, id, (const struct ns__Dispatch_Modify_Participants *)ptr, "ns:Dispatch-Modify-Participants");
	case SOAP_TYPE_ns__Dispatch_Modify_Group:
		return soap_out_ns__Dispatch_Modify_Group(soap, tag, id, (const struct ns__Dispatch_Modify_Group *)ptr, "ns:Dispatch-Modify-Group");
	case SOAP_TYPE_ns__Dispatch_Append_Group:
		return soap_out_ns__Dispatch_Append_Group(soap, tag, id, (const struct ns__Dispatch_Append_Group *)ptr, "ns:Dispatch-Append-Group");
	case SOAP_TYPE_ns__Dispatch_Entity_Status_Notification:
		return soap_out_ns__Dispatch_Entity_Status_Notification(soap, tag, id, (const struct ns__Dispatch_Entity_Status_Notification *)ptr, "ns:Dispatch-Entity-Status-Notification");
	case SOAP_TYPE_ns__Dispatch_Entity_Nofitication:
		return soap_out_ns__Dispatch_Entity_Nofitication(soap, tag, id, (const struct ns__Dispatch_Entity_Nofitication *)ptr, "ns:Dispatch-Entity-Nofitication");
	case SOAP_TYPE_ns__Dispatch_Entity_Request:
		return soap_out_ns__Dispatch_Entity_Request(soap, tag, id, (const struct ns__Dispatch_Entity_Request *)ptr, "ns:Dispatch-Entity-Request");
	case SOAP_TYPE_ns__Dispatch_Keepalive:
		return soap_out_ns__Dispatch_Keepalive(soap, tag, id, (const struct ns__Dispatch_Keepalive *)ptr, "ns:Dispatch-Keepalive");
	case SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response:
		return soap_out_ns__Dispatch_Keepalive_Request_Response(soap, tag, id, (const struct ns__Dispatch_Keepalive_Request_Response *)ptr, "ns:Dispatch-Keepalive-Request-Response");
	case SOAP_TYPE_ns__Dispatch_Logout:
		return soap_out_ns__Dispatch_Logout(soap, tag, id, (const struct ns__Dispatch_Logout *)ptr, "ns:Dispatch-Logout");
	case SOAP_TYPE_ns__LogOutResponse:
		return soap_out_ns__LogOutResponse(soap, tag, id, (const struct ns__LogOutResponse *)ptr, "ns:LogOutResponse");
	case SOAP_TYPE_ns__Dispatch_Login:
		return soap_out_ns__Dispatch_Login(soap, tag, id, (const struct ns__Dispatch_Login *)ptr, "ns:Dispatch-Login");
	case SOAP_TYPE_PointerTons__Dispatch_Delete_History_Alert_Request_Response:
		return soap_out_PointerTons__Dispatch_Delete_History_Alert_Request_Response(soap, tag, id, (struct ns__Dispatch_Delete_History_Alert_Request_Response *const*)ptr, "ns:Dispatch-Delete-History-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Alert_Overed_Notification_Response:
		return soap_out_PointerTons__Dispatch_Alert_Overed_Notification_Response(soap, tag, id, (struct ns__Dispatch_Alert_Overed_Notification_Response *const*)ptr, "ns:Dispatch-Alert-Overed-Notification-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Alert_Request_Response:
		return soap_out_PointerTons__Dispatch_Stop_Alert_Request_Response(soap, tag, id, (struct ns__Dispatch_Stop_Alert_Request_Response *const*)ptr, "ns:Dispatch-Stop-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Modify_Alert_Request_Response:
		return soap_out_PointerTons__Dispatch_Modify_Alert_Request_Response(soap, tag, id, (struct ns__Dispatch_Modify_Alert_Request_Response *const*)ptr, "ns:Dispatch-Modify-Alert-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response:
		return soap_out_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, id, (struct ns__Dispatch_Subscribe_Account_Location_Request_Response *const*)ptr, "ns:Dispatch-Subscribe-Account-Location-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Record_Request_Response:
		return soap_out_PointerTons__Dispatch_Stop_Record_Request_Response(soap, tag, id, (struct ns__Dispatch_Stop_Record_Request_Response *const*)ptr, "ns:Dispatch-Stop-Record-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Start_Record_Request_Response:
		return soap_out_PointerTons__Dispatch_Start_Record_Request_Response(soap, tag, id, (struct ns__Dispatch_Start_Record_Request_Response *const*)ptr, "ns:Dispatch-Start-Record-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Kick_Participant_Request_Response:
		return soap_out_PointerTons__Dispatch_Kick_Participant_Request_Response(soap, tag, id, (struct ns__Dispatch_Kick_Participant_Request_Response *const*)ptr, "ns:Dispatch-Kick-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Send_Message_Request_Response:
		return soap_out_PointerTons__Dispatch_Send_Message_Request_Response(soap, tag, id, (struct ns__Dispatch_Send_Message_Request_Response *const*)ptr, "ns:Dispatch-Send-Message-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Leave_Group_Request_Response:
		return soap_out_PointerTons__Dispatch_Leave_Group_Request_Response(soap, tag, id, (struct ns__Dispatch_Leave_Group_Request_Response *const*)ptr, "ns:Dispatch-Leave-Group-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Jion_Group_Request_Response:
		return soap_out_PointerTons__Dispatch_Jion_Group_Request_Response(soap, tag, id, (struct ns__Dispatch_Jion_Group_Request_Response *const*)ptr, "ns:Dispatch-Jion-Group-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response:
		return soap_out_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, id, (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *const*)ptr, "ns:Dispatch-Appoint-Participant-Speak-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Release_Participant_Token_Request_Response:
		return soap_out_PointerTons__Dispatch_Release_Participant_Token_Request_Response(soap, tag, id, (struct ns__Dispatch_Release_Participant_Token_Request_Response *const*)ptr, "ns:Dispatch-Release-Participant-Token-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Drop_Participant_Request_Response:
		return soap_out_PointerTons__Dispatch_Drop_Participant_Request_Response(soap, tag, id, (struct ns__Dispatch_Drop_Participant_Request_Response *const*)ptr, "ns:Dispatch-Drop-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Invite_Participant_Request_Response:
		return soap_out_PointerTons__Dispatch_Invite_Participant_Request_Response(soap, tag, id, (struct ns__Dispatch_Invite_Participant_Request_Response *const*)ptr, "ns:Dispatch-Invite-Participant-Request-Response");
	case SOAP_TYPE_PointerTons__Delete_Group_Response:
		return soap_out_PointerTons__Delete_Group_Response(soap, tag, id, (struct ns__Delete_Group_Response *const*)ptr, "ns:Delete-Group-Response");
	case SOAP_TYPE_PointerTons__Dispatch_Keepalive_Request_Response:
		return soap_out_PointerTons__Dispatch_Keepalive_Request_Response(soap, tag, id, (struct ns__Dispatch_Keepalive_Request_Response *const*)ptr, "ns:Dispatch-Keepalive-Request-Response");
	case SOAP_TYPE_PointerTons__LogOutResponse:
		return soap_out_PointerTons__LogOutResponse(soap, tag, id, (struct ns__LogOutResponse *const*)ptr, "ns:LogOutResponse");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__Dispatch_Record_Status:
		((ns__Dispatch_Record_Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message:
		((ns__Dispatch_History_Alert_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__HistoryAlert:
		((ns__HistoryAlert *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response:
		((ns__Dispatch_Account_Location_Notification_Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Session_Status_Notification:
		((ns__Session_Status_Notification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Participant_Connect_Request_Notification:
		((ns__Participant_Connect_Request_Notification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Media_Message_Notification:
		((ns__Media_Message_Notification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Media_Message:
		((ns__Media_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__MediaMessage:
		((ns__MediaMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Participant_Status_Notification:
		((ns__Participant_Status_Notification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Join_Group_Request_Nofitication:
		((ns__Join_Group_Request_Nofitication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Modify_Participant:
		((ns__Modify_Participant *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Entity_Status_Notification:
		((ns__Entity_Status_Notification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Entity_Nofitication_Response:
		((ns__Entity_Nofitication_Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__EntityData:
		((ns__EntityData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Organization:
		((ns__Organization *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Alert:
		((ns__Alert *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Gateway:
		((ns__Gateway *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Group:
		((ns__Group *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Participant:
		((ns__Participant *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Unit:
		((ns__Unit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Login_Response:
		((ns__Login_Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Account:
		((ns__Account *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__User:
		((ns__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Address:
		((ns__Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__Entity:
		((ns__Entity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request:
		soap_serialize_ns__Dispatch_Delete_History_Alert_Request(soap, (const struct ns__Dispatch_Delete_History_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response:
		soap_serialize_ns__Dispatch_Delete_History_Alert_Request_Response(soap, (const struct ns__Dispatch_Delete_History_Alert_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request:
		soap_serialize_ns__Dispatch_History_Alert_Message_Request(soap, (const struct ns__Dispatch_History_Alert_Message_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Request:
		soap_serialize_ns__Dispatch_Alert_Request(soap, (const struct ns__Dispatch_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Request:
		soap_serialize_ns__Dispatch_History_Alert_Request(soap, (const struct ns__Dispatch_History_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse:
		soap_serialize_ns__Dispatch_History_Alert_RequestResponse(soap, (const struct ns__Dispatch_History_Alert_RequestResponse *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification:
		soap_serialize_ns__Dispatch_Alert_Overed_Notification(soap, (const struct ns__Dispatch_Alert_Overed_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response:
		soap_serialize_ns__Dispatch_Alert_Overed_Notification_Response(soap, (const struct ns__Dispatch_Alert_Overed_Notification_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request:
		soap_serialize_ns__Dispatch_Stop_Alert_Request(soap, (const struct ns__Dispatch_Stop_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response:
		soap_serialize_ns__Dispatch_Stop_Alert_Request_Response(soap, (const struct ns__Dispatch_Stop_Alert_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request:
		soap_serialize_ns__Dispatch_Modify_Alert_Request(soap, (const struct ns__Dispatch_Modify_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response:
		soap_serialize_ns__Dispatch_Modify_Alert_Request_Response(soap, (const struct ns__Dispatch_Modify_Alert_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Append_Alert_Request:
		soap_serialize_ns__Dispatch_Append_Alert_Request(soap, (const struct ns__Dispatch_Append_Alert_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification:
		soap_serialize_ns__Dispatch_Account_Location_Notification(soap, (const struct ns__Dispatch_Account_Location_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request:
		soap_serialize_ns__Dispatch_Subscribe_Account_Location_Request(soap, (const struct ns__Dispatch_Subscribe_Account_Location_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response:
		soap_serialize_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, (const struct ns__Dispatch_Subscribe_Account_Location_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Record_Status_Notification:
		soap_serialize_ns__Dispatch_Record_Status_Notification(soap, (const struct ns__Dispatch_Record_Status_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request:
		soap_serialize_ns__Dispatch_Stop_Record_Request(soap, (const struct ns__Dispatch_Stop_Record_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response:
		soap_serialize_ns__Dispatch_Stop_Record_Request_Response(soap, (const struct ns__Dispatch_Stop_Record_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request:
		soap_serialize_ns__Dispatch_Start_Record_Request(soap, (const struct ns__Dispatch_Start_Record_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response:
		soap_serialize_ns__Dispatch_Start_Record_Request_Response(soap, (const struct ns__Dispatch_Start_Record_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request:
		soap_serialize_ns__Dispatch_Kick_Participant_Request(soap, (const struct ns__Dispatch_Kick_Participant_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response:
		soap_serialize_ns__Dispatch_Kick_Participant_Request_Response(soap, (const struct ns__Dispatch_Kick_Participant_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request:
		soap_serialize_ns__Dispatch_Send_Message_Request(soap, (const struct ns__Dispatch_Send_Message_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response:
		soap_serialize_ns__Dispatch_Send_Message_Request_Response(soap, (const struct ns__Dispatch_Send_Message_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Session_Status_Notification:
		soap_serialize_ns__Dispatch_Session_Status_Notification(soap, (const struct ns__Dispatch_Session_Status_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request:
		soap_serialize_ns__Dispatch_Leave_Group_Request(soap, (const struct ns__Dispatch_Leave_Group_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response:
		soap_serialize_ns__Dispatch_Leave_Group_Request_Response(soap, (const struct ns__Dispatch_Leave_Group_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request:
		soap_serialize_ns__Dispatch_Jion_Group_Request(soap, (const struct ns__Dispatch_Jion_Group_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response:
		soap_serialize_ns__Dispatch_Jion_Group_Request_Response(soap, (const struct ns__Dispatch_Jion_Group_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request:
		soap_serialize_ns__Dispatch_Appoint_Participant_Speak_Request(soap, (const struct ns__Dispatch_Appoint_Participant_Speak_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response:
		soap_serialize_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, (const struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request:
		soap_serialize_ns__Dispatch_Release_Participant_Token_Request(soap, (const struct ns__Dispatch_Release_Participant_Token_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response:
		soap_serialize_ns__Dispatch_Release_Participant_Token_Request_Response(soap, (const struct ns__Dispatch_Release_Participant_Token_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request:
		soap_serialize_ns__Dispatch_Drop_Participant_Request(soap, (const struct ns__Dispatch_Drop_Participant_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response:
		soap_serialize_ns__Dispatch_Drop_Participant_Request_Response(soap, (const struct ns__Dispatch_Drop_Participant_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request:
		soap_serialize_ns__Dispatch_Invite_Participant_Request(soap, (const struct ns__Dispatch_Invite_Participant_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response:
		soap_serialize_ns__Dispatch_Invite_Participant_Request_Response(soap, (const struct ns__Dispatch_Invite_Participant_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification:
		soap_serialize_ns__Dispatch_Participant_Speak_Request_Notification(soap, (const struct ns__Dispatch_Participant_Speak_Request_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification:
		soap_serialize_ns__Dispatch_Participant_Connect_Request_Notification(soap, (const struct ns__Dispatch_Participant_Connect_Request_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Media_Message_Notification:
		soap_serialize_ns__Dispatch_Media_Message_Notification(soap, (const struct ns__Dispatch_Media_Message_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Media_Message_Request:
		soap_serialize_ns__Dispatch_Media_Message_Request(soap, (const struct ns__Dispatch_Media_Message_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Status_Notification:
		soap_serialize_ns__Dispatch_Participant_Status_Notification(soap, (const struct ns__Dispatch_Participant_Status_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication:
		soap_serialize_ns__Dispatch_Join_Group_Request_Nofitication(soap, (const struct ns__Dispatch_Join_Group_Request_Nofitication *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification:
		soap_serialize_ns__Dispatch_Dispatch_Participants_Notification(soap, (const struct ns__Dispatch_Dispatch_Participants_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_Group:
		soap_serialize_ns__Dispatch_Delete_Group(soap, (const struct ns__Dispatch_Delete_Group *)ptr);
		break;
	case SOAP_TYPE_ns__Delete_Group_Response:
		soap_serialize_ns__Delete_Group_Response(soap, (const struct ns__Delete_Group_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Participants:
		soap_serialize_ns__Dispatch_Modify_Participants(soap, (const struct ns__Dispatch_Modify_Participants *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Group:
		soap_serialize_ns__Dispatch_Modify_Group(soap, (const struct ns__Dispatch_Modify_Group *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Append_Group:
		soap_serialize_ns__Dispatch_Append_Group(soap, (const struct ns__Dispatch_Append_Group *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Status_Notification:
		soap_serialize_ns__Dispatch_Entity_Status_Notification(soap, (const struct ns__Dispatch_Entity_Status_Notification *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Nofitication:
		soap_serialize_ns__Dispatch_Entity_Nofitication(soap, (const struct ns__Dispatch_Entity_Nofitication *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Request:
		soap_serialize_ns__Dispatch_Entity_Request(soap, (const struct ns__Dispatch_Entity_Request *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Keepalive:
		soap_serialize_ns__Dispatch_Keepalive(soap, (const struct ns__Dispatch_Keepalive *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response:
		soap_serialize_ns__Dispatch_Keepalive_Request_Response(soap, (const struct ns__Dispatch_Keepalive_Request_Response *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Logout:
		soap_serialize_ns__Dispatch_Logout(soap, (const struct ns__Dispatch_Logout *)ptr);
		break;
	case SOAP_TYPE_ns__LogOutResponse:
		soap_serialize_ns__LogOutResponse(soap, (const struct ns__LogOutResponse *)ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Login:
		soap_serialize_ns__Dispatch_Login(soap, (const struct ns__Dispatch_Login *)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Delete_History_Alert_Request_Response:
		soap_serialize_PointerTons__Dispatch_Delete_History_Alert_Request_Response(soap, (struct ns__Dispatch_Delete_History_Alert_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Alert_Overed_Notification_Response:
		soap_serialize_PointerTons__Dispatch_Alert_Overed_Notification_Response(soap, (struct ns__Dispatch_Alert_Overed_Notification_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Alert_Request_Response:
		soap_serialize_PointerTons__Dispatch_Stop_Alert_Request_Response(soap, (struct ns__Dispatch_Stop_Alert_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Modify_Alert_Request_Response:
		soap_serialize_PointerTons__Dispatch_Modify_Alert_Request_Response(soap, (struct ns__Dispatch_Modify_Alert_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response:
		soap_serialize_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(soap, (struct ns__Dispatch_Subscribe_Account_Location_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Stop_Record_Request_Response:
		soap_serialize_PointerTons__Dispatch_Stop_Record_Request_Response(soap, (struct ns__Dispatch_Stop_Record_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Start_Record_Request_Response:
		soap_serialize_PointerTons__Dispatch_Start_Record_Request_Response(soap, (struct ns__Dispatch_Start_Record_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Kick_Participant_Request_Response:
		soap_serialize_PointerTons__Dispatch_Kick_Participant_Request_Response(soap, (struct ns__Dispatch_Kick_Participant_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Send_Message_Request_Response:
		soap_serialize_PointerTons__Dispatch_Send_Message_Request_Response(soap, (struct ns__Dispatch_Send_Message_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Leave_Group_Request_Response:
		soap_serialize_PointerTons__Dispatch_Leave_Group_Request_Response(soap, (struct ns__Dispatch_Leave_Group_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Jion_Group_Request_Response:
		soap_serialize_PointerTons__Dispatch_Jion_Group_Request_Response(soap, (struct ns__Dispatch_Jion_Group_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response:
		soap_serialize_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(soap, (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Release_Participant_Token_Request_Response:
		soap_serialize_PointerTons__Dispatch_Release_Participant_Token_Request_Response(soap, (struct ns__Dispatch_Release_Participant_Token_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Drop_Participant_Request_Response:
		soap_serialize_PointerTons__Dispatch_Drop_Participant_Request_Response(soap, (struct ns__Dispatch_Drop_Participant_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Invite_Participant_Request_Response:
		soap_serialize_PointerTons__Dispatch_Invite_Participant_Request_Response(soap, (struct ns__Dispatch_Invite_Participant_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Delete_Group_Response:
		soap_serialize_PointerTons__Delete_Group_Response(soap, (struct ns__Delete_Group_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__Dispatch_Keepalive_Request_Response:
		soap_serialize_PointerTons__Dispatch_Keepalive_Request_Response(soap, (struct ns__Dispatch_Keepalive_Request_Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__LogOutResponse:
		soap_serialize_PointerTons__LogOutResponse(soap, (struct ns__LogOutResponse *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Entity:
		return (void*)soap_instantiate_ns__Entity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Address:
		return (void*)soap_instantiate_ns__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__User:
		return (void*)soap_instantiate_ns__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Account:
		return (void*)soap_instantiate_ns__Account(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Login_Response:
		return (void*)soap_instantiate_ns__Login_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Unit:
		return (void*)soap_instantiate_ns__Unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Participant:
		return (void*)soap_instantiate_ns__Participant(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Group:
		return (void*)soap_instantiate_ns__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Gateway:
		return (void*)soap_instantiate_ns__Gateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Alert:
		return (void*)soap_instantiate_ns__Alert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Organization:
		return (void*)soap_instantiate_ns__Organization(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__EntityData:
		return (void*)soap_instantiate_ns__EntityData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Entity_Nofitication_Response:
		return (void*)soap_instantiate_ns__Entity_Nofitication_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Entity_Status_Notification:
		return (void*)soap_instantiate_ns__Entity_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Modify_Participant:
		return (void*)soap_instantiate_ns__Modify_Participant(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Join_Group_Request_Nofitication:
		return (void*)soap_instantiate_ns__Join_Group_Request_Nofitication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Participant_Status_Notification:
		return (void*)soap_instantiate_ns__Participant_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__MediaMessage:
		return (void*)soap_instantiate_ns__MediaMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Media_Message:
		return (void*)soap_instantiate_ns__Media_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Media_Message_Notification:
		return (void*)soap_instantiate_ns__Media_Message_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Participant_Connect_Request_Notification:
		return (void*)soap_instantiate_ns__Participant_Connect_Request_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Session_Status_Notification:
		return (void*)soap_instantiate_ns__Session_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response:
		return (void*)soap_instantiate_ns__Dispatch_Account_Location_Notification_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__HistoryAlert:
		return (void*)soap_instantiate_ns__HistoryAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message:
		return (void*)soap_instantiate_ns__Dispatch_History_Alert_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Record_Status:
		return (void*)soap_instantiate_ns__Dispatch_Record_Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Login:
		return (void*)soap_instantiate_ns__Dispatch_Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__LogOutResponse:
		return (void*)soap_instantiate_ns__LogOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Logout:
		return (void*)soap_instantiate_ns__Dispatch_Logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Keepalive_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Keepalive:
		return (void*)soap_instantiate_ns__Dispatch_Keepalive(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Entity_Request:
		return (void*)soap_instantiate_ns__Dispatch_Entity_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Entity_Nofitication:
		return (void*)soap_instantiate_ns__Dispatch_Entity_Nofitication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Entity_Status_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Entity_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Append_Group:
		return (void*)soap_instantiate_ns__Dispatch_Append_Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Modify_Group:
		return (void*)soap_instantiate_ns__Dispatch_Modify_Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Modify_Participants:
		return (void*)soap_instantiate_ns__Dispatch_Modify_Participants(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Delete_Group_Response:
		return (void*)soap_instantiate_ns__Delete_Group_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Delete_Group:
		return (void*)soap_instantiate_ns__Dispatch_Delete_Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Dispatch_Participants_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication:
		return (void*)soap_instantiate_ns__Dispatch_Join_Group_Request_Nofitication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Participant_Status_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Participant_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Media_Message_Request:
		return (void*)soap_instantiate_ns__Dispatch_Media_Message_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Media_Message_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Media_Message_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Participant_Connect_Request_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Participant_Speak_Request_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Invite_Participant_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request:
		return (void*)soap_instantiate_ns__Dispatch_Invite_Participant_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Drop_Participant_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request:
		return (void*)soap_instantiate_ns__Dispatch_Drop_Participant_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Release_Participant_Token_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request:
		return (void*)soap_instantiate_ns__Dispatch_Release_Participant_Token_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request:
		return (void*)soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Jion_Group_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request:
		return (void*)soap_instantiate_ns__Dispatch_Jion_Group_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Leave_Group_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request:
		return (void*)soap_instantiate_ns__Dispatch_Leave_Group_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Session_Status_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Session_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Send_Message_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request:
		return (void*)soap_instantiate_ns__Dispatch_Send_Message_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Kick_Participant_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request:
		return (void*)soap_instantiate_ns__Dispatch_Kick_Participant_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Start_Record_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request:
		return (void*)soap_instantiate_ns__Dispatch_Start_Record_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Stop_Record_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request:
		return (void*)soap_instantiate_ns__Dispatch_Stop_Record_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Record_Status_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Record_Status_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request:
		return (void*)soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Account_Location_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Append_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_Append_Alert_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Modify_Alert_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_Modify_Alert_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Stop_Alert_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_Stop_Alert_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response:
		return (void*)soap_instantiate_ns__Dispatch_Alert_Overed_Notification_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification:
		return (void*)soap_instantiate_ns__Dispatch_Alert_Overed_Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse:
		return (void*)soap_instantiate_ns__Dispatch_History_Alert_RequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_History_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_History_Alert_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_Alert_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request:
		return (void*)soap_instantiate_ns__Dispatch_History_Alert_Message_Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response:
		return (void*)soap_instantiate_ns__Dispatch_Delete_History_Alert_Request_Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request:
		return (void*)soap_instantiate_ns__Dispatch_Delete_History_Alert_Request(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__listTemplateOfns__HistoryAlert:
		return (void*)soap_instantiate_std__listTemplateOfns__HistoryAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOfns__Account:
		return (void*)soap_instantiate_std__listTemplateOfns__Account(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOfns__MediaMessage:
		return (void*)soap_instantiate_std__listTemplateOfns__MediaMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__listTemplateOfns__Participant:
		return (void*)soap_instantiate_std__listTemplateOfns__Participant(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns__Entity:
		if (p->size < 0)
			SOAP_DELETE((ns__Entity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Entity*)p->ptr);
		break;
	case SOAP_TYPE_ns__Address:
		if (p->size < 0)
			SOAP_DELETE((ns__Address*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Address*)p->ptr);
		break;
	case SOAP_TYPE_ns__User:
		if (p->size < 0)
			SOAP_DELETE((ns__User*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__User*)p->ptr);
		break;
	case SOAP_TYPE_ns__Account:
		if (p->size < 0)
			SOAP_DELETE((ns__Account*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Account*)p->ptr);
		break;
	case SOAP_TYPE_ns__Login_Response:
		if (p->size < 0)
			SOAP_DELETE((ns__Login_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Login_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Unit:
		if (p->size < 0)
			SOAP_DELETE((ns__Unit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Unit*)p->ptr);
		break;
	case SOAP_TYPE_ns__Participant:
		if (p->size < 0)
			SOAP_DELETE((ns__Participant*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Participant*)p->ptr);
		break;
	case SOAP_TYPE_ns__Group:
		if (p->size < 0)
			SOAP_DELETE((ns__Group*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Group*)p->ptr);
		break;
	case SOAP_TYPE_ns__Gateway:
		if (p->size < 0)
			SOAP_DELETE((ns__Gateway*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Gateway*)p->ptr);
		break;
	case SOAP_TYPE_ns__Alert:
		if (p->size < 0)
			SOAP_DELETE((ns__Alert*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Alert*)p->ptr);
		break;
	case SOAP_TYPE_ns__Organization:
		if (p->size < 0)
			SOAP_DELETE((ns__Organization*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Organization*)p->ptr);
		break;
	case SOAP_TYPE_ns__EntityData:
		if (p->size < 0)
			SOAP_DELETE((ns__EntityData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__EntityData*)p->ptr);
		break;
	case SOAP_TYPE_ns__Entity_Nofitication_Response:
		if (p->size < 0)
			SOAP_DELETE((ns__Entity_Nofitication_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Entity_Nofitication_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Entity_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((ns__Entity_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Entity_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Modify_Participant:
		if (p->size < 0)
			SOAP_DELETE((ns__Modify_Participant*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Modify_Participant*)p->ptr);
		break;
	case SOAP_TYPE_ns__Join_Group_Request_Nofitication:
		if (p->size < 0)
			SOAP_DELETE((ns__Join_Group_Request_Nofitication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Join_Group_Request_Nofitication*)p->ptr);
		break;
	case SOAP_TYPE_ns__Participant_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((ns__Participant_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Participant_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__MediaMessage:
		if (p->size < 0)
			SOAP_DELETE((ns__MediaMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__MediaMessage*)p->ptr);
		break;
	case SOAP_TYPE_ns__Media_Message:
		if (p->size < 0)
			SOAP_DELETE((ns__Media_Message*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Media_Message*)p->ptr);
		break;
	case SOAP_TYPE_ns__Media_Message_Notification:
		if (p->size < 0)
			SOAP_DELETE((ns__Media_Message_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Media_Message_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Participant_Connect_Request_Notification:
		if (p->size < 0)
			SOAP_DELETE((ns__Participant_Connect_Request_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Participant_Connect_Request_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Session_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((ns__Session_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Session_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response:
		if (p->size < 0)
			SOAP_DELETE((ns__Dispatch_Account_Location_Notification_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Dispatch_Account_Location_Notification_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__HistoryAlert:
		if (p->size < 0)
			SOAP_DELETE((ns__HistoryAlert*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__HistoryAlert*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message:
		if (p->size < 0)
			SOAP_DELETE((ns__Dispatch_History_Alert_Message*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Dispatch_History_Alert_Message*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Record_Status:
		if (p->size < 0)
			SOAP_DELETE((ns__Dispatch_Record_Status*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns__Dispatch_Record_Status*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Login:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Login*)p->ptr);
		break;
	case SOAP_TYPE_ns__LogOutResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__LogOutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__LogOutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Logout:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Logout*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Keepalive_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Keepalive_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Keepalive:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Keepalive*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Keepalive*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Entity_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Entity_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Nofitication:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Entity_Nofitication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Entity_Nofitication*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Entity_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Entity_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Entity_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Append_Group:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Append_Group*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Append_Group*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Group:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Modify_Group*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Modify_Group*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Participants:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Modify_Participants*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Modify_Participants*)p->ptr);
		break;
	case SOAP_TYPE_ns__Delete_Group_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Delete_Group_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Delete_Group_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_Group:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Delete_Group*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Delete_Group*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Dispatch_Participants_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Dispatch_Participants_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Join_Group_Request_Nofitication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Join_Group_Request_Nofitication*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Participant_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Participant_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Media_Message_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Media_Message_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Media_Message_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Media_Message_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Media_Message_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Media_Message_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Participant_Connect_Request_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Participant_Connect_Request_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Participant_Speak_Request_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Participant_Speak_Request_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Invite_Participant_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Invite_Participant_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Invite_Participant_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Invite_Participant_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Invite_Participant_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Drop_Participant_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Drop_Participant_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Drop_Participant_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Drop_Participant_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Drop_Participant_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Release_Participant_Token_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Release_Participant_Token_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Release_Participant_Token_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Release_Participant_Token_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Appoint_Participant_Speak_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Appoint_Participant_Speak_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Appoint_Participant_Speak_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Appoint_Participant_Speak_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Jion_Group_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Jion_Group_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Jion_Group_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Jion_Group_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Jion_Group_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Leave_Group_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Leave_Group_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Leave_Group_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Leave_Group_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Leave_Group_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Session_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Session_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Session_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Send_Message_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Send_Message_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Send_Message_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Send_Message_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Send_Message_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Kick_Participant_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Kick_Participant_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Kick_Participant_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Kick_Participant_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Kick_Participant_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Start_Record_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Start_Record_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Start_Record_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Start_Record_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Start_Record_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Stop_Record_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Stop_Record_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Record_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Stop_Record_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Stop_Record_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Record_Status_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Record_Status_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Record_Status_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Subscribe_Account_Location_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Subscribe_Account_Location_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Subscribe_Account_Location_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Subscribe_Account_Location_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Account_Location_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Account_Location_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Account_Location_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Append_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Append_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Append_Alert_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Modify_Alert_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Modify_Alert_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Modify_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Modify_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Modify_Alert_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Stop_Alert_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Stop_Alert_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Stop_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Stop_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Stop_Alert_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Alert_Overed_Notification_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Alert_Overed_Notification_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Alert_Overed_Notification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Alert_Overed_Notification*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_History_Alert_RequestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_History_Alert_RequestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_History_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_History_Alert_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Alert_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_History_Alert_Message_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_History_Alert_Message_Request*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Delete_History_Alert_Request_Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Delete_History_Alert_Request_Response*)p->ptr);
		break;
	case SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Dispatch_Delete_History_Alert_Request*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Dispatch_Delete_History_Alert_Request*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__listTemplateOfns__HistoryAlert:
		if (p->size < 0)
			SOAP_DELETE((std::list<ns__HistoryAlert >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<ns__HistoryAlert >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOfns__Account:
		if (p->size < 0)
			SOAP_DELETE((std::list<ns__Account >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<ns__Account >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOfns__MediaMessage:
		if (p->size < 0)
			SOAP_DELETE((std::list<ns__MediaMessage >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<ns__MediaMessage >*)p->ptr);
		break;
	case SOAP_TYPE_std__listTemplateOfns__Participant:
		if (p->size < 0)
			SOAP_DELETE((std::list<ns__Participant >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::list<ns__Participant >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__listTemplateOfns__HistoryAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<ns__HistoryAlert >*)p)->insert(((std::list<ns__HistoryAlert >*)p)->end(), *(ns__HistoryAlert *)q);
		break;
	case SOAP_TYPE_std__listTemplateOfns__Account:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<ns__Account >*)p)->insert(((std::list<ns__Account >*)p)->end(), *(ns__Account *)q);
		break;
	case SOAP_TYPE_std__listTemplateOfns__MediaMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<ns__MediaMessage >*)p)->insert(((std::list<ns__MediaMessage >*)p)->end(), *(ns__MediaMessage *)q);
		break;
	case SOAP_TYPE_std__listTemplateOfns__Participant:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		((std::list<ns__Participant >*)p)->insert(((std::list<ns__Participant >*)p)->end(), *(ns__Participant *)q);
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uint32(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_uint32);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_uint32(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{	unsigned long *p;
	p = soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_uint32);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uint32(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_uint32);
	if (soap_out_uint32(soap, tag?tag:"uint32", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_uint32(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_uint32(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{	unsigned long *p;
	p = soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__EntityNotifyType(struct soap *soap, enum ns__EntityNotifyType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__EntityNotifyType
	*a = SOAP_DEFAULT_ns__EntityNotifyType;
#else
	*a = (enum ns__EntityNotifyType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__EntityNotifyType[] =
{	{ (long)Created, "Created" },
	{ (long)Modify, "Modify" },
	{ (long)Update, "Update" },
	{ (long)Deleted, "Deleted" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__EntityNotifyType2s(struct soap *soap, enum ns__EntityNotifyType n)
{	const char *s = soap_code_str(soap_codes_ns__EntityNotifyType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__EntityNotifyType(struct soap *soap, const char *tag, int id, const enum ns__EntityNotifyType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__EntityNotifyType), type) || soap_send(soap, soap_ns__EntityNotifyType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__EntityNotifyType(struct soap *soap, const char *s, enum ns__EntityNotifyType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__EntityNotifyType, s);
	if (map)
		*a = (enum ns__EntityNotifyType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__EntityNotifyType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__EntityNotifyType * SOAP_FMAC4 soap_in_ns__EntityNotifyType(struct soap *soap, const char *tag, enum ns__EntityNotifyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__EntityNotifyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__EntityNotifyType, sizeof(enum ns__EntityNotifyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__EntityNotifyType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__EntityNotifyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__EntityNotifyType, 0, sizeof(enum ns__EntityNotifyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__EntityNotifyType(struct soap *soap, const enum ns__EntityNotifyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__EntityNotifyType);
	if (soap_out_ns__EntityNotifyType(soap, tag?tag:"ns:EntityNotifyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__EntityNotifyType * SOAP_FMAC4 soap_get_ns__EntityNotifyType(struct soap *soap, enum ns__EntityNotifyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__EntityNotifyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AlertLevel(struct soap *soap, enum ns__AlertLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__AlertLevel
	*a = SOAP_DEFAULT_ns__AlertLevel;
#else
	*a = (enum ns__AlertLevel)0;
#endif
}

static const struct soap_code_map soap_codes_ns__AlertLevel[] =
{	{ (long)Exigency, "Exigency" },
	{ (long)Importance, "Importance" },
	{ (long)Subordination, "Subordination" },
	{ (long)Ordinary, "Ordinary" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__AlertLevel2s(struct soap *soap, enum ns__AlertLevel n)
{	const char *s = soap_code_str(soap_codes_ns__AlertLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AlertLevel(struct soap *soap, const char *tag, int id, const enum ns__AlertLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AlertLevel), type) || soap_send(soap, soap_ns__AlertLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__AlertLevel(struct soap *soap, const char *s, enum ns__AlertLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__AlertLevel, s);
	if (map)
		*a = (enum ns__AlertLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__AlertLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__AlertLevel * SOAP_FMAC4 soap_in_ns__AlertLevel(struct soap *soap, const char *tag, enum ns__AlertLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__AlertLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AlertLevel, sizeof(enum ns__AlertLevel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__AlertLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__AlertLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AlertLevel, 0, sizeof(enum ns__AlertLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AlertLevel(struct soap *soap, const enum ns__AlertLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AlertLevel);
	if (soap_out_ns__AlertLevel(soap, tag?tag:"ns:AlertLevel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__AlertLevel * SOAP_FMAC4 soap_get_ns__AlertLevel(struct soap *soap, enum ns__AlertLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AlertLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AlertStatus(struct soap *soap, enum ns__AlertStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__AlertStatus
	*a = SOAP_DEFAULT_ns__AlertStatus;
#else
	*a = (enum ns__AlertStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns__AlertStatus[] =
{	{ (long)AlertActive, "AlertActive" },
	{ (long)AlertOver, "AlertOver" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__AlertStatus2s(struct soap *soap, enum ns__AlertStatus n)
{	const char *s = soap_code_str(soap_codes_ns__AlertStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AlertStatus(struct soap *soap, const char *tag, int id, const enum ns__AlertStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AlertStatus), type) || soap_send(soap, soap_ns__AlertStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__AlertStatus(struct soap *soap, const char *s, enum ns__AlertStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__AlertStatus, s);
	if (map)
		*a = (enum ns__AlertStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__AlertStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__AlertStatus * SOAP_FMAC4 soap_in_ns__AlertStatus(struct soap *soap, const char *tag, enum ns__AlertStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__AlertStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AlertStatus, sizeof(enum ns__AlertStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__AlertStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__AlertStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AlertStatus, 0, sizeof(enum ns__AlertStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AlertStatus(struct soap *soap, const enum ns__AlertStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AlertStatus);
	if (soap_out_ns__AlertStatus(soap, tag?tag:"ns:AlertStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__AlertStatus * SOAP_FMAC4 soap_get_ns__AlertStatus(struct soap *soap, enum ns__AlertStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AlertStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__RecordStatus(struct soap *soap, enum ns__RecordStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__RecordStatus
	*a = SOAP_DEFAULT_ns__RecordStatus;
#else
	*a = (enum ns__RecordStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns__RecordStatus[] =
{	{ (long)RecordStop, "RecordStop" },
	{ (long)RecordStart, "RecordStart" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__RecordStatus2s(struct soap *soap, enum ns__RecordStatus n)
{	const char *s = soap_code_str(soap_codes_ns__RecordStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RecordStatus(struct soap *soap, const char *tag, int id, const enum ns__RecordStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__RecordStatus), type) || soap_send(soap, soap_ns__RecordStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__RecordStatus(struct soap *soap, const char *s, enum ns__RecordStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__RecordStatus, s);
	if (map)
		*a = (enum ns__RecordStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__RecordStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__RecordStatus * SOAP_FMAC4 soap_in_ns__RecordStatus(struct soap *soap, const char *tag, enum ns__RecordStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__RecordStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__RecordStatus, sizeof(enum ns__RecordStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__RecordStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__RecordStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__RecordStatus, 0, sizeof(enum ns__RecordStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__RecordStatus(struct soap *soap, const enum ns__RecordStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__RecordStatus);
	if (soap_out_ns__RecordStatus(soap, tag?tag:"ns:RecordStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__RecordStatus * SOAP_FMAC4 soap_get_ns__RecordStatus(struct soap *soap, enum ns__RecordStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__RecordStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__RecordType(struct soap *soap, enum ns__RecordType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__RecordType
	*a = SOAP_DEFAULT_ns__RecordType;
#else
	*a = (enum ns__RecordType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__RecordType[] =
{	{ (long)DontRecord, "DontRecord" },
	{ (long)AutoRecord, "AutoRecord" },
	{ (long)ManualRecord, "ManualRecord" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__RecordType2s(struct soap *soap, enum ns__RecordType n)
{	const char *s = soap_code_str(soap_codes_ns__RecordType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RecordType(struct soap *soap, const char *tag, int id, const enum ns__RecordType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__RecordType), type) || soap_send(soap, soap_ns__RecordType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__RecordType(struct soap *soap, const char *s, enum ns__RecordType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__RecordType, s);
	if (map)
		*a = (enum ns__RecordType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__RecordType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__RecordType * SOAP_FMAC4 soap_in_ns__RecordType(struct soap *soap, const char *tag, enum ns__RecordType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__RecordType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__RecordType, sizeof(enum ns__RecordType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__RecordType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__RecordType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__RecordType, 0, sizeof(enum ns__RecordType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__RecordType(struct soap *soap, const enum ns__RecordType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__RecordType);
	if (soap_out_ns__RecordType(soap, tag?tag:"ns:RecordType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__RecordType * SOAP_FMAC4 soap_get_ns__RecordType(struct soap *soap, enum ns__RecordType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__RecordType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SessionStatus(struct soap *soap, enum ns__SessionStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__SessionStatus
	*a = SOAP_DEFAULT_ns__SessionStatus;
#else
	*a = (enum ns__SessionStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns__SessionStatus[] =
{	{ (long)IDLE, "IDLE" },
	{ (long)InGroup, "InGroup" },
	{ (long)Talking, "Talking" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SessionStatus2s(struct soap *soap, enum ns__SessionStatus n)
{	const char *s = soap_code_str(soap_codes_ns__SessionStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SessionStatus(struct soap *soap, const char *tag, int id, const enum ns__SessionStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SessionStatus), type) || soap_send(soap, soap_ns__SessionStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SessionStatus(struct soap *soap, const char *s, enum ns__SessionStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SessionStatus, s);
	if (map)
		*a = (enum ns__SessionStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SessionStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SessionStatus * SOAP_FMAC4 soap_in_ns__SessionStatus(struct soap *soap, const char *tag, enum ns__SessionStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SessionStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SessionStatus, sizeof(enum ns__SessionStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__SessionStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__SessionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SessionStatus, 0, sizeof(enum ns__SessionStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SessionStatus(struct soap *soap, const enum ns__SessionStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__SessionStatus);
	if (soap_out_ns__SessionStatus(soap, tag?tag:"ns:SessionStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SessionStatus * SOAP_FMAC4 soap_get_ns__SessionStatus(struct soap *soap, enum ns__SessionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SessionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GpsReportMode(struct soap *soap, enum ns__GpsReportMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__GpsReportMode
	*a = SOAP_DEFAULT_ns__GpsReportMode;
#else
	*a = (enum ns__GpsReportMode)0;
#endif
}

static const struct soap_code_map soap_codes_ns__GpsReportMode[] =
{	{ (long)GpsManualPull, "GpsManualPull" },
	{ (long)GpsManualPush, "GpsManualPush" },
	{ (long)GpsAutoPush, "GpsAutoPush" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__GpsReportMode2s(struct soap *soap, enum ns__GpsReportMode n)
{	const char *s = soap_code_str(soap_codes_ns__GpsReportMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GpsReportMode(struct soap *soap, const char *tag, int id, const enum ns__GpsReportMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GpsReportMode), type) || soap_send(soap, soap_ns__GpsReportMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__GpsReportMode(struct soap *soap, const char *s, enum ns__GpsReportMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__GpsReportMode, s);
	if (map)
		*a = (enum ns__GpsReportMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__GpsReportMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__GpsReportMode * SOAP_FMAC4 soap_in_ns__GpsReportMode(struct soap *soap, const char *tag, enum ns__GpsReportMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__GpsReportMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GpsReportMode, sizeof(enum ns__GpsReportMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__GpsReportMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__GpsReportMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GpsReportMode, 0, sizeof(enum ns__GpsReportMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GpsReportMode(struct soap *soap, const enum ns__GpsReportMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__GpsReportMode);
	if (soap_out_ns__GpsReportMode(soap, tag?tag:"ns:GpsReportMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__GpsReportMode * SOAP_FMAC4 soap_get_ns__GpsReportMode(struct soap *soap, enum ns__GpsReportMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GpsReportMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__TokenPrivilege(struct soap *soap, enum ns__TokenPrivilege *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__TokenPrivilege
	*a = SOAP_DEFAULT_ns__TokenPrivilege;
#else
	*a = (enum ns__TokenPrivilege)0;
#endif
}

static const struct soap_code_map soap_codes_ns__TokenPrivilege[] =
{	{ (long)TokenForbid, "TokenForbid" },
	{ (long)TokenFreedom, "TokenFreedom" },
	{ (long)TokenPolicy, "TokenPolicy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__TokenPrivilege2s(struct soap *soap, enum ns__TokenPrivilege n)
{	const char *s = soap_code_str(soap_codes_ns__TokenPrivilege, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__TokenPrivilege(struct soap *soap, const char *tag, int id, const enum ns__TokenPrivilege *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__TokenPrivilege), type) || soap_send(soap, soap_ns__TokenPrivilege2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__TokenPrivilege(struct soap *soap, const char *s, enum ns__TokenPrivilege *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__TokenPrivilege, s);
	if (map)
		*a = (enum ns__TokenPrivilege)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__TokenPrivilege)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__TokenPrivilege * SOAP_FMAC4 soap_in_ns__TokenPrivilege(struct soap *soap, const char *tag, enum ns__TokenPrivilege *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__TokenPrivilege *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__TokenPrivilege, sizeof(enum ns__TokenPrivilege), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__TokenPrivilege(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__TokenPrivilege *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__TokenPrivilege, 0, sizeof(enum ns__TokenPrivilege), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__TokenPrivilege(struct soap *soap, const enum ns__TokenPrivilege *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__TokenPrivilege);
	if (soap_out_ns__TokenPrivilege(soap, tag?tag:"ns:TokenPrivilege", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__TokenPrivilege * SOAP_FMAC4 soap_get_ns__TokenPrivilege(struct soap *soap, enum ns__TokenPrivilege *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__TokenPrivilege(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__CallPrivilege(struct soap *soap, enum ns__CallPrivilege *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__CallPrivilege
	*a = SOAP_DEFAULT_ns__CallPrivilege;
#else
	*a = (enum ns__CallPrivilege)0;
#endif
}

static const struct soap_code_map soap_codes_ns__CallPrivilege[] =
{	{ (long)CallForbid, "CallForbid" },
	{ (long)CallFreedom, "CallFreedom" },
	{ (long)CallPolicy, "CallPolicy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__CallPrivilege2s(struct soap *soap, enum ns__CallPrivilege n)
{	const char *s = soap_code_str(soap_codes_ns__CallPrivilege, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CallPrivilege(struct soap *soap, const char *tag, int id, const enum ns__CallPrivilege *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__CallPrivilege), type) || soap_send(soap, soap_ns__CallPrivilege2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__CallPrivilege(struct soap *soap, const char *s, enum ns__CallPrivilege *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__CallPrivilege, s);
	if (map)
		*a = (enum ns__CallPrivilege)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__CallPrivilege)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__CallPrivilege * SOAP_FMAC4 soap_in_ns__CallPrivilege(struct soap *soap, const char *tag, enum ns__CallPrivilege *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__CallPrivilege *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__CallPrivilege, sizeof(enum ns__CallPrivilege), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__CallPrivilege(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__CallPrivilege *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__CallPrivilege, 0, sizeof(enum ns__CallPrivilege), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__CallPrivilege(struct soap *soap, const enum ns__CallPrivilege *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__CallPrivilege);
	if (soap_out_ns__CallPrivilege(soap, tag?tag:"ns:CallPrivilege", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__CallPrivilege * SOAP_FMAC4 soap_get_ns__CallPrivilege(struct soap *soap, enum ns__CallPrivilege *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__CallPrivilege(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AccountServiceStatus(struct soap *soap, enum ns__AccountServiceStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__AccountServiceStatus
	*a = SOAP_DEFAULT_ns__AccountServiceStatus;
#else
	*a = (enum ns__AccountServiceStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns__AccountServiceStatus[] =
{	{ (long)AccountStop, "AccountStop" },
	{ (long)AccountActive, "AccountActive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__AccountServiceStatus2s(struct soap *soap, enum ns__AccountServiceStatus n)
{	const char *s = soap_code_str(soap_codes_ns__AccountServiceStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AccountServiceStatus(struct soap *soap, const char *tag, int id, const enum ns__AccountServiceStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AccountServiceStatus), type) || soap_send(soap, soap_ns__AccountServiceStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__AccountServiceStatus(struct soap *soap, const char *s, enum ns__AccountServiceStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__AccountServiceStatus, s);
	if (map)
		*a = (enum ns__AccountServiceStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__AccountServiceStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__AccountServiceStatus * SOAP_FMAC4 soap_in_ns__AccountServiceStatus(struct soap *soap, const char *tag, enum ns__AccountServiceStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__AccountServiceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AccountServiceStatus, sizeof(enum ns__AccountServiceStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__AccountServiceStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__AccountServiceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AccountServiceStatus, 0, sizeof(enum ns__AccountServiceStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AccountServiceStatus(struct soap *soap, const enum ns__AccountServiceStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AccountServiceStatus);
	if (soap_out_ns__AccountServiceStatus(soap, tag?tag:"ns:AccountServiceStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__AccountServiceStatus * SOAP_FMAC4 soap_get_ns__AccountServiceStatus(struct soap *soap, enum ns__AccountServiceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AccountServiceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AccountType(struct soap *soap, enum ns__AccountType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__AccountType
	*a = SOAP_DEFAULT_ns__AccountType;
#else
	*a = (enum ns__AccountType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__AccountType[] =
{	{ (long)Dispatcher, "Dispatcher" },
	{ (long)Terminal, "Terminal" },
	{ (long)Record, "Record" },
	{ (long)MediaGateway, "MediaGateway" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__AccountType2s(struct soap *soap, enum ns__AccountType n)
{	const char *s = soap_code_str(soap_codes_ns__AccountType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AccountType(struct soap *soap, const char *tag, int id, const enum ns__AccountType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AccountType), type) || soap_send(soap, soap_ns__AccountType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__AccountType(struct soap *soap, const char *s, enum ns__AccountType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__AccountType, s);
	if (map)
		*a = (enum ns__AccountType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__AccountType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__AccountType * SOAP_FMAC4 soap_in_ns__AccountType(struct soap *soap, const char *tag, enum ns__AccountType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__AccountType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AccountType, sizeof(enum ns__AccountType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__AccountType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__AccountType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AccountType, 0, sizeof(enum ns__AccountType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AccountType(struct soap *soap, const enum ns__AccountType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__AccountType);
	if (soap_out_ns__AccountType(soap, tag?tag:"ns:AccountType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__AccountType * SOAP_FMAC4 soap_get_ns__AccountType(struct soap *soap, enum ns__AccountType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AccountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ListModifyType(struct soap *soap, enum ns__ListModifyType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__ListModifyType
	*a = SOAP_DEFAULT_ns__ListModifyType;
#else
	*a = (enum ns__ListModifyType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__ListModifyType[] =
{	{ (long)Increased, "Increased" },
	{ (long)Decrease, "Decrease" },
	{ (long)Replace, "Replace" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__ListModifyType2s(struct soap *soap, enum ns__ListModifyType n)
{	const char *s = soap_code_str(soap_codes_ns__ListModifyType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ListModifyType(struct soap *soap, const char *tag, int id, const enum ns__ListModifyType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ListModifyType), type) || soap_send(soap, soap_ns__ListModifyType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__ListModifyType(struct soap *soap, const char *s, enum ns__ListModifyType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__ListModifyType, s);
	if (map)
		*a = (enum ns__ListModifyType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__ListModifyType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__ListModifyType * SOAP_FMAC4 soap_in_ns__ListModifyType(struct soap *soap, const char *tag, enum ns__ListModifyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__ListModifyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ListModifyType, sizeof(enum ns__ListModifyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__ListModifyType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__ListModifyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ListModifyType, 0, sizeof(enum ns__ListModifyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ListModifyType(struct soap *soap, const enum ns__ListModifyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ListModifyType);
	if (soap_out_ns__ListModifyType(soap, tag?tag:"ns:ListModifyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__ListModifyType * SOAP_FMAC4 soap_get_ns__ListModifyType(struct soap *soap, enum ns__ListModifyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ListModifyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__EntityType(struct soap *soap, enum ns__EntityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__EntityType
	*a = SOAP_DEFAULT_ns__EntityType;
#else
	*a = (enum ns__EntityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__EntityType[] =
{	{ (long)UNIT, "UNIT" },
	{ (long)ACCOUNT, "ACCOUNT" },
	{ (long)USER, "USER" },
	{ (long)GROUP, "GROUP" },
	{ (long)GATEWAY, "GATEWAY" },
	{ (long)ORGANIZATION, "ORGANIZATION" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__EntityType2s(struct soap *soap, enum ns__EntityType n)
{	const char *s = soap_code_str(soap_codes_ns__EntityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__EntityType(struct soap *soap, const char *tag, int id, const enum ns__EntityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__EntityType), type) || soap_send(soap, soap_ns__EntityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__EntityType(struct soap *soap, const char *s, enum ns__EntityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__EntityType, s);
	if (map)
		*a = (enum ns__EntityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__EntityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__EntityType * SOAP_FMAC4 soap_in_ns__EntityType(struct soap *soap, const char *tag, enum ns__EntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__EntityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__EntityType, sizeof(enum ns__EntityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__EntityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__EntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__EntityType, 0, sizeof(enum ns__EntityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__EntityType(struct soap *soap, const enum ns__EntityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__EntityType);
	if (soap_out_ns__EntityType(soap, tag?tag:"ns:EntityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__EntityType * SOAP_FMAC4 soap_get_ns__EntityType(struct soap *soap, enum ns__EntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UserType(struct soap *soap, enum ns__UserType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__UserType
	*a = SOAP_DEFAULT_ns__UserType;
#else
	*a = (enum ns__UserType)0;
#endif
}

static const struct soap_code_map soap_codes_ns__UserType[] =
{	{ (long)Admin, "Admin" },
	{ (long)Operator, "Operator" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__UserType2s(struct soap *soap, enum ns__UserType n)
{	const char *s = soap_code_str(soap_codes_ns__UserType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserType(struct soap *soap, const char *tag, int id, const enum ns__UserType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserType), type) || soap_send(soap, soap_ns__UserType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__UserType(struct soap *soap, const char *s, enum ns__UserType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__UserType, s);
	if (map)
		*a = (enum ns__UserType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__UserType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_in_ns__UserType(struct soap *soap, const char *tag, enum ns__UserType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__UserType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserType, sizeof(enum ns__UserType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__UserType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__UserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserType, 0, sizeof(enum ns__UserType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UserType(struct soap *soap, const enum ns__UserType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__UserType);
	if (soap_out_ns__UserType(soap, tag?tag:"ns:UserType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_get_ns__UserType(struct soap *soap, enum ns__UserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__RegisterStatus(struct soap *soap, enum ns__RegisterStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__RegisterStatus
	*a = SOAP_DEFAULT_ns__RegisterStatus;
#else
	*a = (enum ns__RegisterStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns__RegisterStatus[] =
{	{ (long)OffLine, "OffLine" },
	{ (long)OnLine, "OnLine" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__RegisterStatus2s(struct soap *soap, enum ns__RegisterStatus n)
{	const char *s = soap_code_str(soap_codes_ns__RegisterStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RegisterStatus(struct soap *soap, const char *tag, int id, const enum ns__RegisterStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__RegisterStatus), type) || soap_send(soap, soap_ns__RegisterStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__RegisterStatus(struct soap *soap, const char *s, enum ns__RegisterStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__RegisterStatus, s);
	if (map)
		*a = (enum ns__RegisterStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__RegisterStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__RegisterStatus * SOAP_FMAC4 soap_in_ns__RegisterStatus(struct soap *soap, const char *tag, enum ns__RegisterStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__RegisterStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__RegisterStatus, sizeof(enum ns__RegisterStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__RegisterStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__RegisterStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__RegisterStatus, 0, sizeof(enum ns__RegisterStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__RegisterStatus(struct soap *soap, const enum ns__RegisterStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__RegisterStatus);
	if (soap_out_ns__RegisterStatus(soap, tag?tag:"ns:RegisterStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__RegisterStatus * SOAP_FMAC4 soap_get_ns__RegisterStatus(struct soap *soap, enum ns__RegisterStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__RegisterStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Dispatch_Record_Status::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Dispatch_Record_Status::group_id.ns__Entity::soap_default(soap);
	soap_default_bool(soap, &this->ns__Dispatch_Record_Status::recording);
}

void ns__Dispatch_Record_Status::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Dispatch_Record_Status::group_id.soap_serialize(soap);
#endif
}

int ns__Dispatch_Record_Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Dispatch_Record_Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Record_Status(struct soap *soap, const char *tag, int id, const ns__Dispatch_Record_Status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Record_Status), type))
		return soap->error;
	if ((a->ns__Dispatch_Record_Status::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "recording", -1, &(a->ns__Dispatch_Record_Status::recording), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Dispatch_Record_Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Dispatch_Record_Status(soap, tag, this, type);
}

SOAP_FMAC3 ns__Dispatch_Record_Status * SOAP_FMAC4 soap_in_ns__Dispatch_Record_Status(struct soap *soap, const char *tag, ns__Dispatch_Record_Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Dispatch_Record_Status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Record_Status, sizeof(ns__Dispatch_Record_Status), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Dispatch_Record_Status)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Dispatch_Record_Status *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_recording1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Dispatch_Record_Status::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_recording1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "recording", &(a->ns__Dispatch_Record_Status::recording), "xsd:boolean"))
				{	soap_flag_recording1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Dispatch_Record_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Record_Status, 0, sizeof(ns__Dispatch_Record_Status), 0, soap_copy_ns__Dispatch_Record_Status);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_recording1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Dispatch_Record_Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Record_Status);
	if (this->soap_out(soap, tag?tag:"ns:Dispatch-Record-Status", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Dispatch_Record_Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Dispatch_Record_Status(soap, this, tag, type);
}

SOAP_FMAC3 ns__Dispatch_Record_Status * SOAP_FMAC4 soap_get_ns__Dispatch_Record_Status(struct soap *soap, ns__Dispatch_Record_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Record_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Dispatch_Record_Status * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Record_Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Record_Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Record_Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Dispatch_Record_Status);
		if (size)
			*size = sizeof(ns__Dispatch_Record_Status);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Dispatch_Record_Status, n);
		if (size)
			*size = n * sizeof(ns__Dispatch_Record_Status);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Dispatch_Record_Status*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Record_Status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Dispatch_Record_Status %p -> %p\n", q, p));
	*(ns__Dispatch_Record_Status*)p = *(ns__Dispatch_Record_Status*)q;
}

void ns__Dispatch_History_Alert_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__Dispatch_History_Alert_Message::history_alert_id);
	soap_default_std__listTemplateOfns__MediaMessage(soap, &this->ns__Dispatch_History_Alert_Message::messages);
	soap_default_uint32(soap, &this->ns__Dispatch_History_Alert_Message::leave_message_count);
}

void ns__Dispatch_History_Alert_Message::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOfns__MediaMessage(soap, &this->ns__Dispatch_History_Alert_Message::messages);
#endif
}

int ns__Dispatch_History_Alert_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Dispatch_History_Alert_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_History_Alert_Message(struct soap *soap, const char *tag, int id, const ns__Dispatch_History_Alert_Message *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Message), type))
		return soap->error;
	if (soap_out_uint32(soap, "history-alert-id", -1, &(a->ns__Dispatch_History_Alert_Message::history_alert_id), ""))
		return soap->error;
	if (soap_out_std__listTemplateOfns__MediaMessage(soap, "messages", -1, &(a->ns__Dispatch_History_Alert_Message::messages), ""))
		return soap->error;
	if (soap_out_uint32(soap, "leave-message-count", -1, &(a->ns__Dispatch_History_Alert_Message::leave_message_count), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Dispatch_History_Alert_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Dispatch_History_Alert_Message(soap, tag, this, type);
}

SOAP_FMAC3 ns__Dispatch_History_Alert_Message * SOAP_FMAC4 soap_in_ns__Dispatch_History_Alert_Message(struct soap *soap, const char *tag, ns__Dispatch_History_Alert_Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Dispatch_History_Alert_Message *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Message, sizeof(ns__Dispatch_History_Alert_Message), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Dispatch_History_Alert_Message)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Dispatch_History_Alert_Message *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_history_alert_id1 = 1;
	size_t soap_flag_leave_message_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_history_alert_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "history-alert-id", &(a->ns__Dispatch_History_Alert_Message::history_alert_id), "uint32"))
				{	soap_flag_history_alert_id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOfns__MediaMessage(soap, "messages", &(a->ns__Dispatch_History_Alert_Message::messages), "ns:MediaMessage"))
					continue;
			if (soap_flag_leave_message_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "leave-message-count", &(a->ns__Dispatch_History_Alert_Message::leave_message_count), "uint32"))
				{	soap_flag_leave_message_count1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Dispatch_History_Alert_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_History_Alert_Message, 0, sizeof(ns__Dispatch_History_Alert_Message), 0, soap_copy_ns__Dispatch_History_Alert_Message);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_history_alert_id1 > 0 || soap_flag_leave_message_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Dispatch_History_Alert_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_History_Alert_Message);
	if (this->soap_out(soap, tag?tag:"ns:Dispatch-History-Alert-Message", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Dispatch_History_Alert_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Dispatch_History_Alert_Message(soap, this, tag, type);
}

SOAP_FMAC3 ns__Dispatch_History_Alert_Message * SOAP_FMAC4 soap_get_ns__Dispatch_History_Alert_Message(struct soap *soap, ns__Dispatch_History_Alert_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_History_Alert_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Dispatch_History_Alert_Message * SOAP_FMAC2 soap_instantiate_ns__Dispatch_History_Alert_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_History_Alert_Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_History_Alert_Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Dispatch_History_Alert_Message);
		if (size)
			*size = sizeof(ns__Dispatch_History_Alert_Message);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Dispatch_History_Alert_Message, n);
		if (size)
			*size = n * sizeof(ns__Dispatch_History_Alert_Message);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Dispatch_History_Alert_Message*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_History_Alert_Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Dispatch_History_Alert_Message %p -> %p\n", q, p));
	*(ns__Dispatch_History_Alert_Message*)p = *(ns__Dispatch_History_Alert_Message*)q;
}

void ns__HistoryAlert::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__HistoryAlert::id);
	soap_default_std__string(soap, &this->ns__HistoryAlert::name);
	soap_default_std__string(soap, &this->ns__HistoryAlert::describe);
	soap_default_ns__AlertLevel(soap, &this->ns__HistoryAlert::level);
	soap_default_std__string(soap, &this->ns__HistoryAlert::alram_time);
	soap_default_uint32(soap, &this->ns__HistoryAlert::use_cars);
	soap_default_std__string(soap, &this->ns__HistoryAlert::create_time);
	soap_default_std__string(soap, &this->ns__HistoryAlert::over_time);
}

void ns__HistoryAlert::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns__HistoryAlert::name);
	soap_serialize_std__string(soap, &this->ns__HistoryAlert::describe);
	soap_serialize_std__string(soap, &this->ns__HistoryAlert::alram_time);
	soap_serialize_std__string(soap, &this->ns__HistoryAlert::create_time);
	soap_serialize_std__string(soap, &this->ns__HistoryAlert::over_time);
#endif
}

int ns__HistoryAlert::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__HistoryAlert(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HistoryAlert(struct soap *soap, const char *tag, int id, const ns__HistoryAlert *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__HistoryAlert), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &(a->ns__HistoryAlert::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns__HistoryAlert::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "describe", -1, &(a->ns__HistoryAlert::describe), ""))
		return soap->error;
	if (soap_out_ns__AlertLevel(soap, "level", -1, &(a->ns__HistoryAlert::level), ""))
		return soap->error;
	if (soap_out_std__string(soap, "alram-time", -1, &(a->ns__HistoryAlert::alram_time), ""))
		return soap->error;
	if (soap_out_uint32(soap, "use-cars", -1, &(a->ns__HistoryAlert::use_cars), ""))
		return soap->error;
	if (soap_out_std__string(soap, "create-time", -1, &(a->ns__HistoryAlert::create_time), ""))
		return soap->error;
	if (soap_out_std__string(soap, "over-time", -1, &(a->ns__HistoryAlert::over_time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__HistoryAlert::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__HistoryAlert(soap, tag, this, type);
}

SOAP_FMAC3 ns__HistoryAlert * SOAP_FMAC4 soap_in_ns__HistoryAlert(struct soap *soap, const char *tag, ns__HistoryAlert *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__HistoryAlert *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__HistoryAlert, sizeof(ns__HistoryAlert), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__HistoryAlert)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__HistoryAlert *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_describe1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_alram_time1 = 1;
	size_t soap_flag_use_cars1 = 1;
	size_t soap_flag_create_time1 = 1;
	size_t soap_flag_over_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &(a->ns__HistoryAlert::id), "uint32"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns__HistoryAlert::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_describe1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "describe", &(a->ns__HistoryAlert::describe), "xsd:string"))
				{	soap_flag_describe1--;
					continue;
				}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AlertLevel(soap, "level", &(a->ns__HistoryAlert::level), "ns:AlertLevel"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_alram_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alram-time", &(a->ns__HistoryAlert::alram_time), "xsd:string"))
				{	soap_flag_alram_time1--;
					continue;
				}
			if (soap_flag_use_cars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "use-cars", &(a->ns__HistoryAlert::use_cars), "uint32"))
				{	soap_flag_use_cars1--;
					continue;
				}
			if (soap_flag_create_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "create-time", &(a->ns__HistoryAlert::create_time), "xsd:string"))
				{	soap_flag_create_time1--;
					continue;
				}
			if (soap_flag_over_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "over-time", &(a->ns__HistoryAlert::over_time), "xsd:string"))
				{	soap_flag_over_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__HistoryAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__HistoryAlert, 0, sizeof(ns__HistoryAlert), 0, soap_copy_ns__HistoryAlert);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_describe1 > 0 || soap_flag_level1 > 0 || soap_flag_alram_time1 > 0 || soap_flag_use_cars1 > 0 || soap_flag_create_time1 > 0 || soap_flag_over_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__HistoryAlert::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__HistoryAlert);
	if (this->soap_out(soap, tag?tag:"ns:HistoryAlert", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__HistoryAlert::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__HistoryAlert(soap, this, tag, type);
}

SOAP_FMAC3 ns__HistoryAlert * SOAP_FMAC4 soap_get_ns__HistoryAlert(struct soap *soap, ns__HistoryAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__HistoryAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__HistoryAlert * SOAP_FMAC2 soap_instantiate_ns__HistoryAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__HistoryAlert(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__HistoryAlert, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__HistoryAlert);
		if (size)
			*size = sizeof(ns__HistoryAlert);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__HistoryAlert, n);
		if (size)
			*size = n * sizeof(ns__HistoryAlert);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__HistoryAlert*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__HistoryAlert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__HistoryAlert %p -> %p\n", q, p));
	*(ns__HistoryAlert*)p = *(ns__HistoryAlert*)q;
}

void ns__Dispatch_Account_Location_Notification_Response::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Dispatch_Account_Location_Notification_Response::account_id.ns__Entity::soap_default(soap);
	soap_default_double(soap, &this->ns__Dispatch_Account_Location_Notification_Response::longitude);
	soap_default_double(soap, &this->ns__Dispatch_Account_Location_Notification_Response::latitude);
	soap_default_std__string(soap, &this->ns__Dispatch_Account_Location_Notification_Response::timestamp);
}

void ns__Dispatch_Account_Location_Notification_Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Dispatch_Account_Location_Notification_Response::account_id.soap_serialize(soap);
	soap_serialize_std__string(soap, &this->ns__Dispatch_Account_Location_Notification_Response::timestamp);
#endif
}

int ns__Dispatch_Account_Location_Notification_Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Dispatch_Account_Location_Notification_Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Account_Location_Notification_Response(struct soap *soap, const char *tag, int id, const ns__Dispatch_Account_Location_Notification_Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response), type))
		return soap->error;
	if ((a->ns__Dispatch_Account_Location_Notification_Response::account_id).soap_out(soap, "account-id", -1, ""))
		return soap->error;
	if (soap_out_double(soap, "longitude", -1, &(a->ns__Dispatch_Account_Location_Notification_Response::longitude), ""))
		return soap->error;
	if (soap_out_double(soap, "latitude", -1, &(a->ns__Dispatch_Account_Location_Notification_Response::latitude), ""))
		return soap->error;
	if (soap_out_std__string(soap, "timestamp", -1, &(a->ns__Dispatch_Account_Location_Notification_Response::timestamp), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Dispatch_Account_Location_Notification_Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Dispatch_Account_Location_Notification_Response(soap, tag, this, type);
}

SOAP_FMAC3 ns__Dispatch_Account_Location_Notification_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Account_Location_Notification_Response(struct soap *soap, const char *tag, ns__Dispatch_Account_Location_Notification_Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Dispatch_Account_Location_Notification_Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response, sizeof(ns__Dispatch_Account_Location_Notification_Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Dispatch_Account_Location_Notification_Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account_id1 = 1;
	size_t soap_flag_longitude1 = 1;
	size_t soap_flag_latitude1 = 1;
	size_t soap_flag_timestamp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Dispatch_Account_Location_Notification_Response::account_id).soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id1--;
					continue;
				}
			if (soap_flag_longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "longitude", &(a->ns__Dispatch_Account_Location_Notification_Response::longitude), "xsd:double"))
				{	soap_flag_longitude1--;
					continue;
				}
			if (soap_flag_latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "latitude", &(a->ns__Dispatch_Account_Location_Notification_Response::latitude), "xsd:double"))
				{	soap_flag_latitude1--;
					continue;
				}
			if (soap_flag_timestamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "timestamp", &(a->ns__Dispatch_Account_Location_Notification_Response::timestamp), "xsd:string"))
				{	soap_flag_timestamp1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Dispatch_Account_Location_Notification_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response, 0, sizeof(ns__Dispatch_Account_Location_Notification_Response), 0, soap_copy_ns__Dispatch_Account_Location_Notification_Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_account_id1 > 0 || soap_flag_longitude1 > 0 || soap_flag_latitude1 > 0 || soap_flag_timestamp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Dispatch_Account_Location_Notification_Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response);
	if (this->soap_out(soap, tag?tag:"ns:Dispatch-Account-Location-Notification-Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Dispatch_Account_Location_Notification_Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Dispatch_Account_Location_Notification_Response(soap, this, tag, type);
}

SOAP_FMAC3 ns__Dispatch_Account_Location_Notification_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Account_Location_Notification_Response(struct soap *soap, ns__Dispatch_Account_Location_Notification_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Account_Location_Notification_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Dispatch_Account_Location_Notification_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Account_Location_Notification_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Account_Location_Notification_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Account_Location_Notification_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Dispatch_Account_Location_Notification_Response);
		if (size)
			*size = sizeof(ns__Dispatch_Account_Location_Notification_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Dispatch_Account_Location_Notification_Response, n);
		if (size)
			*size = n * sizeof(ns__Dispatch_Account_Location_Notification_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Dispatch_Account_Location_Notification_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Account_Location_Notification_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Dispatch_Account_Location_Notification_Response %p -> %p\n", q, p));
	*(ns__Dispatch_Account_Location_Notification_Response*)p = *(ns__Dispatch_Account_Location_Notification_Response*)q;
}

void ns__Session_Status_Notification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Session_Status_Notification::group_id.ns__Entity::soap_default(soap);
	soap_default_ns__SessionStatus(soap, &this->ns__Session_Status_Notification::status);
}

void ns__Session_Status_Notification::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Session_Status_Notification::group_id.soap_serialize(soap);
#endif
}

int ns__Session_Status_Notification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Session_Status_Notification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Session_Status_Notification(struct soap *soap, const char *tag, int id, const ns__Session_Status_Notification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Session_Status_Notification), type))
		return soap->error;
	if ((a->ns__Session_Status_Notification::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (soap_out_ns__SessionStatus(soap, "status", -1, &(a->ns__Session_Status_Notification::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Session_Status_Notification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Session_Status_Notification(soap, tag, this, type);
}

SOAP_FMAC3 ns__Session_Status_Notification * SOAP_FMAC4 soap_in_ns__Session_Status_Notification(struct soap *soap, const char *tag, ns__Session_Status_Notification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Session_Status_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Session_Status_Notification, sizeof(ns__Session_Status_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Session_Status_Notification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Session_Status_Notification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Session_Status_Notification::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SessionStatus(soap, "status", &(a->ns__Session_Status_Notification::status), "ns:SessionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Session_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Session_Status_Notification, 0, sizeof(ns__Session_Status_Notification), 0, soap_copy_ns__Session_Status_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Session_Status_Notification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Session_Status_Notification);
	if (this->soap_out(soap, tag?tag:"ns:Session-Status-Notification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Session_Status_Notification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Session_Status_Notification(soap, this, tag, type);
}

SOAP_FMAC3 ns__Session_Status_Notification * SOAP_FMAC4 soap_get_ns__Session_Status_Notification(struct soap *soap, ns__Session_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Session_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Session_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Session_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Session_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Session_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Session_Status_Notification);
		if (size)
			*size = sizeof(ns__Session_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Session_Status_Notification, n);
		if (size)
			*size = n * sizeof(ns__Session_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Session_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Session_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Session_Status_Notification %p -> %p\n", q, p));
	*(ns__Session_Status_Notification*)p = *(ns__Session_Status_Notification*)q;
}

void ns__Participant_Connect_Request_Notification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Participant_Connect_Request_Notification::group_id.ns__Entity::soap_default(soap);
	this->ns__Participant_Connect_Request_Notification::account_id.ns__Entity::soap_default(soap);
}

void ns__Participant_Connect_Request_Notification::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Participant_Connect_Request_Notification::group_id.soap_serialize(soap);
	this->ns__Participant_Connect_Request_Notification::account_id.soap_serialize(soap);
#endif
}

int ns__Participant_Connect_Request_Notification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Participant_Connect_Request_Notification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Participant_Connect_Request_Notification(struct soap *soap, const char *tag, int id, const ns__Participant_Connect_Request_Notification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Participant_Connect_Request_Notification), type))
		return soap->error;
	if ((a->ns__Participant_Connect_Request_Notification::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if ((a->ns__Participant_Connect_Request_Notification::account_id).soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Participant_Connect_Request_Notification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Participant_Connect_Request_Notification(soap, tag, this, type);
}

SOAP_FMAC3 ns__Participant_Connect_Request_Notification * SOAP_FMAC4 soap_in_ns__Participant_Connect_Request_Notification(struct soap *soap, const char *tag, ns__Participant_Connect_Request_Notification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Participant_Connect_Request_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Participant_Connect_Request_Notification, sizeof(ns__Participant_Connect_Request_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Participant_Connect_Request_Notification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Participant_Connect_Request_Notification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_account_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant_Connect_Request_Notification::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_account_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant_Connect_Request_Notification::account_id).soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Participant_Connect_Request_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Participant_Connect_Request_Notification, 0, sizeof(ns__Participant_Connect_Request_Notification), 0, soap_copy_ns__Participant_Connect_Request_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_account_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Participant_Connect_Request_Notification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Participant_Connect_Request_Notification);
	if (this->soap_out(soap, tag?tag:"ns:Participant-Connect-Request-Notification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Participant_Connect_Request_Notification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Participant_Connect_Request_Notification(soap, this, tag, type);
}

SOAP_FMAC3 ns__Participant_Connect_Request_Notification * SOAP_FMAC4 soap_get_ns__Participant_Connect_Request_Notification(struct soap *soap, ns__Participant_Connect_Request_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Participant_Connect_Request_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Participant_Connect_Request_Notification * SOAP_FMAC2 soap_instantiate_ns__Participant_Connect_Request_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Participant_Connect_Request_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Participant_Connect_Request_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Participant_Connect_Request_Notification);
		if (size)
			*size = sizeof(ns__Participant_Connect_Request_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Participant_Connect_Request_Notification, n);
		if (size)
			*size = n * sizeof(ns__Participant_Connect_Request_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Participant_Connect_Request_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Participant_Connect_Request_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Participant_Connect_Request_Notification %p -> %p\n", q, p));
	*(ns__Participant_Connect_Request_Notification*)p = *(ns__Participant_Connect_Request_Notification*)q;
}

void ns__Media_Message_Notification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__Media_Message_Notification::id);
	this->ns__Media_Message_Notification::messages.ns__MediaMessage::soap_default(soap);
}

void ns__Media_Message_Notification::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Media_Message_Notification::messages.soap_serialize(soap);
#endif
}

int ns__Media_Message_Notification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Media_Message_Notification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Media_Message_Notification(struct soap *soap, const char *tag, int id, const ns__Media_Message_Notification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Media_Message_Notification), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &(a->ns__Media_Message_Notification::id), ""))
		return soap->error;
	if ((a->ns__Media_Message_Notification::messages).soap_out(soap, "messages", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Media_Message_Notification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Media_Message_Notification(soap, tag, this, type);
}

SOAP_FMAC3 ns__Media_Message_Notification * SOAP_FMAC4 soap_in_ns__Media_Message_Notification(struct soap *soap, const char *tag, ns__Media_Message_Notification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Media_Message_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Media_Message_Notification, sizeof(ns__Media_Message_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Media_Message_Notification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Media_Message_Notification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_messages1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &(a->ns__Media_Message_Notification::id), "uint32"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_messages1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Media_Message_Notification::messages).soap_in(soap, "messages", "ns:MediaMessage"))
				{	soap_flag_messages1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Media_Message_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Media_Message_Notification, 0, sizeof(ns__Media_Message_Notification), 0, soap_copy_ns__Media_Message_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_messages1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Media_Message_Notification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Media_Message_Notification);
	if (this->soap_out(soap, tag?tag:"ns:Media-Message-Notification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Media_Message_Notification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Media_Message_Notification(soap, this, tag, type);
}

SOAP_FMAC3 ns__Media_Message_Notification * SOAP_FMAC4 soap_get_ns__Media_Message_Notification(struct soap *soap, ns__Media_Message_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Media_Message_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Media_Message_Notification * SOAP_FMAC2 soap_instantiate_ns__Media_Message_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Media_Message_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Media_Message_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Media_Message_Notification);
		if (size)
			*size = sizeof(ns__Media_Message_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Media_Message_Notification, n);
		if (size)
			*size = n * sizeof(ns__Media_Message_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Media_Message_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Media_Message_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Media_Message_Notification %p -> %p\n", q, p));
	*(ns__Media_Message_Notification*)p = *(ns__Media_Message_Notification*)q;
}

void ns__Media_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Media_Message::id.ns__Entity::soap_default(soap);
	this->ns__Media_Message::messages.ns__MediaMessage::soap_default(soap);
	soap_default_uint32(soap, &this->ns__Media_Message::leave_message_count);
}

void ns__Media_Message::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Media_Message::id.soap_serialize(soap);
	this->ns__Media_Message::messages.soap_serialize(soap);
#endif
}

int ns__Media_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Media_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Media_Message(struct soap *soap, const char *tag, int id, const ns__Media_Message *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Media_Message), type))
		return soap->error;
	if ((a->ns__Media_Message::id).soap_out(soap, "id", -1, ""))
		return soap->error;
	if ((a->ns__Media_Message::messages).soap_out(soap, "messages", -1, ""))
		return soap->error;
	if (soap_out_uint32(soap, "leave-message-count", -1, &(a->ns__Media_Message::leave_message_count), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Media_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Media_Message(soap, tag, this, type);
}

SOAP_FMAC3 ns__Media_Message * SOAP_FMAC4 soap_in_ns__Media_Message(struct soap *soap, const char *tag, ns__Media_Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Media_Message *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Media_Message, sizeof(ns__Media_Message), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Media_Message)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Media_Message *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_messages1 = 1;
	size_t soap_flag_leave_message_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Media_Message::id).soap_in(soap, "id", "ns:Entity"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_messages1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Media_Message::messages).soap_in(soap, "messages", "ns:MediaMessage"))
				{	soap_flag_messages1--;
					continue;
				}
			if (soap_flag_leave_message_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "leave-message-count", &(a->ns__Media_Message::leave_message_count), "uint32"))
				{	soap_flag_leave_message_count1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Media_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Media_Message, 0, sizeof(ns__Media_Message), 0, soap_copy_ns__Media_Message);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_messages1 > 0 || soap_flag_leave_message_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Media_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Media_Message);
	if (this->soap_out(soap, tag?tag:"ns:Media-Message", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Media_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Media_Message(soap, this, tag, type);
}

SOAP_FMAC3 ns__Media_Message * SOAP_FMAC4 soap_get_ns__Media_Message(struct soap *soap, ns__Media_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Media_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Media_Message * SOAP_FMAC2 soap_instantiate_ns__Media_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Media_Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Media_Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Media_Message);
		if (size)
			*size = sizeof(ns__Media_Message);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Media_Message, n);
		if (size)
			*size = n * sizeof(ns__Media_Message);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Media_Message*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Media_Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Media_Message %p -> %p\n", q, p));
	*(ns__Media_Message*)p = *(ns__Media_Message*)q;
}

void ns__MediaMessage::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__MediaMessage::id);
	soap_default_std__string(soap, &this->ns__MediaMessage::sender);
	soap_default_std__string(soap, &this->ns__MediaMessage::text);
	soap_default_std__string(soap, &this->ns__MediaMessage::picture_uri);
	soap_default_std__string(soap, &this->ns__MediaMessage::audio_uri);
	soap_default_uint32(soap, &this->ns__MediaMessage::audio_length);
	soap_default_std__string(soap, &this->ns__MediaMessage::video_uri);
	soap_default_uint32(soap, &this->ns__MediaMessage::video_length);
	soap_default_std__string(soap, &this->ns__MediaMessage::timestamp);
}

void ns__MediaMessage::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns__MediaMessage::sender);
	soap_serialize_std__string(soap, &this->ns__MediaMessage::text);
	soap_serialize_std__string(soap, &this->ns__MediaMessage::picture_uri);
	soap_serialize_std__string(soap, &this->ns__MediaMessage::audio_uri);
	soap_serialize_std__string(soap, &this->ns__MediaMessage::video_uri);
	soap_serialize_std__string(soap, &this->ns__MediaMessage::timestamp);
#endif
}

int ns__MediaMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__MediaMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__MediaMessage(struct soap *soap, const char *tag, int id, const ns__MediaMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__MediaMessage), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &(a->ns__MediaMessage::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sender", -1, &(a->ns__MediaMessage::sender), ""))
		return soap->error;
	if (soap_out_std__string(soap, "text", -1, &(a->ns__MediaMessage::text), ""))
		return soap->error;
	if (soap_out_std__string(soap, "picture-uri", -1, &(a->ns__MediaMessage::picture_uri), ""))
		return soap->error;
	if (soap_out_std__string(soap, "audio-uri", -1, &(a->ns__MediaMessage::audio_uri), ""))
		return soap->error;
	if (soap_out_uint32(soap, "audio-length", -1, &(a->ns__MediaMessage::audio_length), ""))
		return soap->error;
	if (soap_out_std__string(soap, "video-uri", -1, &(a->ns__MediaMessage::video_uri), ""))
		return soap->error;
	if (soap_out_uint32(soap, "video-length", -1, &(a->ns__MediaMessage::video_length), ""))
		return soap->error;
	if (soap_out_std__string(soap, "timestamp", -1, &(a->ns__MediaMessage::timestamp), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__MediaMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__MediaMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns__MediaMessage * SOAP_FMAC4 soap_in_ns__MediaMessage(struct soap *soap, const char *tag, ns__MediaMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__MediaMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__MediaMessage, sizeof(ns__MediaMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__MediaMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__MediaMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_sender1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_picture_uri1 = 1;
	size_t soap_flag_audio_uri1 = 1;
	size_t soap_flag_audio_length1 = 1;
	size_t soap_flag_video_uri1 = 1;
	size_t soap_flag_video_length1 = 1;
	size_t soap_flag_timestamp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &(a->ns__MediaMessage::id), "uint32"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_sender1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sender", &(a->ns__MediaMessage::sender), "xsd:string"))
				{	soap_flag_sender1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "text", &(a->ns__MediaMessage::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_picture_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "picture-uri", &(a->ns__MediaMessage::picture_uri), "xsd:string"))
				{	soap_flag_picture_uri1--;
					continue;
				}
			if (soap_flag_audio_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "audio-uri", &(a->ns__MediaMessage::audio_uri), "xsd:string"))
				{	soap_flag_audio_uri1--;
					continue;
				}
			if (soap_flag_audio_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "audio-length", &(a->ns__MediaMessage::audio_length), "uint32"))
				{	soap_flag_audio_length1--;
					continue;
				}
			if (soap_flag_video_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "video-uri", &(a->ns__MediaMessage::video_uri), "xsd:string"))
				{	soap_flag_video_uri1--;
					continue;
				}
			if (soap_flag_video_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "video-length", &(a->ns__MediaMessage::video_length), "uint32"))
				{	soap_flag_video_length1--;
					continue;
				}
			if (soap_flag_timestamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "timestamp", &(a->ns__MediaMessage::timestamp), "xsd:string"))
				{	soap_flag_timestamp1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__MediaMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__MediaMessage, 0, sizeof(ns__MediaMessage), 0, soap_copy_ns__MediaMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_sender1 > 0 || soap_flag_text1 > 0 || soap_flag_picture_uri1 > 0 || soap_flag_audio_uri1 > 0 || soap_flag_audio_length1 > 0 || soap_flag_video_uri1 > 0 || soap_flag_video_length1 > 0 || soap_flag_timestamp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__MediaMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__MediaMessage);
	if (this->soap_out(soap, tag?tag:"ns:MediaMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__MediaMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__MediaMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns__MediaMessage * SOAP_FMAC4 soap_get_ns__MediaMessage(struct soap *soap, ns__MediaMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__MediaMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__MediaMessage * SOAP_FMAC2 soap_instantiate_ns__MediaMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__MediaMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__MediaMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__MediaMessage);
		if (size)
			*size = sizeof(ns__MediaMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__MediaMessage, n);
		if (size)
			*size = n * sizeof(ns__MediaMessage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__MediaMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__MediaMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__MediaMessage %p -> %p\n", q, p));
	*(ns__MediaMessage*)p = *(ns__MediaMessage*)q;
}

void ns__Participant_Status_Notification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Participant_Status_Notification::group_id.ns__Entity::soap_default(soap);
	this->ns__Participant_Status_Notification::account_id.ns__Entity::soap_default(soap);
	soap_default_ns__SessionStatus(soap, &this->ns__Participant_Status_Notification::status);
}

void ns__Participant_Status_Notification::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Participant_Status_Notification::group_id.soap_serialize(soap);
	this->ns__Participant_Status_Notification::account_id.soap_serialize(soap);
#endif
}

int ns__Participant_Status_Notification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Participant_Status_Notification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Participant_Status_Notification(struct soap *soap, const char *tag, int id, const ns__Participant_Status_Notification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Participant_Status_Notification), type))
		return soap->error;
	if ((a->ns__Participant_Status_Notification::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if ((a->ns__Participant_Status_Notification::account_id).soap_out(soap, "account-id", -1, ""))
		return soap->error;
	if (soap_out_ns__SessionStatus(soap, "status", -1, &(a->ns__Participant_Status_Notification::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Participant_Status_Notification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Participant_Status_Notification(soap, tag, this, type);
}

SOAP_FMAC3 ns__Participant_Status_Notification * SOAP_FMAC4 soap_in_ns__Participant_Status_Notification(struct soap *soap, const char *tag, ns__Participant_Status_Notification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Participant_Status_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Participant_Status_Notification, sizeof(ns__Participant_Status_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Participant_Status_Notification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Participant_Status_Notification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_account_id1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant_Status_Notification::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_account_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant_Status_Notification::account_id).soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SessionStatus(soap, "status", &(a->ns__Participant_Status_Notification::status), "ns:SessionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Participant_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Participant_Status_Notification, 0, sizeof(ns__Participant_Status_Notification), 0, soap_copy_ns__Participant_Status_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_account_id1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Participant_Status_Notification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Participant_Status_Notification);
	if (this->soap_out(soap, tag?tag:"ns:Participant-Status-Notification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Participant_Status_Notification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Participant_Status_Notification(soap, this, tag, type);
}

SOAP_FMAC3 ns__Participant_Status_Notification * SOAP_FMAC4 soap_get_ns__Participant_Status_Notification(struct soap *soap, ns__Participant_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Participant_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Participant_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Participant_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Participant_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Participant_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Participant_Status_Notification);
		if (size)
			*size = sizeof(ns__Participant_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Participant_Status_Notification, n);
		if (size)
			*size = n * sizeof(ns__Participant_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Participant_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Participant_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Participant_Status_Notification %p -> %p\n", q, p));
	*(ns__Participant_Status_Notification*)p = *(ns__Participant_Status_Notification*)q;
}

void ns__Join_Group_Request_Nofitication::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Join_Group_Request_Nofitication::group_id.ns__Entity::soap_default(soap);
	this->ns__Join_Group_Request_Nofitication::account_id.ns__Entity::soap_default(soap);
}

void ns__Join_Group_Request_Nofitication::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Join_Group_Request_Nofitication::group_id.soap_serialize(soap);
	this->ns__Join_Group_Request_Nofitication::account_id.soap_serialize(soap);
#endif
}

int ns__Join_Group_Request_Nofitication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Join_Group_Request_Nofitication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Join_Group_Request_Nofitication(struct soap *soap, const char *tag, int id, const ns__Join_Group_Request_Nofitication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Join_Group_Request_Nofitication), type))
		return soap->error;
	if ((a->ns__Join_Group_Request_Nofitication::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if ((a->ns__Join_Group_Request_Nofitication::account_id).soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Join_Group_Request_Nofitication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Join_Group_Request_Nofitication(soap, tag, this, type);
}

SOAP_FMAC3 ns__Join_Group_Request_Nofitication * SOAP_FMAC4 soap_in_ns__Join_Group_Request_Nofitication(struct soap *soap, const char *tag, ns__Join_Group_Request_Nofitication *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Join_Group_Request_Nofitication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Join_Group_Request_Nofitication, sizeof(ns__Join_Group_Request_Nofitication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Join_Group_Request_Nofitication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Join_Group_Request_Nofitication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_account_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Join_Group_Request_Nofitication::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_account_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Join_Group_Request_Nofitication::account_id).soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Join_Group_Request_Nofitication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Join_Group_Request_Nofitication, 0, sizeof(ns__Join_Group_Request_Nofitication), 0, soap_copy_ns__Join_Group_Request_Nofitication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_account_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Join_Group_Request_Nofitication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Join_Group_Request_Nofitication);
	if (this->soap_out(soap, tag?tag:"ns:Join-Group-Request-Nofitication", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Join_Group_Request_Nofitication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Join_Group_Request_Nofitication(soap, this, tag, type);
}

SOAP_FMAC3 ns__Join_Group_Request_Nofitication * SOAP_FMAC4 soap_get_ns__Join_Group_Request_Nofitication(struct soap *soap, ns__Join_Group_Request_Nofitication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Join_Group_Request_Nofitication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Join_Group_Request_Nofitication * SOAP_FMAC2 soap_instantiate_ns__Join_Group_Request_Nofitication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Join_Group_Request_Nofitication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Join_Group_Request_Nofitication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Join_Group_Request_Nofitication);
		if (size)
			*size = sizeof(ns__Join_Group_Request_Nofitication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Join_Group_Request_Nofitication, n);
		if (size)
			*size = n * sizeof(ns__Join_Group_Request_Nofitication);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Join_Group_Request_Nofitication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Join_Group_Request_Nofitication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Join_Group_Request_Nofitication %p -> %p\n", q, p));
	*(ns__Join_Group_Request_Nofitication*)p = *(ns__Join_Group_Request_Nofitication*)q;
}

void ns__Modify_Participant::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Modify_Participant::group_id.ns__Entity::soap_default(soap);
	soap_default_ns__ListModifyType(soap, &this->ns__Modify_Participant::modify_type);
	soap_default_std__listTemplateOfns__Participant(soap, &this->ns__Modify_Participant::participants);
}

void ns__Modify_Participant::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Modify_Participant::group_id.soap_serialize(soap);
	soap_serialize_std__listTemplateOfns__Participant(soap, &this->ns__Modify_Participant::participants);
#endif
}

int ns__Modify_Participant::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Modify_Participant(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Modify_Participant(struct soap *soap, const char *tag, int id, const ns__Modify_Participant *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Modify_Participant), type))
		return soap->error;
	if ((a->ns__Modify_Participant::group_id).soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (soap_out_ns__ListModifyType(soap, "modify-type", -1, &(a->ns__Modify_Participant::modify_type), ""))
		return soap->error;
	if (soap_out_std__listTemplateOfns__Participant(soap, "participants", -1, &(a->ns__Modify_Participant::participants), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Modify_Participant::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Modify_Participant(soap, tag, this, type);
}

SOAP_FMAC3 ns__Modify_Participant * SOAP_FMAC4 soap_in_ns__Modify_Participant(struct soap *soap, const char *tag, ns__Modify_Participant *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Modify_Participant *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Modify_Participant, sizeof(ns__Modify_Participant), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Modify_Participant)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Modify_Participant *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_group_id1 = 1;
	size_t soap_flag_modify_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Modify_Participant::group_id).soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id1--;
					continue;
				}
			if (soap_flag_modify_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__ListModifyType(soap, "modify-type", &(a->ns__Modify_Participant::modify_type), "ns:ListModifyType"))
				{	soap_flag_modify_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOfns__Participant(soap, "participants", &(a->ns__Modify_Participant::participants), "ns:Participant"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Modify_Participant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Modify_Participant, 0, sizeof(ns__Modify_Participant), 0, soap_copy_ns__Modify_Participant);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id1 > 0 || soap_flag_modify_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Modify_Participant::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Modify_Participant);
	if (this->soap_out(soap, tag?tag:"ns:Modify-Participant", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Modify_Participant::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Modify_Participant(soap, this, tag, type);
}

SOAP_FMAC3 ns__Modify_Participant * SOAP_FMAC4 soap_get_ns__Modify_Participant(struct soap *soap, ns__Modify_Participant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Modify_Participant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Modify_Participant * SOAP_FMAC2 soap_instantiate_ns__Modify_Participant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Modify_Participant(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Modify_Participant, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Modify_Participant);
		if (size)
			*size = sizeof(ns__Modify_Participant);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Modify_Participant, n);
		if (size)
			*size = n * sizeof(ns__Modify_Participant);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Modify_Participant*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Modify_Participant(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Modify_Participant %p -> %p\n", q, p));
	*(ns__Modify_Participant*)p = *(ns__Modify_Participant*)q;
}

void ns__Entity_Status_Notification::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Entity_Status_Notification::id.ns__Entity::soap_default(soap);
	soap_default_ns__RegisterStatus(soap, &this->ns__Entity_Status_Notification::status);
	soap_default_ns__RegisterStatus(soap, &this->ns__Entity_Status_Notification::sip_status);
}

void ns__Entity_Status_Notification::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Entity_Status_Notification::id.soap_serialize(soap);
#endif
}

int ns__Entity_Status_Notification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Entity_Status_Notification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Entity_Status_Notification(struct soap *soap, const char *tag, int id, const ns__Entity_Status_Notification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Entity_Status_Notification), type))
		return soap->error;
	if ((a->ns__Entity_Status_Notification::id).soap_out(soap, "id", -1, ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "status", -1, &(a->ns__Entity_Status_Notification::status), ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "sip-status", -1, &(a->ns__Entity_Status_Notification::sip_status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Entity_Status_Notification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Entity_Status_Notification(soap, tag, this, type);
}

SOAP_FMAC3 ns__Entity_Status_Notification * SOAP_FMAC4 soap_in_ns__Entity_Status_Notification(struct soap *soap, const char *tag, ns__Entity_Status_Notification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Entity_Status_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Entity_Status_Notification, sizeof(ns__Entity_Status_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Entity_Status_Notification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Entity_Status_Notification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_sip_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Entity_Status_Notification::id).soap_in(soap, "id", "ns:Entity"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "status", &(a->ns__Entity_Status_Notification::status), "ns:RegisterStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_sip_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "sip-status", &(a->ns__Entity_Status_Notification::sip_status), "ns:RegisterStatus"))
				{	soap_flag_sip_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Entity_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Entity_Status_Notification, 0, sizeof(ns__Entity_Status_Notification), 0, soap_copy_ns__Entity_Status_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_status1 > 0 || soap_flag_sip_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Entity_Status_Notification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Entity_Status_Notification);
	if (this->soap_out(soap, tag?tag:"ns:Entity-Status-Notification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Entity_Status_Notification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Entity_Status_Notification(soap, this, tag, type);
}

SOAP_FMAC3 ns__Entity_Status_Notification * SOAP_FMAC4 soap_get_ns__Entity_Status_Notification(struct soap *soap, ns__Entity_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Entity_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Entity_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Entity_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Entity_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Entity_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Entity_Status_Notification);
		if (size)
			*size = sizeof(ns__Entity_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Entity_Status_Notification, n);
		if (size)
			*size = n * sizeof(ns__Entity_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Entity_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Entity_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Entity_Status_Notification %p -> %p\n", q, p));
	*(ns__Entity_Status_Notification*)p = *(ns__Entity_Status_Notification*)q;
}

void ns__Entity_Nofitication_Response::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns__EntityNotifyType(soap, &this->ns__Entity_Nofitication_Response::notify_type);
	this->ns__Entity_Nofitication_Response::data.ns__EntityData::soap_default(soap);
}

void ns__Entity_Nofitication_Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Entity_Nofitication_Response::data.soap_serialize(soap);
#endif
}

int ns__Entity_Nofitication_Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Entity_Nofitication_Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Entity_Nofitication_Response(struct soap *soap, const char *tag, int id, const ns__Entity_Nofitication_Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Entity_Nofitication_Response), type))
		return soap->error;
	if (soap_out_ns__EntityNotifyType(soap, "notify-type", -1, &(a->ns__Entity_Nofitication_Response::notify_type), ""))
		return soap->error;
	if ((a->ns__Entity_Nofitication_Response::data).soap_out(soap, "data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Entity_Nofitication_Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Entity_Nofitication_Response(soap, tag, this, type);
}

SOAP_FMAC3 ns__Entity_Nofitication_Response * SOAP_FMAC4 soap_in_ns__Entity_Nofitication_Response(struct soap *soap, const char *tag, ns__Entity_Nofitication_Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Entity_Nofitication_Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Entity_Nofitication_Response, sizeof(ns__Entity_Nofitication_Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Entity_Nofitication_Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Entity_Nofitication_Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_notify_type1 = 1;
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_notify_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__EntityNotifyType(soap, "notify-type", &(a->ns__Entity_Nofitication_Response::notify_type), "ns:EntityNotifyType"))
				{	soap_flag_notify_type1--;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Entity_Nofitication_Response::data).soap_in(soap, "data", "ns:EntityData"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Entity_Nofitication_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Entity_Nofitication_Response, 0, sizeof(ns__Entity_Nofitication_Response), 0, soap_copy_ns__Entity_Nofitication_Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_notify_type1 > 0 || soap_flag_data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Entity_Nofitication_Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Entity_Nofitication_Response);
	if (this->soap_out(soap, tag?tag:"ns:Entity-Nofitication-Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Entity_Nofitication_Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Entity_Nofitication_Response(soap, this, tag, type);
}

SOAP_FMAC3 ns__Entity_Nofitication_Response * SOAP_FMAC4 soap_get_ns__Entity_Nofitication_Response(struct soap *soap, ns__Entity_Nofitication_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Entity_Nofitication_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Entity_Nofitication_Response * SOAP_FMAC2 soap_instantiate_ns__Entity_Nofitication_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Entity_Nofitication_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Entity_Nofitication_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Entity_Nofitication_Response);
		if (size)
			*size = sizeof(ns__Entity_Nofitication_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Entity_Nofitication_Response, n);
		if (size)
			*size = n * sizeof(ns__Entity_Nofitication_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Entity_Nofitication_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Entity_Nofitication_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Entity_Nofitication_Response %p -> %p\n", q, p));
	*(ns__Entity_Nofitication_Response*)p = *(ns__Entity_Nofitication_Response*)q;
}

void ns__EntityData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__EntityData::id.ns__Entity::soap_default(soap);
	this->ns__EntityData::unit.ns__Unit::soap_default(soap);
	this->ns__EntityData::accout.ns__Account::soap_default(soap);
	this->ns__EntityData::user.ns__User::soap_default(soap);
	this->ns__EntityData::group.ns__Group::soap_default(soap);
	this->ns__EntityData::alert.ns__Alert::soap_default(soap);
	this->ns__EntityData::gateway.ns__Gateway::soap_default(soap);
	this->ns__EntityData::organization.ns__Organization::soap_default(soap);
}

void ns__EntityData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__EntityData::id.soap_serialize(soap);
	this->ns__EntityData::unit.soap_serialize(soap);
	this->ns__EntityData::accout.soap_serialize(soap);
	this->ns__EntityData::user.soap_serialize(soap);
	this->ns__EntityData::group.soap_serialize(soap);
	this->ns__EntityData::alert.soap_serialize(soap);
	this->ns__EntityData::gateway.soap_serialize(soap);
	this->ns__EntityData::organization.soap_serialize(soap);
#endif
}

int ns__EntityData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__EntityData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__EntityData(struct soap *soap, const char *tag, int id, const ns__EntityData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__EntityData), type))
		return soap->error;
	if ((a->ns__EntityData::id).soap_out(soap, "id", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::unit).soap_out(soap, "unit", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::accout).soap_out(soap, "accout", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::user).soap_out(soap, "user", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::group).soap_out(soap, "group", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::alert).soap_out(soap, "alert", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::gateway).soap_out(soap, "gateway", -1, ""))
		return soap->error;
	if ((a->ns__EntityData::organization).soap_out(soap, "organization", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__EntityData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__EntityData(soap, tag, this, type);
}

SOAP_FMAC3 ns__EntityData * SOAP_FMAC4 soap_in_ns__EntityData(struct soap *soap, const char *tag, ns__EntityData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__EntityData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__EntityData, sizeof(ns__EntityData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__EntityData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__EntityData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_accout1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_alert1 = 1;
	size_t soap_flag_gateway1 = 1;
	size_t soap_flag_organization1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::id).soap_in(soap, "id", "ns:Entity"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::unit).soap_in(soap, "unit", "ns:Unit"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap_flag_accout1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::accout).soap_in(soap, "accout", "ns:Account"))
				{	soap_flag_accout1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::user).soap_in(soap, "user", "ns:User"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::group).soap_in(soap, "group", "ns:Group"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_alert1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::alert).soap_in(soap, "alert", "ns:Alert"))
				{	soap_flag_alert1--;
					continue;
				}
			if (soap_flag_gateway1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::gateway).soap_in(soap, "gateway", "ns:Gateway"))
				{	soap_flag_gateway1--;
					continue;
				}
			if (soap_flag_organization1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__EntityData::organization).soap_in(soap, "organization", "ns:Organization"))
				{	soap_flag_organization1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__EntityData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__EntityData, 0, sizeof(ns__EntityData), 0, soap_copy_ns__EntityData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_unit1 > 0 || soap_flag_accout1 > 0 || soap_flag_user1 > 0 || soap_flag_group1 > 0 || soap_flag_alert1 > 0 || soap_flag_gateway1 > 0 || soap_flag_organization1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__EntityData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__EntityData);
	if (this->soap_out(soap, tag?tag:"ns:EntityData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__EntityData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__EntityData(soap, this, tag, type);
}

SOAP_FMAC3 ns__EntityData * SOAP_FMAC4 soap_get_ns__EntityData(struct soap *soap, ns__EntityData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__EntityData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__EntityData * SOAP_FMAC2 soap_instantiate_ns__EntityData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__EntityData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__EntityData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__EntityData);
		if (size)
			*size = sizeof(ns__EntityData);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__EntityData, n);
		if (size)
			*size = n * sizeof(ns__EntityData);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__EntityData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__EntityData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__EntityData %p -> %p\n", q, p));
	*(ns__EntityData*)p = *(ns__EntityData*)q;
}

void ns__Organization::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Organization::base.ns__Entity::soap_default(soap);
	soap_default_bool(soap, &this->ns__Organization::include_members);
	this->ns__Organization::members.ns__Entity::soap_default(soap);
}

void ns__Organization::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Organization::base.soap_serialize(soap);
	this->ns__Organization::members.soap_serialize(soap);
#endif
}

int ns__Organization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Organization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Organization(struct soap *soap, const char *tag, int id, const ns__Organization *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Organization), type))
		return soap->error;
	if ((a->ns__Organization::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "include-members", -1, &(a->ns__Organization::include_members), ""))
		return soap->error;
	if ((a->ns__Organization::members).soap_out(soap, "members", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Organization::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Organization(soap, tag, this, type);
}

SOAP_FMAC3 ns__Organization * SOAP_FMAC4 soap_in_ns__Organization(struct soap *soap, const char *tag, ns__Organization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Organization *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Organization, sizeof(ns__Organization), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Organization)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Organization *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_include_members1 = 1;
	size_t soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Organization::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_include_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "include-members", &(a->ns__Organization::include_members), "xsd:boolean"))
				{	soap_flag_include_members1--;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Organization::members).soap_in(soap, "members", "ns:Entity"))
				{	soap_flag_members1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Organization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Organization, 0, sizeof(ns__Organization), 0, soap_copy_ns__Organization);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_include_members1 > 0 || soap_flag_members1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Organization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Organization);
	if (this->soap_out(soap, tag?tag:"ns:Organization", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Organization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Organization(soap, this, tag, type);
}

SOAP_FMAC3 ns__Organization * SOAP_FMAC4 soap_get_ns__Organization(struct soap *soap, ns__Organization *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Organization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Organization * SOAP_FMAC2 soap_instantiate_ns__Organization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Organization(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Organization, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Organization);
		if (size)
			*size = sizeof(ns__Organization);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Organization, n);
		if (size)
			*size = n * sizeof(ns__Organization);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Organization*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Organization(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Organization %p -> %p\n", q, p));
	*(ns__Organization*)p = *(ns__Organization*)q;
}

void ns__Alert::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Alert::base.ns__Entity::soap_default(soap);
	this->ns__Alert::group.ns__Entity::soap_default(soap);
	soap_default_std__string(soap, &this->ns__Alert::describe);
	soap_default_ns__AlertLevel(soap, &this->ns__Alert::level);
	soap_default_std__string(soap, &this->ns__Alert::alram_time);
	soap_default_uint32(soap, &this->ns__Alert::use_cars);
	soap_default_std__string(soap, &this->ns__Alert::create_time);
	soap_default_ns__AlertStatus(soap, &this->ns__Alert::status);
}

void ns__Alert::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Alert::base.soap_serialize(soap);
	this->ns__Alert::group.soap_serialize(soap);
	soap_serialize_std__string(soap, &this->ns__Alert::describe);
	soap_serialize_std__string(soap, &this->ns__Alert::alram_time);
	soap_serialize_std__string(soap, &this->ns__Alert::create_time);
#endif
}

int ns__Alert::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Alert(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Alert(struct soap *soap, const char *tag, int id, const ns__Alert *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Alert), type))
		return soap->error;
	if ((a->ns__Alert::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if ((a->ns__Alert::group).soap_out(soap, "group", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "describe", -1, &(a->ns__Alert::describe), ""))
		return soap->error;
	if (soap_out_ns__AlertLevel(soap, "level", -1, &(a->ns__Alert::level), ""))
		return soap->error;
	if (soap_out_std__string(soap, "alram-time", -1, &(a->ns__Alert::alram_time), ""))
		return soap->error;
	if (soap_out_uint32(soap, "use-cars", -1, &(a->ns__Alert::use_cars), ""))
		return soap->error;
	if (soap_out_std__string(soap, "create-time", -1, &(a->ns__Alert::create_time), ""))
		return soap->error;
	if (soap_out_ns__AlertStatus(soap, "status", -1, &(a->ns__Alert::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Alert::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Alert(soap, tag, this, type);
}

SOAP_FMAC3 ns__Alert * SOAP_FMAC4 soap_in_ns__Alert(struct soap *soap, const char *tag, ns__Alert *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Alert *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Alert, sizeof(ns__Alert), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Alert)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Alert *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_describe1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_alram_time1 = 1;
	size_t soap_flag_use_cars1 = 1;
	size_t soap_flag_create_time1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Alert::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Alert::group).soap_in(soap, "group", "ns:Entity"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_describe1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "describe", &(a->ns__Alert::describe), "xsd:string"))
				{	soap_flag_describe1--;
					continue;
				}
			if (soap_flag_level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AlertLevel(soap, "level", &(a->ns__Alert::level), "ns:AlertLevel"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_alram_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alram-time", &(a->ns__Alert::alram_time), "xsd:string"))
				{	soap_flag_alram_time1--;
					continue;
				}
			if (soap_flag_use_cars1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "use-cars", &(a->ns__Alert::use_cars), "uint32"))
				{	soap_flag_use_cars1--;
					continue;
				}
			if (soap_flag_create_time1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "create-time", &(a->ns__Alert::create_time), "xsd:string"))
				{	soap_flag_create_time1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AlertStatus(soap, "status", &(a->ns__Alert::status), "ns:AlertStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Alert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Alert, 0, sizeof(ns__Alert), 0, soap_copy_ns__Alert);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_group1 > 0 || soap_flag_describe1 > 0 || soap_flag_level1 > 0 || soap_flag_alram_time1 > 0 || soap_flag_use_cars1 > 0 || soap_flag_create_time1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Alert::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Alert);
	if (this->soap_out(soap, tag?tag:"ns:Alert", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Alert::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Alert(soap, this, tag, type);
}

SOAP_FMAC3 ns__Alert * SOAP_FMAC4 soap_get_ns__Alert(struct soap *soap, ns__Alert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Alert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Alert * SOAP_FMAC2 soap_instantiate_ns__Alert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Alert(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Alert, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Alert);
		if (size)
			*size = sizeof(ns__Alert);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Alert, n);
		if (size)
			*size = n * sizeof(ns__Alert);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Alert*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Alert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Alert %p -> %p\n", q, p));
	*(ns__Alert*)p = *(ns__Alert*)q;
}

void ns__Gateway::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Gateway::base.ns__Entity::soap_default(soap);
	this->ns__Gateway::address.ns__Address::soap_default(soap);
	soap_default_bool(soap, &this->ns__Gateway::include_allocate_counts);
	this->ns__Gateway::allocate_counts.ns__Entity::soap_default(soap);
	soap_default_bool(soap, &this->ns__Gateway::include_active_counts);
	this->ns__Gateway::active_counts.ns__Entity::soap_default(soap);
	soap_default_ns__RegisterStatus(soap, &this->ns__Gateway::status);
}

void ns__Gateway::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Gateway::base.soap_serialize(soap);
	this->ns__Gateway::address.soap_serialize(soap);
	this->ns__Gateway::allocate_counts.soap_serialize(soap);
	this->ns__Gateway::active_counts.soap_serialize(soap);
#endif
}

int ns__Gateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Gateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Gateway(struct soap *soap, const char *tag, int id, const ns__Gateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Gateway), type))
		return soap->error;
	if ((a->ns__Gateway::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if ((a->ns__Gateway::address).soap_out(soap, "address", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "include-allocate-counts", -1, &(a->ns__Gateway::include_allocate_counts), ""))
		return soap->error;
	if ((a->ns__Gateway::allocate_counts).soap_out(soap, "allocate-counts", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "include-active-counts", -1, &(a->ns__Gateway::include_active_counts), ""))
		return soap->error;
	if ((a->ns__Gateway::active_counts).soap_out(soap, "active-counts", -1, ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "status", -1, &(a->ns__Gateway::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Gateway::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Gateway(soap, tag, this, type);
}

SOAP_FMAC3 ns__Gateway * SOAP_FMAC4 soap_in_ns__Gateway(struct soap *soap, const char *tag, ns__Gateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Gateway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Gateway, sizeof(ns__Gateway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Gateway)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Gateway *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_include_allocate_counts1 = 1;
	size_t soap_flag_allocate_counts1 = 1;
	size_t soap_flag_include_active_counts1 = 1;
	size_t soap_flag_active_counts1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gateway::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gateway::address).soap_in(soap, "address", "ns:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_include_allocate_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "include-allocate-counts", &(a->ns__Gateway::include_allocate_counts), "xsd:boolean"))
				{	soap_flag_include_allocate_counts1--;
					continue;
				}
			if (soap_flag_allocate_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gateway::allocate_counts).soap_in(soap, "allocate-counts", "ns:Entity"))
				{	soap_flag_allocate_counts1--;
					continue;
				}
			if (soap_flag_include_active_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "include-active-counts", &(a->ns__Gateway::include_active_counts), "xsd:boolean"))
				{	soap_flag_include_active_counts1--;
					continue;
				}
			if (soap_flag_active_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Gateway::active_counts).soap_in(soap, "active-counts", "ns:Entity"))
				{	soap_flag_active_counts1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "status", &(a->ns__Gateway::status), "ns:RegisterStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Gateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Gateway, 0, sizeof(ns__Gateway), 0, soap_copy_ns__Gateway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_address1 > 0 || soap_flag_include_allocate_counts1 > 0 || soap_flag_allocate_counts1 > 0 || soap_flag_include_active_counts1 > 0 || soap_flag_active_counts1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Gateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Gateway);
	if (this->soap_out(soap, tag?tag:"ns:Gateway", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Gateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Gateway(soap, this, tag, type);
}

SOAP_FMAC3 ns__Gateway * SOAP_FMAC4 soap_get_ns__Gateway(struct soap *soap, ns__Gateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Gateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Gateway * SOAP_FMAC2 soap_instantiate_ns__Gateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Gateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Gateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Gateway);
		if (size)
			*size = sizeof(ns__Gateway);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Gateway, n);
		if (size)
			*size = n * sizeof(ns__Gateway);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Gateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Gateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Gateway %p -> %p\n", q, p));
	*(ns__Gateway*)p = *(ns__Gateway*)q;
}

void ns__Group::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Group::base.ns__Entity::soap_default(soap);
	this->ns__Group::owner.ns__Entity::soap_default(soap);
	soap_default_std__string(soap, &this->ns__Group::number);
	soap_default_std__string(soap, &this->ns__Group::short_number);
	soap_default_bool(soap, &this->ns__Group::sealed);
	soap_default_bool(soap, &this->ns__Group::include_participants);
	this->ns__Group::participants.ns__Participant::soap_default(soap);
	soap_default_ns__RecordType(soap, &this->ns__Group::record_type);
	this->ns__Group::recorder.ns__Participant::soap_default(soap);
	soap_default_ns__RecordStatus(soap, &this->ns__Group::record_status);
}

void ns__Group::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Group::base.soap_serialize(soap);
	this->ns__Group::owner.soap_serialize(soap);
	soap_serialize_std__string(soap, &this->ns__Group::number);
	soap_serialize_std__string(soap, &this->ns__Group::short_number);
	this->ns__Group::participants.soap_serialize(soap);
	this->ns__Group::recorder.soap_serialize(soap);
#endif
}

int ns__Group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Group(struct soap *soap, const char *tag, int id, const ns__Group *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Group), type))
		return soap->error;
	if ((a->ns__Group::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if ((a->ns__Group::owner).soap_out(soap, "owner", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "number", -1, &(a->ns__Group::number), ""))
		return soap->error;
	if (soap_out_std__string(soap, "short-number", -1, &(a->ns__Group::short_number), ""))
		return soap->error;
	if (soap_out_bool(soap, "sealed", -1, &(a->ns__Group::sealed), ""))
		return soap->error;
	if (soap_out_bool(soap, "include-participants", -1, &(a->ns__Group::include_participants), ""))
		return soap->error;
	if ((a->ns__Group::participants).soap_out(soap, "participants", -1, ""))
		return soap->error;
	if (soap_out_ns__RecordType(soap, "record-type", -1, &(a->ns__Group::record_type), ""))
		return soap->error;
	if ((a->ns__Group::recorder).soap_out(soap, "recorder", -1, ""))
		return soap->error;
	if (soap_out_ns__RecordStatus(soap, "record-status", -1, &(a->ns__Group::record_status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Group(soap, tag, this, type);
}

SOAP_FMAC3 ns__Group * SOAP_FMAC4 soap_in_ns__Group(struct soap *soap, const char *tag, ns__Group *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Group, sizeof(ns__Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Group)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Group *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_short_number1 = 1;
	size_t soap_flag_sealed1 = 1;
	size_t soap_flag_include_participants1 = 1;
	size_t soap_flag_participants1 = 1;
	size_t soap_flag_record_type1 = 1;
	size_t soap_flag_recorder1 = 1;
	size_t soap_flag_record_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Group::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Group::owner).soap_in(soap, "owner", "ns:Entity"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "number", &(a->ns__Group::number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_short_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "short-number", &(a->ns__Group::short_number), "xsd:string"))
				{	soap_flag_short_number1--;
					continue;
				}
			if (soap_flag_sealed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "sealed", &(a->ns__Group::sealed), "xsd:boolean"))
				{	soap_flag_sealed1--;
					continue;
				}
			if (soap_flag_include_participants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "include-participants", &(a->ns__Group::include_participants), "xsd:boolean"))
				{	soap_flag_include_participants1--;
					continue;
				}
			if (soap_flag_participants1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Group::participants).soap_in(soap, "participants", "ns:Participant"))
				{	soap_flag_participants1--;
					continue;
				}
			if (soap_flag_record_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RecordType(soap, "record-type", &(a->ns__Group::record_type), "ns:RecordType"))
				{	soap_flag_record_type1--;
					continue;
				}
			if (soap_flag_recorder1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Group::recorder).soap_in(soap, "recorder", "ns:Participant"))
				{	soap_flag_recorder1--;
					continue;
				}
			if (soap_flag_record_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RecordStatus(soap, "record-status", &(a->ns__Group::record_status), "ns:RecordStatus"))
				{	soap_flag_record_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Group, 0, sizeof(ns__Group), 0, soap_copy_ns__Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_owner1 > 0 || soap_flag_number1 > 0 || soap_flag_short_number1 > 0 || soap_flag_sealed1 > 0 || soap_flag_include_participants1 > 0 || soap_flag_participants1 > 0 || soap_flag_record_type1 > 0 || soap_flag_recorder1 > 0 || soap_flag_record_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Group);
	if (this->soap_out(soap, tag?tag:"ns:Group", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Group(soap, this, tag, type);
}

SOAP_FMAC3 ns__Group * SOAP_FMAC4 soap_get_ns__Group(struct soap *soap, ns__Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Group * SOAP_FMAC2 soap_instantiate_ns__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Group);
		if (size)
			*size = sizeof(ns__Group);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Group, n);
		if (size)
			*size = n * sizeof(ns__Group);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Group*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Group %p -> %p\n", q, p));
	*(ns__Group*)p = *(ns__Group*)q;
}

void ns__Participant::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__Participant::id);
	this->ns__Participant::group.ns__Entity::soap_default(soap);
	this->ns__Participant::account.ns__Entity::soap_default(soap);
	soap_default_uint32(soap, &this->ns__Participant::priority);
	soap_default_ns__CallPrivilege(soap, &this->ns__Participant::call_privilege);
	soap_default_ns__TokenPrivilege(soap, &this->ns__Participant::toke_privilege);
	soap_default_ns__SessionStatus(soap, &this->ns__Participant::status);
	soap_default_bool(soap, &this->ns__Participant::sync_added);
}

void ns__Participant::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Participant::group.soap_serialize(soap);
	this->ns__Participant::account.soap_serialize(soap);
#endif
}

int ns__Participant::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Participant(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Participant(struct soap *soap, const char *tag, int id, const ns__Participant *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Participant), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &(a->ns__Participant::id), ""))
		return soap->error;
	if ((a->ns__Participant::group).soap_out(soap, "group", -1, ""))
		return soap->error;
	if ((a->ns__Participant::account).soap_out(soap, "account", -1, ""))
		return soap->error;
	if (soap_out_uint32(soap, "priority", -1, &(a->ns__Participant::priority), ""))
		return soap->error;
	if (soap_out_ns__CallPrivilege(soap, "call-privilege", -1, &(a->ns__Participant::call_privilege), ""))
		return soap->error;
	if (soap_out_ns__TokenPrivilege(soap, "toke-privilege", -1, &(a->ns__Participant::toke_privilege), ""))
		return soap->error;
	if (soap_out_ns__SessionStatus(soap, "status", -1, &(a->ns__Participant::status), ""))
		return soap->error;
	if (soap_out_bool(soap, "sync-added", -1, &(a->ns__Participant::sync_added), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Participant::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Participant(soap, tag, this, type);
}

SOAP_FMAC3 ns__Participant * SOAP_FMAC4 soap_in_ns__Participant(struct soap *soap, const char *tag, ns__Participant *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Participant *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Participant, sizeof(ns__Participant), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Participant)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Participant *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_account1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_call_privilege1 = 1;
	size_t soap_flag_toke_privilege1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_sync_added1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &(a->ns__Participant::id), "uint32"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant::group).soap_in(soap, "group", "ns:Entity"))
				{	soap_flag_group1--;
					continue;
				}
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Participant::account).soap_in(soap, "account", "ns:Entity"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "priority", &(a->ns__Participant::priority), "uint32"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_call_privilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__CallPrivilege(soap, "call-privilege", &(a->ns__Participant::call_privilege), "ns:CallPrivilege"))
				{	soap_flag_call_privilege1--;
					continue;
				}
			if (soap_flag_toke_privilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__TokenPrivilege(soap, "toke-privilege", &(a->ns__Participant::toke_privilege), "ns:TokenPrivilege"))
				{	soap_flag_toke_privilege1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__SessionStatus(soap, "status", &(a->ns__Participant::status), "ns:SessionStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_sync_added1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "sync-added", &(a->ns__Participant::sync_added), "xsd:boolean"))
				{	soap_flag_sync_added1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Participant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Participant, 0, sizeof(ns__Participant), 0, soap_copy_ns__Participant);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_group1 > 0 || soap_flag_account1 > 0 || soap_flag_priority1 > 0 || soap_flag_call_privilege1 > 0 || soap_flag_toke_privilege1 > 0 || soap_flag_status1 > 0 || soap_flag_sync_added1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Participant::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Participant);
	if (this->soap_out(soap, tag?tag:"ns:Participant", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Participant::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Participant(soap, this, tag, type);
}

SOAP_FMAC3 ns__Participant * SOAP_FMAC4 soap_get_ns__Participant(struct soap *soap, ns__Participant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Participant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Participant * SOAP_FMAC2 soap_instantiate_ns__Participant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Participant(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Participant, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Participant);
		if (size)
			*size = sizeof(ns__Participant);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Participant, n);
		if (size)
			*size = n * sizeof(ns__Participant);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Participant*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Participant(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Participant %p -> %p\n", q, p));
	*(ns__Participant*)p = *(ns__Participant*)q;
}

void ns__Unit::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Unit::base.ns__Entity::soap_default(soap);
	soap_default_bool(soap, &this->ns__Unit::include_members);
	this->ns__Unit::members.ns__Entity::soap_default(soap);
}

void ns__Unit::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Unit::base.soap_serialize(soap);
	this->ns__Unit::members.soap_serialize(soap);
#endif
}

int ns__Unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Unit(struct soap *soap, const char *tag, int id, const ns__Unit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Unit), type))
		return soap->error;
	if ((a->ns__Unit::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "include-members", -1, &(a->ns__Unit::include_members), ""))
		return soap->error;
	if ((a->ns__Unit::members).soap_out(soap, "members", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Unit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Unit(soap, tag, this, type);
}

SOAP_FMAC3 ns__Unit * SOAP_FMAC4 soap_in_ns__Unit(struct soap *soap, const char *tag, ns__Unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Unit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Unit, sizeof(ns__Unit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Unit)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Unit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_include_members1 = 1;
	size_t soap_flag_members1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Unit::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_include_members1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "include-members", &(a->ns__Unit::include_members), "xsd:boolean"))
				{	soap_flag_include_members1--;
					continue;
				}
			if (soap_flag_members1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Unit::members).soap_in(soap, "members", "ns:Entity"))
				{	soap_flag_members1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Unit, 0, sizeof(ns__Unit), 0, soap_copy_ns__Unit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_include_members1 > 0 || soap_flag_members1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Unit);
	if (this->soap_out(soap, tag?tag:"ns:Unit", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Unit(soap, this, tag, type);
}

SOAP_FMAC3 ns__Unit * SOAP_FMAC4 soap_get_ns__Unit(struct soap *soap, ns__Unit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Unit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Unit * SOAP_FMAC2 soap_instantiate_ns__Unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Unit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Unit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Unit);
		if (size)
			*size = sizeof(ns__Unit);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Unit, n);
		if (size)
			*size = n * sizeof(ns__Unit);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Unit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Unit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Unit %p -> %p\n", q, p));
	*(ns__Unit*)p = *(ns__Unit*)q;
}

void ns__Login_Response::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__Login_Response::session_id);
	this->ns__Login_Response::user.ns__User::soap_default(soap);
	soap_default_uint32(soap, &this->ns__Login_Response::ttl);
}

void ns__Login_Response::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Login_Response::user.soap_serialize(soap);
#endif
}

int ns__Login_Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Login_Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Login_Response(struct soap *soap, const char *tag, int id, const ns__Login_Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Login_Response), type))
		return soap->error;
	if (soap_out_uint32(soap, "session-id", -1, &(a->ns__Login_Response::session_id), ""))
		return soap->error;
	if ((a->ns__Login_Response::user).soap_out(soap, "user", -1, ""))
		return soap->error;
	if (soap_out_uint32(soap, "ttl", -1, &(a->ns__Login_Response::ttl), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Login_Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Login_Response(soap, tag, this, type);
}

SOAP_FMAC3 ns__Login_Response * SOAP_FMAC4 soap_in_ns__Login_Response(struct soap *soap, const char *tag, ns__Login_Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Login_Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Login_Response, sizeof(ns__Login_Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Login_Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Login_Response *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session_id1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_ttl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "session-id", &(a->ns__Login_Response::session_id), "uint32"))
				{	soap_flag_session_id1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Login_Response::user).soap_in(soap, "user", "ns:User"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_ttl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "ttl", &(a->ns__Login_Response::ttl), "uint32"))
				{	soap_flag_ttl1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Login_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Login_Response, 0, sizeof(ns__Login_Response), 0, soap_copy_ns__Login_Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session_id1 > 0 || soap_flag_user1 > 0 || soap_flag_ttl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Login_Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Login_Response);
	if (this->soap_out(soap, tag?tag:"ns:Login-Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Login_Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Login_Response(soap, this, tag, type);
}

SOAP_FMAC3 ns__Login_Response * SOAP_FMAC4 soap_get_ns__Login_Response(struct soap *soap, ns__Login_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Login_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Login_Response * SOAP_FMAC2 soap_instantiate_ns__Login_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Login_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Login_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Login_Response);
		if (size)
			*size = sizeof(ns__Login_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Login_Response, n);
		if (size)
			*size = n * sizeof(ns__Login_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Login_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Login_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Login_Response %p -> %p\n", q, p));
	*(ns__Login_Response*)p = *(ns__Login_Response*)q;
}

void ns__Account::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Account::base.ns__Entity::soap_default(soap);
	soap_default_ns__AccountType(soap, &this->ns__Account::account_type);
	soap_default_std__string(soap, &this->ns__Account::number);
	soap_default_std__string(soap, &this->ns__Account::short_number);
	soap_default_std__string(soap, &this->ns__Account::password);
	soap_default_ns__AccountServiceStatus(soap, &this->ns__Account::service_status);
	soap_default_uint32(soap, &this->ns__Account::priority);
	soap_default_ns__CallPrivilege(soap, &this->ns__Account::call_privilege);
	soap_default_ns__TokenPrivilege(soap, &this->ns__Account::token_privilege);
	soap_default_ns__GpsReportMode(soap, &this->ns__Account::gps_report_mode);
	soap_default_uint32(soap, &this->ns__Account::ttl);
	soap_default_ns__RegisterStatus(soap, &this->ns__Account::status);
	soap_default_ns__RegisterStatus(soap, &this->ns__Account::sip_status);
	this->ns__Account::address.ns__Address::soap_default(soap);
}

void ns__Account::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__Account::base.soap_serialize(soap);
	soap_serialize_std__string(soap, &this->ns__Account::number);
	soap_serialize_std__string(soap, &this->ns__Account::short_number);
	soap_serialize_std__string(soap, &this->ns__Account::password);
	this->ns__Account::address.soap_serialize(soap);
#endif
}

int ns__Account::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Account(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Account(struct soap *soap, const char *tag, int id, const ns__Account *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Account), type))
		return soap->error;
	if ((a->ns__Account::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if (soap_out_ns__AccountType(soap, "account-type", -1, &(a->ns__Account::account_type), ""))
		return soap->error;
	if (soap_out_std__string(soap, "number", -1, &(a->ns__Account::number), ""))
		return soap->error;
	if (soap_out_std__string(soap, "short-number", -1, &(a->ns__Account::short_number), ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->ns__Account::password), ""))
		return soap->error;
	if (soap_out_ns__AccountServiceStatus(soap, "service-status", -1, &(a->ns__Account::service_status), ""))
		return soap->error;
	if (soap_out_uint32(soap, "priority", -1, &(a->ns__Account::priority), ""))
		return soap->error;
	if (soap_out_ns__CallPrivilege(soap, "call-privilege", -1, &(a->ns__Account::call_privilege), ""))
		return soap->error;
	if (soap_out_ns__TokenPrivilege(soap, "token-privilege", -1, &(a->ns__Account::token_privilege), ""))
		return soap->error;
	if (soap_out_ns__GpsReportMode(soap, "gps-report-mode", -1, &(a->ns__Account::gps_report_mode), ""))
		return soap->error;
	if (soap_out_uint32(soap, "ttl", -1, &(a->ns__Account::ttl), ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "status", -1, &(a->ns__Account::status), ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "sip-status", -1, &(a->ns__Account::sip_status), ""))
		return soap->error;
	if ((a->ns__Account::address).soap_out(soap, "address", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Account::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Account(soap, tag, this, type);
}

SOAP_FMAC3 ns__Account * SOAP_FMAC4 soap_in_ns__Account(struct soap *soap, const char *tag, ns__Account *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Account *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Account, sizeof(ns__Account), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Account)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Account *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_account_type1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_short_number1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_service_status1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_call_privilege1 = 1;
	size_t soap_flag_token_privilege1 = 1;
	size_t soap_flag_gps_report_mode1 = 1;
	size_t soap_flag_ttl1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_sip_status1 = 1;
	size_t soap_flag_address1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Account::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_account_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AccountType(soap, "account-type", &(a->ns__Account::account_type), "ns:AccountType"))
				{	soap_flag_account_type1--;
					continue;
				}
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "number", &(a->ns__Account::number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_short_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "short-number", &(a->ns__Account::short_number), "xsd:string"))
				{	soap_flag_short_number1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->ns__Account::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_service_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__AccountServiceStatus(soap, "service-status", &(a->ns__Account::service_status), "ns:AccountServiceStatus"))
				{	soap_flag_service_status1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "priority", &(a->ns__Account::priority), "uint32"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_call_privilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__CallPrivilege(soap, "call-privilege", &(a->ns__Account::call_privilege), "ns:CallPrivilege"))
				{	soap_flag_call_privilege1--;
					continue;
				}
			if (soap_flag_token_privilege1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__TokenPrivilege(soap, "token-privilege", &(a->ns__Account::token_privilege), "ns:TokenPrivilege"))
				{	soap_flag_token_privilege1--;
					continue;
				}
			if (soap_flag_gps_report_mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__GpsReportMode(soap, "gps-report-mode", &(a->ns__Account::gps_report_mode), "ns:GpsReportMode"))
				{	soap_flag_gps_report_mode1--;
					continue;
				}
			if (soap_flag_ttl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "ttl", &(a->ns__Account::ttl), "uint32"))
				{	soap_flag_ttl1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "status", &(a->ns__Account::status), "ns:RegisterStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_sip_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "sip-status", &(a->ns__Account::sip_status), "ns:RegisterStatus"))
				{	soap_flag_sip_status1--;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__Account::address).soap_in(soap, "address", "ns:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Account *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Account, 0, sizeof(ns__Account), 0, soap_copy_ns__Account);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_account_type1 > 0 || soap_flag_number1 > 0 || soap_flag_short_number1 > 0 || soap_flag_password1 > 0 || soap_flag_service_status1 > 0 || soap_flag_priority1 > 0 || soap_flag_call_privilege1 > 0 || soap_flag_token_privilege1 > 0 || soap_flag_gps_report_mode1 > 0 || soap_flag_ttl1 > 0 || soap_flag_status1 > 0 || soap_flag_sip_status1 > 0 || soap_flag_address1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Account::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Account);
	if (this->soap_out(soap, tag?tag:"ns:Account", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Account::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Account(soap, this, tag, type);
}

SOAP_FMAC3 ns__Account * SOAP_FMAC4 soap_get_ns__Account(struct soap *soap, ns__Account *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Account * SOAP_FMAC2 soap_instantiate_ns__Account(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Account(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Account, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Account);
		if (size)
			*size = sizeof(ns__Account);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Account, n);
		if (size)
			*size = n * sizeof(ns__Account);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Account*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Account(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Account %p -> %p\n", q, p));
	*(ns__Account*)p = *(ns__Account*)q;
}

void ns__User::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__User::base.ns__Entity::soap_default(soap);
	soap_default_std__string(soap, &this->ns__User::password);
	soap_default_ns__UserType(soap, &this->ns__User::user_type);
	this->ns__User::account.ns__Entity::soap_default(soap);
	soap_default_ns__RegisterStatus(soap, &this->ns__User::status);
	this->ns__User::address.ns__Address::soap_default(soap);
}

void ns__User::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns__User::base.soap_serialize(soap);
	soap_serialize_std__string(soap, &this->ns__User::password);
	this->ns__User::account.soap_serialize(soap);
	this->ns__User::address.soap_serialize(soap);
#endif
}

int ns__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__User(struct soap *soap, const char *tag, int id, const ns__User *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__User), type))
		return soap->error;
	if ((a->ns__User::base).soap_out(soap, "base", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->ns__User::password), ""))
		return soap->error;
	if (soap_out_ns__UserType(soap, "user-type", -1, &(a->ns__User::user_type), ""))
		return soap->error;
	if ((a->ns__User::account).soap_out(soap, "account", -1, ""))
		return soap->error;
	if (soap_out_ns__RegisterStatus(soap, "status", -1, &(a->ns__User::status), ""))
		return soap->error;
	if ((a->ns__User::address).soap_out(soap, "address", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__User(soap, tag, this, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_in_ns__User(struct soap *soap, const char *tag, ns__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__User, sizeof(ns__User), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__User)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__User *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_user_type1 = 1;
	size_t soap_flag_account1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_address1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__User::base).soap_in(soap, "base", "ns:Entity"))
				{	soap_flag_base1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->ns__User::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_user_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__UserType(soap, "user-type", &(a->ns__User::user_type), "ns:UserType"))
				{	soap_flag_user_type1--;
					continue;
				}
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__User::account).soap_in(soap, "account", "ns:Entity"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__RegisterStatus(soap, "status", &(a->ns__User::status), "ns:RegisterStatus"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns__User::address).soap_in(soap, "address", "ns:Address"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__User, 0, sizeof(ns__User), 0, soap_copy_ns__User);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_password1 > 0 || soap_flag_user_type1 > 0 || soap_flag_account1 > 0 || soap_flag_status1 > 0 || soap_flag_address1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__User);
	if (this->soap_out(soap, tag?tag:"ns:User", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__User(soap, this, tag, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_get_ns__User(struct soap *soap, ns__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__User * SOAP_FMAC2 soap_instantiate_ns__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__User, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__User);
		if (size)
			*size = sizeof(ns__User);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__User, n);
		if (size)
			*size = n * sizeof(ns__User);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__User %p -> %p\n", q, p));
	*(ns__User*)p = *(ns__User*)q;
}

void ns__Address::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->ns__Address::ip);
	soap_default_uint32(soap, &this->ns__Address::port);
}

void ns__Address::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns__Address::ip);
#endif
}

int ns__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Address(struct soap *soap, const char *tag, int id, const ns__Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Address), type))
		return soap->error;
	if (soap_out_std__string(soap, "ip", -1, &(a->ns__Address::ip), ""))
		return soap->error;
	if (soap_out_uint32(soap, "port", -1, &(a->ns__Address::port), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Address(soap, tag, this, type);
}

SOAP_FMAC3 ns__Address * SOAP_FMAC4 soap_in_ns__Address(struct soap *soap, const char *tag, ns__Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Address, sizeof(ns__Address), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Address)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ip1 = 1;
	size_t soap_flag_port1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ip", &(a->ns__Address::ip), "xsd:string"))
				{	soap_flag_ip1--;
					continue;
				}
			if (soap_flag_port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "port", &(a->ns__Address::port), "uint32"))
				{	soap_flag_port1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Address, 0, sizeof(ns__Address), 0, soap_copy_ns__Address);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ip1 > 0 || soap_flag_port1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Address);
	if (this->soap_out(soap, tag?tag:"ns:Address", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Address(soap, this, tag, type);
}

SOAP_FMAC3 ns__Address * SOAP_FMAC4 soap_get_ns__Address(struct soap *soap, ns__Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Address * SOAP_FMAC2 soap_instantiate_ns__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Address);
		if (size)
			*size = sizeof(ns__Address);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Address, n);
		if (size)
			*size = n * sizeof(ns__Address);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Address %p -> %p\n", q, p));
	*(ns__Address*)p = *(ns__Address*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns__Entity::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_uint32(soap, &this->ns__Entity::id);
	soap_default_std__string(soap, &this->ns__Entity::name);
	soap_default_ns__EntityType(soap, &this->ns__Entity::entity_type);
	soap_default_uint32(soap, &this->ns__Entity::parentid);
}

void ns__Entity::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->ns__Entity::name);
#endif
}

int ns__Entity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Entity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Entity(struct soap *soap, const char *tag, int id, const ns__Entity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Entity), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &(a->ns__Entity::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns__Entity::name), ""))
		return soap->error;
	if (soap_out_ns__EntityType(soap, "entity-type", -1, &(a->ns__Entity::entity_type), ""))
		return soap->error;
	if (soap_out_uint32(soap, "parentid", -1, &(a->ns__Entity::parentid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Entity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Entity(soap, tag, this, type);
}

SOAP_FMAC3 ns__Entity * SOAP_FMAC4 soap_in_ns__Entity(struct soap *soap, const char *tag, ns__Entity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Entity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Entity, sizeof(ns__Entity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns__Entity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__Entity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_entity_type1 = 1;
	size_t soap_flag_parentid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &(a->ns__Entity::id), "uint32"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns__Entity::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_entity_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__EntityType(soap, "entity-type", &(a->ns__Entity::entity_type), "ns:EntityType"))
				{	soap_flag_entity_type1--;
					continue;
				}
			if (soap_flag_parentid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "parentid", &(a->ns__Entity::parentid), "uint32"))
				{	soap_flag_parentid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Entity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Entity, 0, sizeof(ns__Entity), 0, soap_copy_ns__Entity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_entity_type1 > 0 || soap_flag_parentid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns__Entity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns__Entity);
	if (this->soap_out(soap, tag?tag:"ns:Entity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Entity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Entity(soap, this, tag, type);
}

SOAP_FMAC3 ns__Entity * SOAP_FMAC4 soap_get_ns__Entity(struct soap *soap, ns__Entity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns__Entity * SOAP_FMAC2 soap_instantiate_ns__Entity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Entity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Entity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns__Entity);
		if (size)
			*size = sizeof(ns__Entity);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns__Entity, n);
		if (size)
			*size = n * sizeof(ns__Entity);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns__Entity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Entity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__Entity %p -> %p\n", q, p));
	*(ns__Entity*)p = *(ns__Entity*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_uint32(soap, &a->history_alert_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, const struct ns__Dispatch_Delete_History_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Delete_History_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request), type))
		return soap->error;
	if (soap_out_uint32(soap, "history-alert-id", -1, &a->history_alert_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Delete_History_Alert_Request *a, const char *type)
{
	size_t soap_flag_history_alert_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Delete_History_Alert_Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request, sizeof(struct ns__Dispatch_Delete_History_Alert_Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Delete_History_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_history_alert_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "history-alert-id", &a->history_alert_id, "uint32"))
				{	soap_flag_history_alert_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Delete_History_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request, 0, sizeof(struct ns__Dispatch_Delete_History_Alert_Request), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_history_alert_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, const struct ns__Dispatch_Delete_History_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request);
	if (soap_out_ns__Dispatch_Delete_History_Alert_Request(soap, tag?tag:"ns:Dispatch-Delete-History-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Delete_History_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Delete_History_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Delete_History_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Delete_History_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Delete_History_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Delete_History_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Delete_History_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Delete_History_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Delete_History_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Delete_History_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Delete_History_Alert_Request*)p = *(struct ns__Dispatch_Delete_History_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Delete_History_Alert_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Delete_History_Alert_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Delete_History_Alert_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Delete_History_Alert_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response, sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Delete_History_Alert_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Delete_History_Alert_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response, 0, sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Delete_History_Alert_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response);
	if (soap_out_ns__Dispatch_Delete_History_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Delete-History-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Delete_History_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Delete_History_Alert_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Delete_History_Alert_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Delete_History_Alert_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Delete_History_Alert_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Delete_History_Alert_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Delete_History_Alert_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Delete_History_Alert_Request_Response*)p = *(struct ns__Dispatch_Delete_History_Alert_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, struct ns__Dispatch_History_Alert_Message_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_uint32(soap, &a->history_alert_id);
	soap_default_uint32(soap, &a->from_message_id);
	soap_default_std__string(soap, &a->from_time);
	soap_default_uint32(soap, &a->max_message_count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, const struct ns__Dispatch_History_Alert_Message_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->from_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_History_Alert_Message_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request), type))
		return soap->error;
	if (soap_out_uint32(soap, "history-alert-id", -1, &a->history_alert_id, ""))
		return soap->error;
	if (soap_out_uint32(soap, "from-message-id", -1, &a->from_message_id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "from-time", -1, &a->from_time, ""))
		return soap->error;
	if (soap_out_uint32(soap, "max-message-count", -1, &a->max_message_count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_Message_Request * SOAP_FMAC4 soap_in_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, const char *tag, struct ns__Dispatch_History_Alert_Message_Request *a, const char *type)
{
	size_t soap_flag_history_alert_id = 1;
	size_t soap_flag_from_message_id = 1;
	size_t soap_flag_from_time = 1;
	size_t soap_flag_max_message_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_History_Alert_Message_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request, sizeof(struct ns__Dispatch_History_Alert_Message_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_History_Alert_Message_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_history_alert_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "history-alert-id", &a->history_alert_id, "uint32"))
				{	soap_flag_history_alert_id--;
					continue;
				}
			if (soap_flag_from_message_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "from-message-id", &a->from_message_id, "uint32"))
				{	soap_flag_from_message_id--;
					continue;
				}
			if (soap_flag_from_time && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "from-time", &a->from_time, "xsd:string"))
				{	soap_flag_from_time--;
					continue;
				}
			if (soap_flag_max_message_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "max-message-count", &a->max_message_count, "uint32"))
				{	soap_flag_max_message_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_History_Alert_Message_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request, 0, sizeof(struct ns__Dispatch_History_Alert_Message_Request), 0, soap_copy_ns__Dispatch_History_Alert_Message_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_history_alert_id > 0 || soap_flag_from_message_id > 0 || soap_flag_from_time > 0 || soap_flag_max_message_count > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, const struct ns__Dispatch_History_Alert_Message_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request);
	if (soap_out_ns__Dispatch_History_Alert_Message_Request(soap, tag?tag:"ns:Dispatch-History-Alert-Message-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_Message_Request * SOAP_FMAC4 soap_get_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, struct ns__Dispatch_History_Alert_Message_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_History_Alert_Message_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_History_Alert_Message_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_History_Alert_Message_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_History_Alert_Message_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_History_Alert_Message_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_History_Alert_Message_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_History_Alert_Message_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_History_Alert_Message_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_History_Alert_Message_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_History_Alert_Message_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_History_Alert_Message_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_History_Alert_Message_Request*)p = *(struct ns__Dispatch_History_Alert_Message_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Alert_Request(struct soap *soap, struct ns__Dispatch_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_uint32(soap, &a->alert_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Alert_Request(struct soap *soap, const struct ns__Dispatch_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Alert_Request), type))
		return soap->error;
	if (soap_out_uint32(soap, "alert-id", -1, &a->alert_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Alert_Request *a, const char *type)
{
	size_t soap_flag_alert_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Alert_Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Alert_Request, sizeof(struct ns__Dispatch_Alert_Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alert_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "alert-id", &a->alert_id, "uint32"))
				{	soap_flag_alert_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Alert_Request, 0, sizeof(struct ns__Dispatch_Alert_Request), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alert_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Alert_Request(struct soap *soap, const struct ns__Dispatch_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Alert_Request);
	if (soap_out_ns__Dispatch_Alert_Request(soap, tag?tag:"ns:Dispatch-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Alert_Request(struct soap *soap, struct ns__Dispatch_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Alert_Request*)p = *(struct ns__Dispatch_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_History_Alert_Request(struct soap *soap, struct ns__Dispatch_History_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->create_time_from);
	soap_default_std__string(soap, &a->create_time_to);
	soap_default_std__string(soap, &a->alram_time_from);
	soap_default_std__string(soap, &a->alram_time_to);
	soap_default_std__string(soap, &a->over_time_from);
	soap_default_std__string(soap, &a->over_time_to);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_History_Alert_Request(struct soap *soap, const struct ns__Dispatch_History_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->name);
	soap_serialize_std__string(soap, &a->create_time_from);
	soap_serialize_std__string(soap, &a->create_time_to);
	soap_serialize_std__string(soap, &a->alram_time_from);
	soap_serialize_std__string(soap, &a->alram_time_to);
	soap_serialize_std__string(soap, &a->over_time_from);
	soap_serialize_std__string(soap, &a->over_time_to);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_History_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_History_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Request), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "create-time-from", -1, &a->create_time_from, ""))
		return soap->error;
	if (soap_out_std__string(soap, "create-time-to", -1, &a->create_time_to, ""))
		return soap->error;
	if (soap_out_std__string(soap, "alram-time-from", -1, &a->alram_time_from, ""))
		return soap->error;
	if (soap_out_std__string(soap, "alram-time-to", -1, &a->alram_time_to, ""))
		return soap->error;
	if (soap_out_std__string(soap, "over-time-from", -1, &a->over_time_from, ""))
		return soap->error;
	if (soap_out_std__string(soap, "over-time-to", -1, &a->over_time_to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_History_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_History_Alert_Request *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_create_time_from = 1;
	size_t soap_flag_create_time_to = 1;
	size_t soap_flag_alram_time_from = 1;
	size_t soap_flag_alram_time_to = 1;
	size_t soap_flag_over_time_from = 1;
	size_t soap_flag_over_time_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_History_Alert_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_History_Alert_Request, sizeof(struct ns__Dispatch_History_Alert_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_History_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_create_time_from && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "create-time-from", &a->create_time_from, "xsd:string"))
				{	soap_flag_create_time_from--;
					continue;
				}
			if (soap_flag_create_time_to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "create-time-to", &a->create_time_to, "xsd:string"))
				{	soap_flag_create_time_to--;
					continue;
				}
			if (soap_flag_alram_time_from && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alram-time-from", &a->alram_time_from, "xsd:string"))
				{	soap_flag_alram_time_from--;
					continue;
				}
			if (soap_flag_alram_time_to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alram-time-to", &a->alram_time_to, "xsd:string"))
				{	soap_flag_alram_time_to--;
					continue;
				}
			if (soap_flag_over_time_from && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "over-time-from", &a->over_time_from, "xsd:string"))
				{	soap_flag_over_time_from--;
					continue;
				}
			if (soap_flag_over_time_to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "over-time-to", &a->over_time_to, "xsd:string"))
				{	soap_flag_over_time_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_History_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_History_Alert_Request, 0, sizeof(struct ns__Dispatch_History_Alert_Request), 0, soap_copy_ns__Dispatch_History_Alert_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_create_time_from > 0 || soap_flag_create_time_to > 0 || soap_flag_alram_time_from > 0 || soap_flag_alram_time_to > 0 || soap_flag_over_time_from > 0 || soap_flag_over_time_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_History_Alert_Request(struct soap *soap, const struct ns__Dispatch_History_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_History_Alert_Request);
	if (soap_out_ns__Dispatch_History_Alert_Request(soap, tag?tag:"ns:Dispatch-History-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_History_Alert_Request(struct soap *soap, struct ns__Dispatch_History_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_History_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_History_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_History_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_History_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_History_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_History_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_History_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_History_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_History_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_History_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_History_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_History_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_History_Alert_Request*)p = *(struct ns__Dispatch_History_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, struct ns__Dispatch_History_Alert_RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__listTemplateOfns__HistoryAlert(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, const struct ns__Dispatch_History_Alert_RequestResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__listTemplateOfns__HistoryAlert(soap, &a->response);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_History_Alert_RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse), type))
		return soap->error;
	if (soap_out_std__listTemplateOfns__HistoryAlert(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_RequestResponse * SOAP_FMAC4 soap_in_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, const char *tag, struct ns__Dispatch_History_Alert_RequestResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_History_Alert_RequestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse, sizeof(struct ns__Dispatch_History_Alert_RequestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_History_Alert_RequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOfns__HistoryAlert(soap, "response", &a->response, "ns:HistoryAlert"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_History_Alert_RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse, 0, sizeof(struct ns__Dispatch_History_Alert_RequestResponse), 0, soap_copy_ns__Dispatch_History_Alert_RequestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->response.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, const struct ns__Dispatch_History_Alert_RequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse);
	if (soap_out_ns__Dispatch_History_Alert_RequestResponse(soap, tag?tag:"ns:Dispatch-History-Alert-RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_History_Alert_RequestResponse * SOAP_FMAC4 soap_get_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, struct ns__Dispatch_History_Alert_RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_History_Alert_RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_History_Alert_RequestResponse * SOAP_FMAC2 soap_instantiate_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_History_Alert_RequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_History_Alert_RequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_History_Alert_RequestResponse);
		if (size)
			*size = sizeof(struct ns__Dispatch_History_Alert_RequestResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_History_Alert_RequestResponse, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_History_Alert_RequestResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_History_Alert_RequestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_History_Alert_RequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_History_Alert_RequestResponse %p -> %p\n", q, p));
	*(struct ns__Dispatch_History_Alert_RequestResponse*)p = *(struct ns__Dispatch_History_Alert_RequestResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, const struct ns__Dispatch_Alert_Overed_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Alert_Overed_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification), type))
		return soap->error;
	if (a->alert_id.soap_out(soap, "alert-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Alert_Overed_Notification *a, const char *type)
{
	size_t soap_flag_alert_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Alert_Overed_Notification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification, sizeof(struct ns__Dispatch_Alert_Overed_Notification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Alert_Overed_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alert_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->alert_id.soap_in(soap, "alert-id", "ns:Entity"))
				{	soap_flag_alert_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Alert_Overed_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification, 0, sizeof(struct ns__Dispatch_Alert_Overed_Notification), 0, soap_copy_ns__Dispatch_Alert_Overed_Notification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alert_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, const struct ns__Dispatch_Alert_Overed_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification);
	if (soap_out_ns__Dispatch_Alert_Overed_Notification(soap, tag?tag:"ns:Dispatch-Alert-Overed-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Alert_Overed_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Alert_Overed_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Alert_Overed_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Alert_Overed_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Alert_Overed_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Alert_Overed_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Alert_Overed_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Alert_Overed_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Alert_Overed_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Alert_Overed_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Alert_Overed_Notification*)p = *(struct ns__Dispatch_Alert_Overed_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const struct ns__Dispatch_Alert_Overed_Notification_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Alert_Overed_Notification_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Alert_Overed_Notification_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Alert_Overed_Notification_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response, sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Alert_Overed_Notification_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Alert_Overed_Notification_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response, 0, sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const struct ns__Dispatch_Alert_Overed_Notification_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response);
	if (soap_out_ns__Dispatch_Alert_Overed_Notification_Response(soap, tag?tag:"ns:Dispatch-Alert-Overed-Notification-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Alert_Overed_Notification_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Alert_Overed_Notification_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Alert_Overed_Notification_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Alert_Overed_Notification_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Alert_Overed_Notification_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Alert_Overed_Notification_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Alert_Overed_Notification_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Alert_Overed_Notification_Response*)p = *(struct ns__Dispatch_Alert_Overed_Notification_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Stop_Alert_Request(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Stop_Alert_Request(struct soap *soap, const struct ns__Dispatch_Stop_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Stop_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Stop_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request), type))
		return soap->error;
	if (a->alert_id.soap_out(soap, "alert-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Stop_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Alert_Request *a, const char *type)
{
	size_t soap_flag_alert_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Stop_Alert_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request, sizeof(struct ns__Dispatch_Stop_Alert_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Stop_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alert_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->alert_id.soap_in(soap, "alert-id", "ns:Entity"))
				{	soap_flag_alert_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request, 0, sizeof(struct ns__Dispatch_Stop_Alert_Request), 0, soap_copy_ns__Dispatch_Stop_Alert_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alert_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Stop_Alert_Request(struct soap *soap, const struct ns__Dispatch_Stop_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request);
	if (soap_out_ns__Dispatch_Stop_Alert_Request(soap, tag?tag:"ns:Dispatch-Stop-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Stop_Alert_Request(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Stop_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Stop_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Stop_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Stop_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Stop_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Stop_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Stop_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Stop_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Stop_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Stop_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Stop_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Stop_Alert_Request*)p = *(struct ns__Dispatch_Stop_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Stop_Alert_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Stop_Alert_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Alert_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Stop_Alert_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response, sizeof(struct ns__Dispatch_Stop_Alert_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Stop_Alert_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Alert_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response, 0, sizeof(struct ns__Dispatch_Stop_Alert_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Stop_Alert_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response);
	if (soap_out_ns__Dispatch_Stop_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Stop-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Stop_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Stop_Alert_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Stop_Alert_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Stop_Alert_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Stop_Alert_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Stop_Alert_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Stop_Alert_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Stop_Alert_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Stop_Alert_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Stop_Alert_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Stop_Alert_Request_Response*)p = *(struct ns__Dispatch_Stop_Alert_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Modify_Alert_Request(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert.ns__Alert::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Modify_Alert_Request(struct soap *soap, const struct ns__Dispatch_Modify_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Modify_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Modify_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request), type))
		return soap->error;
	if (a->alert.soap_out(soap, "alert", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Modify_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Modify_Alert_Request *a, const char *type)
{
	size_t soap_flag_alert = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Modify_Alert_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request, sizeof(struct ns__Dispatch_Modify_Alert_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Modify_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alert && soap->error == SOAP_TAG_MISMATCH)
				if (a->alert.soap_in(soap, "alert", "ns:Alert"))
				{	soap_flag_alert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Modify_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request, 0, sizeof(struct ns__Dispatch_Modify_Alert_Request), 0, soap_copy_ns__Dispatch_Modify_Alert_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alert > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Modify_Alert_Request(struct soap *soap, const struct ns__Dispatch_Modify_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request);
	if (soap_out_ns__Dispatch_Modify_Alert_Request(soap, tag?tag:"ns:Dispatch-Modify-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Modify_Alert_Request(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Modify_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Modify_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Modify_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Modify_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Modify_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Modify_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Modify_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Modify_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Modify_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Modify_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Modify_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Modify_Alert_Request*)p = *(struct ns__Dispatch_Modify_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Modify_Alert_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Modify_Alert_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Modify_Alert_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Modify_Alert_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response, sizeof(struct ns__Dispatch_Modify_Alert_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Modify_Alert_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Modify_Alert_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response, 0, sizeof(struct ns__Dispatch_Modify_Alert_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const struct ns__Dispatch_Modify_Alert_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response);
	if (soap_out_ns__Dispatch_Modify_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Modify-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Modify_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Modify_Alert_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Modify_Alert_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Modify_Alert_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Modify_Alert_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Modify_Alert_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Modify_Alert_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Modify_Alert_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Modify_Alert_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Modify_Alert_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Modify_Alert_Request_Response*)p = *(struct ns__Dispatch_Modify_Alert_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Append_Alert_Request(struct soap *soap, struct ns__Dispatch_Append_Alert_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert.ns__Alert::soap_default(soap);
	soap_default_std__listTemplateOfns__Account(soap, &a->acount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Append_Alert_Request(struct soap *soap, const struct ns__Dispatch_Append_Alert_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alert.soap_serialize(soap);
	soap_serialize_std__listTemplateOfns__Account(soap, &a->acount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Append_Alert_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Append_Alert_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Append_Alert_Request), type))
		return soap->error;
	if (a->alert.soap_out(soap, "alert", -1, ""))
		return soap->error;
	if (soap_out_std__listTemplateOfns__Account(soap, "acount", -1, &a->acount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Append_Alert_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Append_Alert_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Append_Alert_Request *a, const char *type)
{
	size_t soap_flag_alert = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Append_Alert_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Append_Alert_Request, sizeof(struct ns__Dispatch_Append_Alert_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Append_Alert_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alert && soap->error == SOAP_TAG_MISMATCH)
				if (a->alert.soap_in(soap, "alert", "ns:Alert"))
				{	soap_flag_alert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__listTemplateOfns__Account(soap, "acount", &a->acount, "ns:Account"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Append_Alert_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Append_Alert_Request, 0, sizeof(struct ns__Dispatch_Append_Alert_Request), 0, soap_copy_ns__Dispatch_Append_Alert_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alert > 0 || a->acount.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Append_Alert_Request(struct soap *soap, const struct ns__Dispatch_Append_Alert_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Append_Alert_Request);
	if (soap_out_ns__Dispatch_Append_Alert_Request(soap, tag?tag:"ns:Dispatch-Append-Alert-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Append_Alert_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Append_Alert_Request(struct soap *soap, struct ns__Dispatch_Append_Alert_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Append_Alert_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Append_Alert_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Append_Alert_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Append_Alert_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Append_Alert_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Append_Alert_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Append_Alert_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Append_Alert_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Append_Alert_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Append_Alert_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Append_Alert_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Append_Alert_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Append_Alert_Request*)p = *(struct ns__Dispatch_Append_Alert_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Account_Location_Notification(struct soap *soap, struct ns__Dispatch_Account_Location_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Account_Location_Notification(struct soap *soap, const struct ns__Dispatch_Account_Location_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Account_Location_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Account_Location_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Account_Location_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Account_Location_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Account_Location_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Account_Location_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Account_Location_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Account_Location_Notification, sizeof(struct ns__Dispatch_Account_Location_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Account_Location_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Account_Location_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Account_Location_Notification, 0, sizeof(struct ns__Dispatch_Account_Location_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Account_Location_Notification(struct soap *soap, const struct ns__Dispatch_Account_Location_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Account_Location_Notification);
	if (soap_out_ns__Dispatch_Account_Location_Notification(soap, tag?tag:"ns:Dispatch-Account-Location-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Account_Location_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Account_Location_Notification(struct soap *soap, struct ns__Dispatch_Account_Location_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Account_Location_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Account_Location_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Account_Location_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Account_Location_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Account_Location_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Account_Location_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Account_Location_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Account_Location_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Account_Location_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Account_Location_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Account_Location_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Account_Location_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Account_Location_Notification*)p = *(struct ns__Dispatch_Account_Location_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->subscribing);
	a->account_id.ns__Entity::soap_default(soap);
	soap_default_uint32(soap, &a->ttl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, const struct ns__Dispatch_Subscribe_Account_Location_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Subscribe_Account_Location_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request), type))
		return soap->error;
	if (soap_out_bool(soap, "subscribing", -1, &a->subscribing, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	if (soap_out_uint32(soap, "ttl", -1, &a->ttl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Subscribe_Account_Location_Request *a, const char *type)
{
	size_t soap_flag_subscribing = 1;
	size_t soap_flag_account_id = 1;
	size_t soap_flag_ttl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Subscribe_Account_Location_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Subscribe_Account_Location_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subscribing && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "subscribing", &a->subscribing, "xsd:boolean"))
				{	soap_flag_subscribing--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap_flag_ttl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "ttl", &a->ttl, "uint32"))
				{	soap_flag_ttl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Subscribe_Account_Location_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request, 0, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request), 0, soap_copy_ns__Dispatch_Subscribe_Account_Location_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subscribing > 0 || soap_flag_account_id > 0 || soap_flag_ttl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, const struct ns__Dispatch_Subscribe_Account_Location_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request);
	if (soap_out_ns__Dispatch_Subscribe_Account_Location_Request(soap, tag?tag:"ns:Dispatch-Subscribe-Account-Location-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Subscribe_Account_Location_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Subscribe_Account_Location_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Subscribe_Account_Location_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Subscribe_Account_Location_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Subscribe_Account_Location_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Subscribe_Account_Location_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Subscribe_Account_Location_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Subscribe_Account_Location_Request*)p = *(struct ns__Dispatch_Subscribe_Account_Location_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const struct ns__Dispatch_Subscribe_Account_Location_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Subscribe_Account_Location_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Subscribe_Account_Location_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Subscribe_Account_Location_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response, 0, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const struct ns__Dispatch_Subscribe_Account_Location_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response);
	if (soap_out_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag?tag:"ns:Dispatch-Subscribe-Account-Location-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Subscribe_Account_Location_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Subscribe_Account_Location_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Subscribe_Account_Location_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Subscribe_Account_Location_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Subscribe_Account_Location_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Subscribe_Account_Location_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Subscribe_Account_Location_Request_Response*)p = *(struct ns__Dispatch_Subscribe_Account_Location_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Record_Status_Notification(struct soap *soap, struct ns__Dispatch_Record_Status_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Record_Status_Notification(struct soap *soap, const struct ns__Dispatch_Record_Status_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Record_Status_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Record_Status_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Record_Status_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Record_Status_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Record_Status_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Record_Status_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Record_Status_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Record_Status_Notification, sizeof(struct ns__Dispatch_Record_Status_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Record_Status_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Record_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Record_Status_Notification, 0, sizeof(struct ns__Dispatch_Record_Status_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Record_Status_Notification(struct soap *soap, const struct ns__Dispatch_Record_Status_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Record_Status_Notification);
	if (soap_out_ns__Dispatch_Record_Status_Notification(soap, tag?tag:"ns:Dispatch-Record-Status-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Record_Status_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Record_Status_Notification(struct soap *soap, struct ns__Dispatch_Record_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Record_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Record_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Record_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Record_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Record_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Record_Status_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Record_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Record_Status_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Record_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Record_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Record_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Record_Status_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Record_Status_Notification*)p = *(struct ns__Dispatch_Record_Status_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Stop_Record_Request(struct soap *soap, struct ns__Dispatch_Stop_Record_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Stop_Record_Request(struct soap *soap, const struct ns__Dispatch_Stop_Record_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Stop_Record_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Stop_Record_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Stop_Record_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Record_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Stop_Record_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request, sizeof(struct ns__Dispatch_Stop_Record_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Stop_Record_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Record_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Stop_Record_Request, 0, sizeof(struct ns__Dispatch_Stop_Record_Request), 0, soap_copy_ns__Dispatch_Stop_Record_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Stop_Record_Request(struct soap *soap, const struct ns__Dispatch_Stop_Record_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Stop_Record_Request);
	if (soap_out_ns__Dispatch_Stop_Record_Request(soap, tag?tag:"ns:Dispatch-Stop-Record-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Stop_Record_Request(struct soap *soap, struct ns__Dispatch_Stop_Record_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Stop_Record_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Stop_Record_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Stop_Record_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Stop_Record_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Stop_Record_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Stop_Record_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Stop_Record_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Stop_Record_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Stop_Record_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Stop_Record_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Stop_Record_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Stop_Record_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Stop_Record_Request*)p = *(struct ns__Dispatch_Stop_Record_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Record_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, const struct ns__Dispatch_Stop_Record_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Stop_Record_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Record_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Stop_Record_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response, sizeof(struct ns__Dispatch_Stop_Record_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Stop_Record_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Record_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response, 0, sizeof(struct ns__Dispatch_Stop_Record_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, const struct ns__Dispatch_Stop_Record_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response);
	if (soap_out_ns__Dispatch_Stop_Record_Request_Response(soap, tag?tag:"ns:Dispatch-Stop-Record-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Record_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Stop_Record_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Stop_Record_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Stop_Record_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Stop_Record_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Stop_Record_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Stop_Record_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Stop_Record_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Stop_Record_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Stop_Record_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Stop_Record_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Stop_Record_Request_Response*)p = *(struct ns__Dispatch_Stop_Record_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Start_Record_Request(struct soap *soap, struct ns__Dispatch_Start_Record_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Start_Record_Request(struct soap *soap, const struct ns__Dispatch_Start_Record_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Start_Record_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Start_Record_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Start_Record_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Start_Record_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Start_Record_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Start_Record_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Start_Record_Request, sizeof(struct ns__Dispatch_Start_Record_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Start_Record_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Start_Record_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Start_Record_Request, 0, sizeof(struct ns__Dispatch_Start_Record_Request), 0, soap_copy_ns__Dispatch_Start_Record_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Start_Record_Request(struct soap *soap, const struct ns__Dispatch_Start_Record_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Start_Record_Request);
	if (soap_out_ns__Dispatch_Start_Record_Request(soap, tag?tag:"ns:Dispatch-Start-Record-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Start_Record_Request(struct soap *soap, struct ns__Dispatch_Start_Record_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Start_Record_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Start_Record_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Start_Record_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Start_Record_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Start_Record_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Start_Record_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Start_Record_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Start_Record_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Start_Record_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Start_Record_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Start_Record_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Start_Record_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Start_Record_Request*)p = *(struct ns__Dispatch_Start_Record_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Start_Record_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, const struct ns__Dispatch_Start_Record_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Start_Record_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Start_Record_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Start_Record_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response, sizeof(struct ns__Dispatch_Start_Record_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Start_Record_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Start_Record_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response, 0, sizeof(struct ns__Dispatch_Start_Record_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, const struct ns__Dispatch_Start_Record_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response);
	if (soap_out_ns__Dispatch_Start_Record_Request_Response(soap, tag?tag:"ns:Dispatch-Start-Record-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Start_Record_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Start_Record_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Start_Record_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Start_Record_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Start_Record_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Start_Record_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Start_Record_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Start_Record_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Start_Record_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Start_Record_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Start_Record_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Start_Record_Request_Response*)p = *(struct ns__Dispatch_Start_Record_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Kick_Participant_Request(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
	a->account_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Kick_Participant_Request(struct soap *soap, const struct ns__Dispatch_Kick_Participant_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Kick_Participant_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Kick_Participant_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Kick_Participant_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Kick_Participant_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	size_t soap_flag_account_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Kick_Participant_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request, sizeof(struct ns__Dispatch_Kick_Participant_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Kick_Participant_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Kick_Participant_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request, 0, sizeof(struct ns__Dispatch_Kick_Participant_Request), 0, soap_copy_ns__Dispatch_Kick_Participant_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0 || soap_flag_account_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Kick_Participant_Request(struct soap *soap, const struct ns__Dispatch_Kick_Participant_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request);
	if (soap_out_ns__Dispatch_Kick_Participant_Request(soap, tag?tag:"ns:Dispatch-Kick-Participant-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Kick_Participant_Request(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Kick_Participant_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Kick_Participant_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Kick_Participant_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Kick_Participant_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Kick_Participant_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Kick_Participant_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Kick_Participant_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Kick_Participant_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Kick_Participant_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Kick_Participant_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Kick_Participant_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Kick_Participant_Request*)p = *(struct ns__Dispatch_Kick_Participant_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Kick_Participant_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Kick_Participant_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Kick_Participant_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Kick_Participant_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response, sizeof(struct ns__Dispatch_Kick_Participant_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Kick_Participant_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Kick_Participant_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response, 0, sizeof(struct ns__Dispatch_Kick_Participant_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Kick_Participant_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response);
	if (soap_out_ns__Dispatch_Kick_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Kick-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Kick_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Kick_Participant_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Kick_Participant_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Kick_Participant_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Kick_Participant_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Kick_Participant_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Kick_Participant_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Kick_Participant_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Kick_Participant_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Kick_Participant_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Kick_Participant_Request_Response*)p = *(struct ns__Dispatch_Kick_Participant_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Send_Message_Request(struct soap *soap, struct ns__Dispatch_Send_Message_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_uint32(soap, &a->id);
	a->message.ns__MediaMessage::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Send_Message_Request(struct soap *soap, const struct ns__Dispatch_Send_Message_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->message.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Send_Message_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Send_Message_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Send_Message_Request), type))
		return soap->error;
	if (soap_out_uint32(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (a->message.soap_out(soap, "message", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Send_Message_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Send_Message_Request *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Send_Message_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Send_Message_Request, sizeof(struct ns__Dispatch_Send_Message_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Send_Message_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "id", &a->id, "uint32"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (a->message.soap_in(soap, "message", "ns:MediaMessage"))
				{	soap_flag_message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Send_Message_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Send_Message_Request, 0, sizeof(struct ns__Dispatch_Send_Message_Request), 0, soap_copy_ns__Dispatch_Send_Message_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Send_Message_Request(struct soap *soap, const struct ns__Dispatch_Send_Message_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Send_Message_Request);
	if (soap_out_ns__Dispatch_Send_Message_Request(soap, tag?tag:"ns:Dispatch-Send-Message-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Send_Message_Request(struct soap *soap, struct ns__Dispatch_Send_Message_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Send_Message_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Send_Message_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Send_Message_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Send_Message_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Send_Message_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Send_Message_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Send_Message_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Send_Message_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Send_Message_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Send_Message_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Send_Message_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Send_Message_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Send_Message_Request*)p = *(struct ns__Dispatch_Send_Message_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, struct ns__Dispatch_Send_Message_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, const struct ns__Dispatch_Send_Message_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Send_Message_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Send_Message_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Send_Message_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response, sizeof(struct ns__Dispatch_Send_Message_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Send_Message_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Send_Message_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response, 0, sizeof(struct ns__Dispatch_Send_Message_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, const struct ns__Dispatch_Send_Message_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response);
	if (soap_out_ns__Dispatch_Send_Message_Request_Response(soap, tag?tag:"ns:Dispatch-Send-Message-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, struct ns__Dispatch_Send_Message_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Send_Message_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Send_Message_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Send_Message_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Send_Message_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Send_Message_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Send_Message_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Send_Message_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Send_Message_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Send_Message_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Send_Message_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Send_Message_Request_Response*)p = *(struct ns__Dispatch_Send_Message_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Session_Status_Notification(struct soap *soap, struct ns__Dispatch_Session_Status_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Session_Status_Notification(struct soap *soap, const struct ns__Dispatch_Session_Status_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Session_Status_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Session_Status_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Session_Status_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Session_Status_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Session_Status_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Session_Status_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Session_Status_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Session_Status_Notification, sizeof(struct ns__Dispatch_Session_Status_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Session_Status_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Session_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Session_Status_Notification, 0, sizeof(struct ns__Dispatch_Session_Status_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Session_Status_Notification(struct soap *soap, const struct ns__Dispatch_Session_Status_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Session_Status_Notification);
	if (soap_out_ns__Dispatch_Session_Status_Notification(soap, tag?tag:"ns:Dispatch-Session-Status-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Session_Status_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Session_Status_Notification(struct soap *soap, struct ns__Dispatch_Session_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Session_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Session_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Session_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Session_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Session_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Session_Status_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Session_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Session_Status_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Session_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Session_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Session_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Session_Status_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Session_Status_Notification*)p = *(struct ns__Dispatch_Session_Status_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Leave_Group_Request(struct soap *soap, struct ns__Dispatch_Leave_Group_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Leave_Group_Request(struct soap *soap, const struct ns__Dispatch_Leave_Group_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Leave_Group_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Leave_Group_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Leave_Group_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Leave_Group_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Leave_Group_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request, sizeof(struct ns__Dispatch_Leave_Group_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Leave_Group_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Leave_Group_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Leave_Group_Request, 0, sizeof(struct ns__Dispatch_Leave_Group_Request), 0, soap_copy_ns__Dispatch_Leave_Group_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Leave_Group_Request(struct soap *soap, const struct ns__Dispatch_Leave_Group_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Leave_Group_Request);
	if (soap_out_ns__Dispatch_Leave_Group_Request(soap, tag?tag:"ns:Dispatch-Leave-Group-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Leave_Group_Request(struct soap *soap, struct ns__Dispatch_Leave_Group_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Leave_Group_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Leave_Group_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Leave_Group_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Leave_Group_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Leave_Group_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Leave_Group_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Leave_Group_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Leave_Group_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Leave_Group_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Leave_Group_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Leave_Group_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Leave_Group_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Leave_Group_Request*)p = *(struct ns__Dispatch_Leave_Group_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Leave_Group_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, const struct ns__Dispatch_Leave_Group_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Leave_Group_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Leave_Group_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Leave_Group_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response, sizeof(struct ns__Dispatch_Leave_Group_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Leave_Group_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Leave_Group_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response, 0, sizeof(struct ns__Dispatch_Leave_Group_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, const struct ns__Dispatch_Leave_Group_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response);
	if (soap_out_ns__Dispatch_Leave_Group_Request_Response(soap, tag?tag:"ns:Dispatch-Leave-Group-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Leave_Group_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Leave_Group_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Leave_Group_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Leave_Group_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Leave_Group_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Leave_Group_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Leave_Group_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Leave_Group_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Leave_Group_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Leave_Group_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Leave_Group_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Leave_Group_Request_Response*)p = *(struct ns__Dispatch_Leave_Group_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Jion_Group_Request(struct soap *soap, struct ns__Dispatch_Jion_Group_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Jion_Group_Request(struct soap *soap, const struct ns__Dispatch_Jion_Group_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Jion_Group_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Jion_Group_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Jion_Group_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Jion_Group_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Jion_Group_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request, sizeof(struct ns__Dispatch_Jion_Group_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Jion_Group_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Jion_Group_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Jion_Group_Request, 0, sizeof(struct ns__Dispatch_Jion_Group_Request), 0, soap_copy_ns__Dispatch_Jion_Group_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Jion_Group_Request(struct soap *soap, const struct ns__Dispatch_Jion_Group_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Jion_Group_Request);
	if (soap_out_ns__Dispatch_Jion_Group_Request(soap, tag?tag:"ns:Dispatch-Jion-Group-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Jion_Group_Request(struct soap *soap, struct ns__Dispatch_Jion_Group_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Jion_Group_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Jion_Group_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Jion_Group_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Jion_Group_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Jion_Group_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Jion_Group_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Jion_Group_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Jion_Group_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Jion_Group_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Jion_Group_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Jion_Group_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Jion_Group_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Jion_Group_Request*)p = *(struct ns__Dispatch_Jion_Group_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Jion_Group_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, const struct ns__Dispatch_Jion_Group_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Jion_Group_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Jion_Group_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Jion_Group_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response, sizeof(struct ns__Dispatch_Jion_Group_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Jion_Group_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Jion_Group_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response, 0, sizeof(struct ns__Dispatch_Jion_Group_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, const struct ns__Dispatch_Jion_Group_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response);
	if (soap_out_ns__Dispatch_Jion_Group_Request_Response(soap, tag?tag:"ns:Dispatch-Jion-Group-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Jion_Group_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Jion_Group_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Jion_Group_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Jion_Group_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Jion_Group_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Jion_Group_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Jion_Group_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Jion_Group_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Jion_Group_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Jion_Group_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Jion_Group_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Jion_Group_Request_Response*)p = *(struct ns__Dispatch_Jion_Group_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
	a->account_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, const struct ns__Dispatch_Appoint_Participant_Speak_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Appoint_Participant_Speak_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Appoint_Participant_Speak_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	size_t soap_flag_account_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Appoint_Participant_Speak_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Appoint_Participant_Speak_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Appoint_Participant_Speak_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request, 0, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request), 0, soap_copy_ns__Dispatch_Appoint_Participant_Speak_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0 || soap_flag_account_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, const struct ns__Dispatch_Appoint_Participant_Speak_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request);
	if (soap_out_ns__Dispatch_Appoint_Participant_Speak_Request(soap, tag?tag:"ns:Dispatch-Appoint-Participant-Speak-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Appoint_Participant_Speak_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Appoint_Participant_Speak_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Appoint_Participant_Speak_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Appoint_Participant_Speak_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Appoint_Participant_Speak_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Appoint_Participant_Speak_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Appoint_Participant_Speak_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Appoint_Participant_Speak_Request*)p = *(struct ns__Dispatch_Appoint_Participant_Speak_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response, 0, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response);
	if (soap_out_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag?tag:"ns:Dispatch-Appoint-Participant-Speak-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Appoint_Participant_Speak_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Appoint_Participant_Speak_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Appoint_Participant_Speak_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response*)p = *(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
	a->account_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, const struct ns__Dispatch_Release_Participant_Token_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Release_Participant_Token_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Release_Participant_Token_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	size_t soap_flag_account_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Release_Participant_Token_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request, sizeof(struct ns__Dispatch_Release_Participant_Token_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Release_Participant_Token_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Release_Participant_Token_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request, 0, sizeof(struct ns__Dispatch_Release_Participant_Token_Request), 0, soap_copy_ns__Dispatch_Release_Participant_Token_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0 || soap_flag_account_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, const struct ns__Dispatch_Release_Participant_Token_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request);
	if (soap_out_ns__Dispatch_Release_Participant_Token_Request(soap, tag?tag:"ns:Dispatch-Release-Participant-Token-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Release_Participant_Token_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Release_Participant_Token_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Release_Participant_Token_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Release_Participant_Token_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Release_Participant_Token_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Release_Participant_Token_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Release_Participant_Token_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Release_Participant_Token_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Release_Participant_Token_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Release_Participant_Token_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Release_Participant_Token_Request*)p = *(struct ns__Dispatch_Release_Participant_Token_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const struct ns__Dispatch_Release_Participant_Token_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Release_Participant_Token_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Release_Participant_Token_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Release_Participant_Token_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response, sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Release_Participant_Token_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Release_Participant_Token_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response, 0, sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const struct ns__Dispatch_Release_Participant_Token_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response);
	if (soap_out_ns__Dispatch_Release_Participant_Token_Request_Response(soap, tag?tag:"ns:Dispatch-Release-Participant-Token-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Release_Participant_Token_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Release_Participant_Token_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Release_Participant_Token_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Release_Participant_Token_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Release_Participant_Token_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Release_Participant_Token_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Release_Participant_Token_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Release_Participant_Token_Request_Response*)p = *(struct ns__Dispatch_Release_Participant_Token_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Drop_Participant_Request(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
	a->account_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Drop_Participant_Request(struct soap *soap, const struct ns__Dispatch_Drop_Participant_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Drop_Participant_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Drop_Participant_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Drop_Participant_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Drop_Participant_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	size_t soap_flag_account_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Drop_Participant_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request, sizeof(struct ns__Dispatch_Drop_Participant_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Drop_Participant_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Drop_Participant_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request, 0, sizeof(struct ns__Dispatch_Drop_Participant_Request), 0, soap_copy_ns__Dispatch_Drop_Participant_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0 || soap_flag_account_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Drop_Participant_Request(struct soap *soap, const struct ns__Dispatch_Drop_Participant_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request);
	if (soap_out_ns__Dispatch_Drop_Participant_Request(soap, tag?tag:"ns:Dispatch-Drop-Participant-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Drop_Participant_Request(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Drop_Participant_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Drop_Participant_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Drop_Participant_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Drop_Participant_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Drop_Participant_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Drop_Participant_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Drop_Participant_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Drop_Participant_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Drop_Participant_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Drop_Participant_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Drop_Participant_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Drop_Participant_Request*)p = *(struct ns__Dispatch_Drop_Participant_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Drop_Participant_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Drop_Participant_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Drop_Participant_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Drop_Participant_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response, sizeof(struct ns__Dispatch_Drop_Participant_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Drop_Participant_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Drop_Participant_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response, 0, sizeof(struct ns__Dispatch_Drop_Participant_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Drop_Participant_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response);
	if (soap_out_ns__Dispatch_Drop_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Drop-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Drop_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Drop_Participant_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Drop_Participant_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Drop_Participant_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Drop_Participant_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Drop_Participant_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Drop_Participant_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Drop_Participant_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Drop_Participant_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Drop_Participant_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Drop_Participant_Request_Response*)p = *(struct ns__Dispatch_Drop_Participant_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Invite_Participant_Request(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
	a->account_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Invite_Participant_Request(struct soap *soap, const struct ns__Dispatch_Invite_Participant_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
	a->account_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Invite_Participant_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Invite_Participant_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	if (a->account_id.soap_out(soap, "account-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Invite_Participant_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Invite_Participant_Request *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	size_t soap_flag_account_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Invite_Participant_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request, sizeof(struct ns__Dispatch_Invite_Participant_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Invite_Participant_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap_flag_account_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->account_id.soap_in(soap, "account-id", "ns:Entity"))
				{	soap_flag_account_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Invite_Participant_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request, 0, sizeof(struct ns__Dispatch_Invite_Participant_Request), 0, soap_copy_ns__Dispatch_Invite_Participant_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0 || soap_flag_account_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Invite_Participant_Request(struct soap *soap, const struct ns__Dispatch_Invite_Participant_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request);
	if (soap_out_ns__Dispatch_Invite_Participant_Request(soap, tag?tag:"ns:Dispatch-Invite-Participant-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Invite_Participant_Request(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Invite_Participant_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Invite_Participant_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Invite_Participant_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Invite_Participant_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Invite_Participant_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Invite_Participant_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Invite_Participant_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Invite_Participant_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Invite_Participant_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Invite_Participant_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Invite_Participant_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Invite_Participant_Request*)p = *(struct ns__Dispatch_Invite_Participant_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Invite_Participant_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Invite_Participant_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Invite_Participant_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Invite_Participant_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response, sizeof(struct ns__Dispatch_Invite_Participant_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Invite_Participant_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Invite_Participant_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response, 0, sizeof(struct ns__Dispatch_Invite_Participant_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const struct ns__Dispatch_Invite_Participant_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response);
	if (soap_out_ns__Dispatch_Invite_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Invite-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Invite_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Invite_Participant_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Invite_Participant_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Invite_Participant_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Invite_Participant_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Invite_Participant_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Invite_Participant_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Invite_Participant_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Invite_Participant_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Invite_Participant_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Invite_Participant_Request_Response*)p = *(struct ns__Dispatch_Invite_Participant_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, struct ns__Dispatch_Participant_Speak_Request_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Speak_Request_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Participant_Speak_Request_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Speak_Request_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Participant_Speak_Request_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Participant_Speak_Request_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification, sizeof(struct ns__Dispatch_Participant_Speak_Request_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Participant_Speak_Request_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Participant_Speak_Request_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification, 0, sizeof(struct ns__Dispatch_Participant_Speak_Request_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Speak_Request_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification);
	if (soap_out_ns__Dispatch_Participant_Speak_Request_Notification(soap, tag?tag:"ns:Dispatch-Participant-Speak-Request-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Speak_Request_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, struct ns__Dispatch_Participant_Speak_Request_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Participant_Speak_Request_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Participant_Speak_Request_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Participant_Speak_Request_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Participant_Speak_Request_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Participant_Speak_Request_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Participant_Speak_Request_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Participant_Speak_Request_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Participant_Speak_Request_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Participant_Speak_Request_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Participant_Speak_Request_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Participant_Speak_Request_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Participant_Speak_Request_Notification*)p = *(struct ns__Dispatch_Participant_Speak_Request_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, struct ns__Dispatch_Participant_Connect_Request_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Connect_Request_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Participant_Connect_Request_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Connect_Request_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Participant_Connect_Request_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Participant_Connect_Request_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification, sizeof(struct ns__Dispatch_Participant_Connect_Request_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Participant_Connect_Request_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Participant_Connect_Request_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification, 0, sizeof(struct ns__Dispatch_Participant_Connect_Request_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Connect_Request_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification);
	if (soap_out_ns__Dispatch_Participant_Connect_Request_Notification(soap, tag?tag:"ns:Dispatch-Participant-Connect-Request-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Connect_Request_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, struct ns__Dispatch_Participant_Connect_Request_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Participant_Connect_Request_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Participant_Connect_Request_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Participant_Connect_Request_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Participant_Connect_Request_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Participant_Connect_Request_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Participant_Connect_Request_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Participant_Connect_Request_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Participant_Connect_Request_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Participant_Connect_Request_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Participant_Connect_Request_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Participant_Connect_Request_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Participant_Connect_Request_Notification*)p = *(struct ns__Dispatch_Participant_Connect_Request_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Media_Message_Notification(struct soap *soap, struct ns__Dispatch_Media_Message_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Media_Message_Notification(struct soap *soap, const struct ns__Dispatch_Media_Message_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Media_Message_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Media_Message_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Media_Message_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Media_Message_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Media_Message_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Media_Message_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Media_Message_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Media_Message_Notification, sizeof(struct ns__Dispatch_Media_Message_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Media_Message_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Media_Message_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Media_Message_Notification, 0, sizeof(struct ns__Dispatch_Media_Message_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Media_Message_Notification(struct soap *soap, const struct ns__Dispatch_Media_Message_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Media_Message_Notification);
	if (soap_out_ns__Dispatch_Media_Message_Notification(soap, tag?tag:"ns:Dispatch-Media-Message-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Media_Message_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Media_Message_Notification(struct soap *soap, struct ns__Dispatch_Media_Message_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Media_Message_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Media_Message_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Media_Message_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Media_Message_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Media_Message_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Media_Message_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Media_Message_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Media_Message_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Media_Message_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Media_Message_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Media_Message_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Media_Message_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Media_Message_Notification*)p = *(struct ns__Dispatch_Media_Message_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Media_Message_Request(struct soap *soap, struct ns__Dispatch_Media_Message_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id.ns__Entity::soap_default(soap);
	soap_default_uint32(soap, &a->from_message_id);
	soap_default_std__string(soap, &a->from_time);
	soap_default_uint32(soap, &a->max_message_count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Media_Message_Request(struct soap *soap, const struct ns__Dispatch_Media_Message_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id.soap_serialize(soap);
	soap_serialize_std__string(soap, &a->from_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Media_Message_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Media_Message_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Media_Message_Request), type))
		return soap->error;
	if (a->id.soap_out(soap, "id", -1, ""))
		return soap->error;
	if (soap_out_uint32(soap, "from-message-id", -1, &a->from_message_id, ""))
		return soap->error;
	if (soap_out_std__string(soap, "from-time", -1, &a->from_time, ""))
		return soap->error;
	if (soap_out_uint32(soap, "max-message-count", -1, &a->max_message_count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Media_Message_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Media_Message_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Media_Message_Request *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_from_message_id = 1;
	size_t soap_flag_from_time = 1;
	size_t soap_flag_max_message_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Media_Message_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Media_Message_Request, sizeof(struct ns__Dispatch_Media_Message_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Media_Message_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->id.soap_in(soap, "id", "ns:Entity"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_from_message_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "from-message-id", &a->from_message_id, "uint32"))
				{	soap_flag_from_message_id--;
					continue;
				}
			if (soap_flag_from_time && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "from-time", &a->from_time, "xsd:string"))
				{	soap_flag_from_time--;
					continue;
				}
			if (soap_flag_max_message_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_uint32(soap, "max-message-count", &a->max_message_count, "uint32"))
				{	soap_flag_max_message_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Media_Message_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Media_Message_Request, 0, sizeof(struct ns__Dispatch_Media_Message_Request), 0, soap_copy_ns__Dispatch_Media_Message_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_from_message_id > 0 || soap_flag_from_time > 0 || soap_flag_max_message_count > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Media_Message_Request(struct soap *soap, const struct ns__Dispatch_Media_Message_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Media_Message_Request);
	if (soap_out_ns__Dispatch_Media_Message_Request(soap, tag?tag:"ns:Dispatch-Media-Message-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Media_Message_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Media_Message_Request(struct soap *soap, struct ns__Dispatch_Media_Message_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Media_Message_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Media_Message_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Media_Message_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Media_Message_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Media_Message_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Media_Message_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Media_Message_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Media_Message_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Media_Message_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Media_Message_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Media_Message_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Media_Message_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Media_Message_Request*)p = *(struct ns__Dispatch_Media_Message_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Participant_Status_Notification(struct soap *soap, struct ns__Dispatch_Participant_Status_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Participant_Status_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Status_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Participant_Status_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Participant_Status_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Participant_Status_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Status_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Participant_Status_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Participant_Status_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Participant_Status_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Participant_Status_Notification, sizeof(struct ns__Dispatch_Participant_Status_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Participant_Status_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Participant_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Participant_Status_Notification, 0, sizeof(struct ns__Dispatch_Participant_Status_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Participant_Status_Notification(struct soap *soap, const struct ns__Dispatch_Participant_Status_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Participant_Status_Notification);
	if (soap_out_ns__Dispatch_Participant_Status_Notification(soap, tag?tag:"ns:Dispatch-Participant-Status-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Participant_Status_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Participant_Status_Notification(struct soap *soap, struct ns__Dispatch_Participant_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Participant_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Participant_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Participant_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Participant_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Participant_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Participant_Status_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Participant_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Participant_Status_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Participant_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Participant_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Participant_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Participant_Status_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Participant_Status_Notification*)p = *(struct ns__Dispatch_Participant_Status_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, struct ns__Dispatch_Join_Group_Request_Nofitication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, const struct ns__Dispatch_Join_Group_Request_Nofitication *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Join_Group_Request_Nofitication *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Join_Group_Request_Nofitication * SOAP_FMAC4 soap_in_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, const char *tag, struct ns__Dispatch_Join_Group_Request_Nofitication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Join_Group_Request_Nofitication *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication, sizeof(struct ns__Dispatch_Join_Group_Request_Nofitication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Join_Group_Request_Nofitication(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Join_Group_Request_Nofitication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication, 0, sizeof(struct ns__Dispatch_Join_Group_Request_Nofitication), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, const struct ns__Dispatch_Join_Group_Request_Nofitication *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication);
	if (soap_out_ns__Dispatch_Join_Group_Request_Nofitication(soap, tag?tag:"ns:Dispatch-Join-Group-Request-Nofitication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Join_Group_Request_Nofitication * SOAP_FMAC4 soap_get_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, struct ns__Dispatch_Join_Group_Request_Nofitication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Join_Group_Request_Nofitication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Join_Group_Request_Nofitication * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Join_Group_Request_Nofitication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Join_Group_Request_Nofitication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Join_Group_Request_Nofitication);
		if (size)
			*size = sizeof(struct ns__Dispatch_Join_Group_Request_Nofitication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Join_Group_Request_Nofitication, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Join_Group_Request_Nofitication);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Join_Group_Request_Nofitication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Join_Group_Request_Nofitication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Join_Group_Request_Nofitication %p -> %p\n", q, p));
	*(struct ns__Dispatch_Join_Group_Request_Nofitication*)p = *(struct ns__Dispatch_Join_Group_Request_Nofitication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, struct ns__Dispatch_Dispatch_Participants_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, const struct ns__Dispatch_Dispatch_Participants_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Dispatch_Participants_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Dispatch_Participants_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Dispatch_Participants_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Dispatch_Participants_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification, sizeof(struct ns__Dispatch_Dispatch_Participants_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Dispatch_Participants_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Dispatch_Participants_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification, 0, sizeof(struct ns__Dispatch_Dispatch_Participants_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, const struct ns__Dispatch_Dispatch_Participants_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification);
	if (soap_out_ns__Dispatch_Dispatch_Participants_Notification(soap, tag?tag:"ns:Dispatch-Dispatch-Participants-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Dispatch_Participants_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, struct ns__Dispatch_Dispatch_Participants_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Dispatch_Participants_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Dispatch_Participants_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Dispatch_Participants_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Dispatch_Participants_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Dispatch_Participants_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Dispatch_Participants_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Dispatch_Participants_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Dispatch_Participants_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Dispatch_Participants_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Dispatch_Participants_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Dispatch_Participants_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Dispatch_Participants_Notification*)p = *(struct ns__Dispatch_Dispatch_Participants_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Delete_Group(struct soap *soap, struct ns__Dispatch_Delete_Group *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Delete_Group(struct soap *soap, const struct ns__Dispatch_Delete_Group *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group_id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Delete_Group(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Delete_Group *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Delete_Group), type))
		return soap->error;
	if (a->group_id.soap_out(soap, "group-id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_Group * SOAP_FMAC4 soap_in_ns__Dispatch_Delete_Group(struct soap *soap, const char *tag, struct ns__Dispatch_Delete_Group *a, const char *type)
{
	size_t soap_flag_group_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Delete_Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Delete_Group, sizeof(struct ns__Dispatch_Delete_Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Delete_Group(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->group_id.soap_in(soap, "group-id", "ns:Entity"))
				{	soap_flag_group_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Delete_Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Delete_Group, 0, sizeof(struct ns__Dispatch_Delete_Group), 0, soap_copy_ns__Dispatch_Delete_Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Delete_Group(struct soap *soap, const struct ns__Dispatch_Delete_Group *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Delete_Group);
	if (soap_out_ns__Dispatch_Delete_Group(soap, tag?tag:"ns:Dispatch-Delete-Group", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_Group * SOAP_FMAC4 soap_get_ns__Dispatch_Delete_Group(struct soap *soap, struct ns__Dispatch_Delete_Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Delete_Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Delete_Group * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Delete_Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Delete_Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Delete_Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Delete_Group);
		if (size)
			*size = sizeof(struct ns__Dispatch_Delete_Group);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Delete_Group, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Delete_Group);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Delete_Group*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Delete_Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Delete_Group %p -> %p\n", q, p));
	*(struct ns__Dispatch_Delete_Group*)p = *(struct ns__Dispatch_Delete_Group*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Delete_Group_Response(struct soap *soap, struct ns__Delete_Group_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Delete_Group_Response(struct soap *soap, const struct ns__Delete_Group_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Delete_Group_Response(struct soap *soap, const char *tag, int id, const struct ns__Delete_Group_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Delete_Group_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Delete_Group_Response * SOAP_FMAC4 soap_in_ns__Delete_Group_Response(struct soap *soap, const char *tag, struct ns__Delete_Group_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Delete_Group_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Delete_Group_Response, sizeof(struct ns__Delete_Group_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Delete_Group_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Delete_Group_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Delete_Group_Response, 0, sizeof(struct ns__Delete_Group_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Delete_Group_Response(struct soap *soap, const struct ns__Delete_Group_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Delete_Group_Response);
	if (soap_out_ns__Delete_Group_Response(soap, tag?tag:"ns:Delete-Group-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Delete_Group_Response * SOAP_FMAC4 soap_get_ns__Delete_Group_Response(struct soap *soap, struct ns__Delete_Group_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Delete_Group_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Delete_Group_Response * SOAP_FMAC2 soap_instantiate_ns__Delete_Group_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Delete_Group_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Delete_Group_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Delete_Group_Response);
		if (size)
			*size = sizeof(struct ns__Delete_Group_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Delete_Group_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Delete_Group_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Delete_Group_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Delete_Group_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Delete_Group_Response %p -> %p\n", q, p));
	*(struct ns__Delete_Group_Response*)p = *(struct ns__Delete_Group_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Modify_Participants(struct soap *soap, struct ns__Dispatch_Modify_Participants *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request.ns__Modify_Participant::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Modify_Participants(struct soap *soap, const struct ns__Dispatch_Modify_Participants *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Modify_Participants(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Modify_Participants *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Modify_Participants), type))
		return soap->error;
	if (a->request.soap_out(soap, "request", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Participants * SOAP_FMAC4 soap_in_ns__Dispatch_Modify_Participants(struct soap *soap, const char *tag, struct ns__Dispatch_Modify_Participants *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Modify_Participants *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Modify_Participants, sizeof(struct ns__Dispatch_Modify_Participants), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Modify_Participants(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (a->request.soap_in(soap, "request", "ns:Modify-Participant"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Modify_Participants *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Modify_Participants, 0, sizeof(struct ns__Dispatch_Modify_Participants), 0, soap_copy_ns__Dispatch_Modify_Participants);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Modify_Participants(struct soap *soap, const struct ns__Dispatch_Modify_Participants *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Modify_Participants);
	if (soap_out_ns__Dispatch_Modify_Participants(soap, tag?tag:"ns:Dispatch-Modify-Participants", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Participants * SOAP_FMAC4 soap_get_ns__Dispatch_Modify_Participants(struct soap *soap, struct ns__Dispatch_Modify_Participants *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Modify_Participants(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Modify_Participants * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Modify_Participants(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Modify_Participants(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Modify_Participants, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Modify_Participants);
		if (size)
			*size = sizeof(struct ns__Dispatch_Modify_Participants);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Modify_Participants, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Modify_Participants);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Modify_Participants*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Modify_Participants(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Modify_Participants %p -> %p\n", q, p));
	*(struct ns__Dispatch_Modify_Participants*)p = *(struct ns__Dispatch_Modify_Participants*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Modify_Group(struct soap *soap, struct ns__Dispatch_Modify_Group *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group.ns__Group::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Modify_Group(struct soap *soap, const struct ns__Dispatch_Modify_Group *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Modify_Group(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Modify_Group *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Modify_Group), type))
		return soap->error;
	if (a->group.soap_out(soap, "group", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Group * SOAP_FMAC4 soap_in_ns__Dispatch_Modify_Group(struct soap *soap, const char *tag, struct ns__Dispatch_Modify_Group *a, const char *type)
{
	size_t soap_flag_group = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Modify_Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Modify_Group, sizeof(struct ns__Dispatch_Modify_Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Modify_Group(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group && soap->error == SOAP_TAG_MISMATCH)
				if (a->group.soap_in(soap, "group", "ns:Group"))
				{	soap_flag_group--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Modify_Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Modify_Group, 0, sizeof(struct ns__Dispatch_Modify_Group), 0, soap_copy_ns__Dispatch_Modify_Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Modify_Group(struct soap *soap, const struct ns__Dispatch_Modify_Group *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Modify_Group);
	if (soap_out_ns__Dispatch_Modify_Group(soap, tag?tag:"ns:Dispatch-Modify-Group", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Group * SOAP_FMAC4 soap_get_ns__Dispatch_Modify_Group(struct soap *soap, struct ns__Dispatch_Modify_Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Modify_Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Modify_Group * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Modify_Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Modify_Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Modify_Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Modify_Group);
		if (size)
			*size = sizeof(struct ns__Dispatch_Modify_Group);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Modify_Group, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Modify_Group);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Modify_Group*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Modify_Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Modify_Group %p -> %p\n", q, p));
	*(struct ns__Dispatch_Modify_Group*)p = *(struct ns__Dispatch_Modify_Group*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Append_Group(struct soap *soap, struct ns__Dispatch_Append_Group *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group.ns__Group::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Append_Group(struct soap *soap, const struct ns__Dispatch_Append_Group *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->group.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Append_Group(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Append_Group *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Append_Group), type))
		return soap->error;
	if (a->group.soap_out(soap, "group", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Append_Group * SOAP_FMAC4 soap_in_ns__Dispatch_Append_Group(struct soap *soap, const char *tag, struct ns__Dispatch_Append_Group *a, const char *type)
{
	size_t soap_flag_group = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Append_Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Append_Group, sizeof(struct ns__Dispatch_Append_Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Append_Group(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group && soap->error == SOAP_TAG_MISMATCH)
				if (a->group.soap_in(soap, "group", "ns:Group"))
				{	soap_flag_group--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Append_Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Append_Group, 0, sizeof(struct ns__Dispatch_Append_Group), 0, soap_copy_ns__Dispatch_Append_Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_group > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Append_Group(struct soap *soap, const struct ns__Dispatch_Append_Group *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Append_Group);
	if (soap_out_ns__Dispatch_Append_Group(soap, tag?tag:"ns:Dispatch-Append-Group", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Append_Group * SOAP_FMAC4 soap_get_ns__Dispatch_Append_Group(struct soap *soap, struct ns__Dispatch_Append_Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Append_Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Append_Group * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Append_Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Append_Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Append_Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Append_Group);
		if (size)
			*size = sizeof(struct ns__Dispatch_Append_Group);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Append_Group, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Append_Group);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Append_Group*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Append_Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Append_Group %p -> %p\n", q, p));
	*(struct ns__Dispatch_Append_Group*)p = *(struct ns__Dispatch_Append_Group*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Entity_Status_Notification(struct soap *soap, struct ns__Dispatch_Entity_Status_Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Entity_Status_Notification(struct soap *soap, const struct ns__Dispatch_Entity_Status_Notification *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Entity_Status_Notification(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Entity_Status_Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Entity_Status_Notification), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Status_Notification * SOAP_FMAC4 soap_in_ns__Dispatch_Entity_Status_Notification(struct soap *soap, const char *tag, struct ns__Dispatch_Entity_Status_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Entity_Status_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Entity_Status_Notification, sizeof(struct ns__Dispatch_Entity_Status_Notification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Entity_Status_Notification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Entity_Status_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Entity_Status_Notification, 0, sizeof(struct ns__Dispatch_Entity_Status_Notification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Entity_Status_Notification(struct soap *soap, const struct ns__Dispatch_Entity_Status_Notification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Entity_Status_Notification);
	if (soap_out_ns__Dispatch_Entity_Status_Notification(soap, tag?tag:"ns:Dispatch-Entity-Status-Notification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Status_Notification * SOAP_FMAC4 soap_get_ns__Dispatch_Entity_Status_Notification(struct soap *soap, struct ns__Dispatch_Entity_Status_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Entity_Status_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Entity_Status_Notification * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Entity_Status_Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Entity_Status_Notification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Entity_Status_Notification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Entity_Status_Notification);
		if (size)
			*size = sizeof(struct ns__Dispatch_Entity_Status_Notification);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Entity_Status_Notification, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Entity_Status_Notification);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Entity_Status_Notification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Entity_Status_Notification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Entity_Status_Notification %p -> %p\n", q, p));
	*(struct ns__Dispatch_Entity_Status_Notification*)p = *(struct ns__Dispatch_Entity_Status_Notification*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Entity_Nofitication(struct soap *soap, struct ns__Dispatch_Entity_Nofitication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Entity_Nofitication(struct soap *soap, const struct ns__Dispatch_Entity_Nofitication *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Entity_Nofitication(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Entity_Nofitication *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Entity_Nofitication), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Nofitication * SOAP_FMAC4 soap_in_ns__Dispatch_Entity_Nofitication(struct soap *soap, const char *tag, struct ns__Dispatch_Entity_Nofitication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Entity_Nofitication *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Entity_Nofitication, sizeof(struct ns__Dispatch_Entity_Nofitication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Entity_Nofitication(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Entity_Nofitication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Entity_Nofitication, 0, sizeof(struct ns__Dispatch_Entity_Nofitication), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Entity_Nofitication(struct soap *soap, const struct ns__Dispatch_Entity_Nofitication *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Entity_Nofitication);
	if (soap_out_ns__Dispatch_Entity_Nofitication(soap, tag?tag:"ns:Dispatch-Entity-Nofitication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Nofitication * SOAP_FMAC4 soap_get_ns__Dispatch_Entity_Nofitication(struct soap *soap, struct ns__Dispatch_Entity_Nofitication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Entity_Nofitication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Entity_Nofitication * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Entity_Nofitication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Entity_Nofitication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Entity_Nofitication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Entity_Nofitication);
		if (size)
			*size = sizeof(struct ns__Dispatch_Entity_Nofitication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Entity_Nofitication, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Entity_Nofitication);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Entity_Nofitication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Entity_Nofitication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Entity_Nofitication %p -> %p\n", q, p));
	*(struct ns__Dispatch_Entity_Nofitication*)p = *(struct ns__Dispatch_Entity_Nofitication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Entity_Request(struct soap *soap, struct ns__Dispatch_Entity_Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id.ns__Entity::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Entity_Request(struct soap *soap, const struct ns__Dispatch_Entity_Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Entity_Request(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Entity_Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Entity_Request), type))
		return soap->error;
	if (a->id.soap_out(soap, "id", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Request * SOAP_FMAC4 soap_in_ns__Dispatch_Entity_Request(struct soap *soap, const char *tag, struct ns__Dispatch_Entity_Request *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Entity_Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Entity_Request, sizeof(struct ns__Dispatch_Entity_Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Entity_Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (a->id.soap_in(soap, "id", "ns:Entity"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Entity_Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Entity_Request, 0, sizeof(struct ns__Dispatch_Entity_Request), 0, soap_copy_ns__Dispatch_Entity_Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Entity_Request(struct soap *soap, const struct ns__Dispatch_Entity_Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Entity_Request);
	if (soap_out_ns__Dispatch_Entity_Request(soap, tag?tag:"ns:Dispatch-Entity-Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Entity_Request * SOAP_FMAC4 soap_get_ns__Dispatch_Entity_Request(struct soap *soap, struct ns__Dispatch_Entity_Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Entity_Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Entity_Request * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Entity_Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Entity_Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Entity_Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Entity_Request);
		if (size)
			*size = sizeof(struct ns__Dispatch_Entity_Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Entity_Request, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Entity_Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Entity_Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Entity_Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Entity_Request %p -> %p\n", q, p));
	*(struct ns__Dispatch_Entity_Request*)p = *(struct ns__Dispatch_Entity_Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Keepalive(struct soap *soap, struct ns__Dispatch_Keepalive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Keepalive(struct soap *soap, const struct ns__Dispatch_Keepalive *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Keepalive(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Keepalive *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Keepalive), type))
		return soap->error;
	/* transient _ skipped */
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive * SOAP_FMAC4 soap_in_ns__Dispatch_Keepalive(struct soap *soap, const char *tag, struct ns__Dispatch_Keepalive *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Keepalive *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Keepalive, sizeof(struct ns__Dispatch_Keepalive), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Keepalive(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Keepalive *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Keepalive, 0, sizeof(struct ns__Dispatch_Keepalive), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Keepalive(struct soap *soap, const struct ns__Dispatch_Keepalive *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Keepalive);
	if (soap_out_ns__Dispatch_Keepalive(soap, tag?tag:"ns:Dispatch-Keepalive", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive * SOAP_FMAC4 soap_get_ns__Dispatch_Keepalive(struct soap *soap, struct ns__Dispatch_Keepalive *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Keepalive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Keepalive * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Keepalive(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Keepalive(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Keepalive, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Keepalive);
		if (size)
			*size = sizeof(struct ns__Dispatch_Keepalive);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Keepalive, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Keepalive);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Keepalive*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Keepalive(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Keepalive %p -> %p\n", q, p));
	*(struct ns__Dispatch_Keepalive*)p = *(struct ns__Dispatch_Keepalive*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, struct ns__Dispatch_Keepalive_Request_Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, const struct ns__Dispatch_Keepalive_Request_Response *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Keepalive_Request_Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive_Request_Response * SOAP_FMAC4 soap_in_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Keepalive_Request_Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Keepalive_Request_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response, sizeof(struct ns__Dispatch_Keepalive_Request_Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Keepalive_Request_Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Keepalive_Request_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response, 0, sizeof(struct ns__Dispatch_Keepalive_Request_Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, const struct ns__Dispatch_Keepalive_Request_Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response);
	if (soap_out_ns__Dispatch_Keepalive_Request_Response(soap, tag?tag:"ns:Dispatch-Keepalive-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive_Request_Response * SOAP_FMAC4 soap_get_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, struct ns__Dispatch_Keepalive_Request_Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Keepalive_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Keepalive_Request_Response * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Keepalive_Request_Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Keepalive_Request_Response);
		if (size)
			*size = sizeof(struct ns__Dispatch_Keepalive_Request_Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Keepalive_Request_Response, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Keepalive_Request_Response);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Keepalive_Request_Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Keepalive_Request_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Keepalive_Request_Response %p -> %p\n", q, p));
	*(struct ns__Dispatch_Keepalive_Request_Response*)p = *(struct ns__Dispatch_Keepalive_Request_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Logout(struct soap *soap, struct ns__Dispatch_Logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Logout(struct soap *soap, const struct ns__Dispatch_Logout *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Logout(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Logout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Logout), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Logout * SOAP_FMAC4 soap_in_ns__Dispatch_Logout(struct soap *soap, const char *tag, struct ns__Dispatch_Logout *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Logout, sizeof(struct ns__Dispatch_Logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Logout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Logout, 0, sizeof(struct ns__Dispatch_Logout), 0, soap_copy_ns__Dispatch_Logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Logout(struct soap *soap, const struct ns__Dispatch_Logout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Logout);
	if (soap_out_ns__Dispatch_Logout(soap, tag?tag:"ns:Dispatch-Logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Logout * SOAP_FMAC4 soap_get_ns__Dispatch_Logout(struct soap *soap, struct ns__Dispatch_Logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Logout * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Logout);
		if (size)
			*size = sizeof(struct ns__Dispatch_Logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Logout, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Logout);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Logout %p -> %p\n", q, p));
	*(struct ns__Dispatch_Logout*)p = *(struct ns__Dispatch_Logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__LogOutResponse(struct soap *soap, struct ns__LogOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__LogOutResponse(struct soap *soap, const struct ns__LogOutResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__LogOutResponse(struct soap *soap, const char *tag, int id, const struct ns__LogOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__LogOutResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__LogOutResponse * SOAP_FMAC4 soap_in_ns__LogOutResponse(struct soap *soap, const char *tag, struct ns__LogOutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__LogOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__LogOutResponse, sizeof(struct ns__LogOutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__LogOutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__LogOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__LogOutResponse, 0, sizeof(struct ns__LogOutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__LogOutResponse(struct soap *soap, const struct ns__LogOutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__LogOutResponse);
	if (soap_out_ns__LogOutResponse(soap, tag?tag:"ns:LogOutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__LogOutResponse * SOAP_FMAC4 soap_get_ns__LogOutResponse(struct soap *soap, struct ns__LogOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__LogOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__LogOutResponse * SOAP_FMAC2 soap_instantiate_ns__LogOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__LogOutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__LogOutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__LogOutResponse);
		if (size)
			*size = sizeof(struct ns__LogOutResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__LogOutResponse, n);
		if (size)
			*size = n * sizeof(struct ns__LogOutResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__LogOutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__LogOutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__LogOutResponse %p -> %p\n", q, p));
	*(struct ns__LogOutResponse*)p = *(struct ns__LogOutResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Dispatch_Login(struct soap *soap, struct ns__Dispatch_Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->username);
	soap_default_std__string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Dispatch_Login(struct soap *soap, const struct ns__Dispatch_Login *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->username);
	soap_serialize_std__string(soap, &a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Dispatch_Login(struct soap *soap, const char *tag, int id, const struct ns__Dispatch_Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Dispatch_Login), type))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Dispatch_Login * SOAP_FMAC4 soap_in_ns__Dispatch_Login(struct soap *soap, const char *tag, struct ns__Dispatch_Login *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Dispatch_Login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Dispatch_Login, sizeof(struct ns__Dispatch_Login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__Dispatch_Login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Dispatch_Login, 0, sizeof(struct ns__Dispatch_Login), 0, soap_copy_ns__Dispatch_Login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username > 0 || soap_flag_password > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Dispatch_Login(struct soap *soap, const struct ns__Dispatch_Login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Dispatch_Login);
	if (soap_out_ns__Dispatch_Login(soap, tag?tag:"ns:Dispatch-Login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Login * SOAP_FMAC4 soap_get_ns__Dispatch_Login(struct soap *soap, struct ns__Dispatch_Login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Dispatch_Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Dispatch_Login * SOAP_FMAC2 soap_instantiate_ns__Dispatch_Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Dispatch_Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Dispatch_Login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Dispatch_Login);
		if (size)
			*size = sizeof(struct ns__Dispatch_Login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns__Dispatch_Login, n);
		if (size)
			*size = n * sizeof(struct ns__Dispatch_Login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns__Dispatch_Login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Dispatch_Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Dispatch_Login %p -> %p\n", q, p));
	*(struct ns__Dispatch_Login*)p = *(struct ns__Dispatch_Login*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response))
		soap_serialize_ns__Dispatch_Delete_History_Alert_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Delete_History_Alert_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Delete_History_Alert_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Delete_History_Alert_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Delete_History_Alert_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Delete_History_Alert_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Delete_History_Alert_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Delete_History_Alert_Request_Response, sizeof(struct ns__Dispatch_Delete_History_Alert_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Delete_History_Alert_Request_Response);
	if (soap_out_PointerTons__Dispatch_Delete_History_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Delete-History-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Delete_History_Alert_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Delete_History_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Delete_History_Alert_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Delete_History_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response))
		soap_serialize_ns__Dispatch_Alert_Overed_Notification_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Alert_Overed_Notification_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Alert_Overed_Notification_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Alert_Overed_Notification_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Alert_Overed_Notification_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Alert_Overed_Notification_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Alert_Overed_Notification_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Alert_Overed_Notification_Response, sizeof(struct ns__Dispatch_Alert_Overed_Notification_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Alert_Overed_Notification_Response);
	if (soap_out_PointerTons__Dispatch_Alert_Overed_Notification_Response(soap, tag?tag:"ns:Dispatch-Alert-Overed-Notification-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Alert_Overed_Notification_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Alert_Overed_Notification_Response(struct soap *soap, struct ns__Dispatch_Alert_Overed_Notification_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Alert_Overed_Notification_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Stop_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response))
		soap_serialize_ns__Dispatch_Stop_Alert_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Stop_Alert_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Stop_Alert_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Stop_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Alert_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Stop_Alert_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Stop_Alert_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Stop_Alert_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Alert_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Stop_Alert_Request_Response, sizeof(struct ns__Dispatch_Stop_Alert_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Stop_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Stop_Alert_Request_Response);
	if (soap_out_PointerTons__Dispatch_Stop_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Stop-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Alert_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Stop_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Alert_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Stop_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Modify_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response))
		soap_serialize_ns__Dispatch_Modify_Alert_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Modify_Alert_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Modify_Alert_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Modify_Alert_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Modify_Alert_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Modify_Alert_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Modify_Alert_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Modify_Alert_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Modify_Alert_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Modify_Alert_Request_Response, sizeof(struct ns__Dispatch_Modify_Alert_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Modify_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Modify_Alert_Request_Response);
	if (soap_out_PointerTons__Dispatch_Modify_Alert_Request_Response(soap, tag?tag:"ns:Dispatch-Modify-Alert-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Modify_Alert_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Modify_Alert_Request_Response(struct soap *soap, struct ns__Dispatch_Modify_Alert_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Modify_Alert_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response))
		soap_serialize_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Subscribe_Account_Location_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Subscribe_Account_Location_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Subscribe_Account_Location_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Subscribe_Account_Location_Request_Response, sizeof(struct ns__Dispatch_Subscribe_Account_Location_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response);
	if (soap_out_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag?tag:"ns:Dispatch-Subscribe-Account-Location-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Subscribe_Account_Location_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(struct soap *soap, struct ns__Dispatch_Subscribe_Account_Location_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Subscribe_Account_Location_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Stop_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Record_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response))
		soap_serialize_ns__Dispatch_Stop_Record_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Stop_Record_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Stop_Record_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Stop_Record_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Stop_Record_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Stop_Record_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Stop_Record_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Stop_Record_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Stop_Record_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Stop_Record_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Stop_Record_Request_Response, sizeof(struct ns__Dispatch_Stop_Record_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Stop_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Record_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Stop_Record_Request_Response);
	if (soap_out_PointerTons__Dispatch_Stop_Record_Request_Response(soap, tag?tag:"ns:Dispatch-Stop-Record-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Stop_Record_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Stop_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Stop_Record_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Stop_Record_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Start_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Start_Record_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response))
		soap_serialize_ns__Dispatch_Start_Record_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Start_Record_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Start_Record_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Start_Record_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Start_Record_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Start_Record_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Start_Record_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Start_Record_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Start_Record_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Start_Record_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Start_Record_Request_Response, sizeof(struct ns__Dispatch_Start_Record_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Start_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Start_Record_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Start_Record_Request_Response);
	if (soap_out_PointerTons__Dispatch_Start_Record_Request_Response(soap, tag?tag:"ns:Dispatch-Start-Record-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Start_Record_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Start_Record_Request_Response(struct soap *soap, struct ns__Dispatch_Start_Record_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Start_Record_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Kick_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response))
		soap_serialize_ns__Dispatch_Kick_Participant_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Kick_Participant_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Kick_Participant_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Kick_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Kick_Participant_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Kick_Participant_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Kick_Participant_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Kick_Participant_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Kick_Participant_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Kick_Participant_Request_Response, sizeof(struct ns__Dispatch_Kick_Participant_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Kick_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Kick_Participant_Request_Response);
	if (soap_out_PointerTons__Dispatch_Kick_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Kick-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Kick_Participant_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Kick_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Kick_Participant_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Kick_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Send_Message_Request_Response(struct soap *soap, struct ns__Dispatch_Send_Message_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response))
		soap_serialize_ns__Dispatch_Send_Message_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Send_Message_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Send_Message_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Send_Message_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Send_Message_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Send_Message_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Send_Message_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Send_Message_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Send_Message_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Send_Message_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Send_Message_Request_Response, sizeof(struct ns__Dispatch_Send_Message_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Send_Message_Request_Response(struct soap *soap, struct ns__Dispatch_Send_Message_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Send_Message_Request_Response);
	if (soap_out_PointerTons__Dispatch_Send_Message_Request_Response(soap, tag?tag:"ns:Dispatch-Send-Message-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Send_Message_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Send_Message_Request_Response(struct soap *soap, struct ns__Dispatch_Send_Message_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Send_Message_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Leave_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Leave_Group_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response))
		soap_serialize_ns__Dispatch_Leave_Group_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Leave_Group_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Leave_Group_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Leave_Group_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Leave_Group_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Leave_Group_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Leave_Group_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Leave_Group_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Leave_Group_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Leave_Group_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Leave_Group_Request_Response, sizeof(struct ns__Dispatch_Leave_Group_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Leave_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Leave_Group_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Leave_Group_Request_Response);
	if (soap_out_PointerTons__Dispatch_Leave_Group_Request_Response(soap, tag?tag:"ns:Dispatch-Leave-Group-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Leave_Group_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Leave_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Leave_Group_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Leave_Group_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Jion_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Jion_Group_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response))
		soap_serialize_ns__Dispatch_Jion_Group_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Jion_Group_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Jion_Group_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Jion_Group_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Jion_Group_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Jion_Group_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Jion_Group_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Jion_Group_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Jion_Group_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Jion_Group_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Jion_Group_Request_Response, sizeof(struct ns__Dispatch_Jion_Group_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Jion_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Jion_Group_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Jion_Group_Request_Response);
	if (soap_out_PointerTons__Dispatch_Jion_Group_Request_Response(soap, tag?tag:"ns:Dispatch-Jion-Group-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Jion_Group_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Jion_Group_Request_Response(struct soap *soap, struct ns__Dispatch_Jion_Group_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Jion_Group_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response))
		soap_serialize_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Appoint_Participant_Speak_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Appoint_Participant_Speak_Request_Response, sizeof(struct ns__Dispatch_Appoint_Participant_Speak_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response);
	if (soap_out_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag?tag:"ns:Dispatch-Appoint-Participant-Speak-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Appoint_Participant_Speak_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(struct soap *soap, struct ns__Dispatch_Appoint_Participant_Speak_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Appoint_Participant_Speak_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response))
		soap_serialize_ns__Dispatch_Release_Participant_Token_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Release_Participant_Token_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Release_Participant_Token_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Release_Participant_Token_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Release_Participant_Token_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Release_Participant_Token_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Release_Participant_Token_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Release_Participant_Token_Request_Response, sizeof(struct ns__Dispatch_Release_Participant_Token_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Release_Participant_Token_Request_Response);
	if (soap_out_PointerTons__Dispatch_Release_Participant_Token_Request_Response(soap, tag?tag:"ns:Dispatch-Release-Participant-Token-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Release_Participant_Token_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Release_Participant_Token_Request_Response(struct soap *soap, struct ns__Dispatch_Release_Participant_Token_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Release_Participant_Token_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Drop_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response))
		soap_serialize_ns__Dispatch_Drop_Participant_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Drop_Participant_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Drop_Participant_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Drop_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Drop_Participant_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Drop_Participant_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Drop_Participant_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Drop_Participant_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Drop_Participant_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Drop_Participant_Request_Response, sizeof(struct ns__Dispatch_Drop_Participant_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Drop_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Drop_Participant_Request_Response);
	if (soap_out_PointerTons__Dispatch_Drop_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Drop-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Drop_Participant_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Drop_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Drop_Participant_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Drop_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Invite_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response))
		soap_serialize_ns__Dispatch_Invite_Participant_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Invite_Participant_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Invite_Participant_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Invite_Participant_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Invite_Participant_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Invite_Participant_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Invite_Participant_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Invite_Participant_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Invite_Participant_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Invite_Participant_Request_Response, sizeof(struct ns__Dispatch_Invite_Participant_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Invite_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Invite_Participant_Request_Response);
	if (soap_out_PointerTons__Dispatch_Invite_Participant_Request_Response(soap, tag?tag:"ns:Dispatch-Invite-Participant-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Invite_Participant_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Invite_Participant_Request_Response(struct soap *soap, struct ns__Dispatch_Invite_Participant_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Invite_Participant_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Delete_Group_Response(struct soap *soap, struct ns__Delete_Group_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Delete_Group_Response))
		soap_serialize_ns__Delete_Group_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Delete_Group_Response(struct soap *soap, const char *tag, int id, struct ns__Delete_Group_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Delete_Group_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Delete_Group_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Delete_Group_Response ** SOAP_FMAC4 soap_in_PointerTons__Delete_Group_Response(struct soap *soap, const char *tag, struct ns__Delete_Group_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Delete_Group_Response **)soap_malloc(soap, sizeof(struct ns__Delete_Group_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Delete_Group_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Delete_Group_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Delete_Group_Response, sizeof(struct ns__Delete_Group_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Delete_Group_Response(struct soap *soap, struct ns__Delete_Group_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Delete_Group_Response);
	if (soap_out_PointerTons__Delete_Group_Response(soap, tag?tag:"ns:Delete-Group-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Delete_Group_Response ** SOAP_FMAC4 soap_get_PointerTons__Delete_Group_Response(struct soap *soap, struct ns__Delete_Group_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Delete_Group_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Dispatch_Keepalive_Request_Response(struct soap *soap, struct ns__Dispatch_Keepalive_Request_Response *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response))
		soap_serialize_ns__Dispatch_Keepalive_Request_Response(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Dispatch_Keepalive_Request_Response(struct soap *soap, const char *tag, int id, struct ns__Dispatch_Keepalive_Request_Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns__Dispatch_Keepalive_Request_Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive_Request_Response ** SOAP_FMAC4 soap_in_PointerTons__Dispatch_Keepalive_Request_Response(struct soap *soap, const char *tag, struct ns__Dispatch_Keepalive_Request_Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__Dispatch_Keepalive_Request_Response **)soap_malloc(soap, sizeof(struct ns__Dispatch_Keepalive_Request_Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__Dispatch_Keepalive_Request_Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__Dispatch_Keepalive_Request_Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__Dispatch_Keepalive_Request_Response, sizeof(struct ns__Dispatch_Keepalive_Request_Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Dispatch_Keepalive_Request_Response(struct soap *soap, struct ns__Dispatch_Keepalive_Request_Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__Dispatch_Keepalive_Request_Response);
	if (soap_out_PointerTons__Dispatch_Keepalive_Request_Response(soap, tag?tag:"ns:Dispatch-Keepalive-Request-Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Dispatch_Keepalive_Request_Response ** SOAP_FMAC4 soap_get_PointerTons__Dispatch_Keepalive_Request_Response(struct soap *soap, struct ns__Dispatch_Keepalive_Request_Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__Dispatch_Keepalive_Request_Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__LogOutResponse(struct soap *soap, struct ns__LogOutResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__LogOutResponse))
		soap_serialize_ns__LogOutResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__LogOutResponse(struct soap *soap, const char *tag, int id, struct ns__LogOutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__LogOutResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns__LogOutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__LogOutResponse ** SOAP_FMAC4 soap_in_PointerTons__LogOutResponse(struct soap *soap, const char *tag, struct ns__LogOutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__LogOutResponse **)soap_malloc(soap, sizeof(struct ns__LogOutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__LogOutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__LogOutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__LogOutResponse, sizeof(struct ns__LogOutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__LogOutResponse(struct soap *soap, struct ns__LogOutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__LogOutResponse);
	if (soap_out_PointerTons__LogOutResponse(soap, tag?tag:"ns:LogOutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__LogOutResponse ** SOAP_FMAC4 soap_get_PointerTons__LogOutResponse(struct soap *soap, struct ns__LogOutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__LogOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOfns__HistoryAlert(struct soap *soap, std::list<ns__HistoryAlert >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOfns__HistoryAlert(struct soap *soap, const std::list<ns__HistoryAlert >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<ns__HistoryAlert >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOfns__HistoryAlert(struct soap *soap, const char *tag, int id, const std::list<ns__HistoryAlert >*a, const char *type)
{
	for (std::list<ns__HistoryAlert >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<ns__HistoryAlert >* SOAP_FMAC4 soap_in_std__listTemplateOfns__HistoryAlert(struct soap *soap, const char *tag, std::list<ns__HistoryAlert >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns__HistoryAlert n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__HistoryAlert, SOAP_TYPE_std__listTemplateOfns__HistoryAlert, sizeof(ns__HistoryAlert), 0))
				break;
			if (!soap_in_ns__HistoryAlert(soap, tag, NULL, "ns:HistoryAlert"))
				break;
		}
		else if (!soap_in_ns__HistoryAlert(soap, tag, &n, "ns:HistoryAlert"))
			break;
		if (!a && !(a = soap_new_std__listTemplateOfns__HistoryAlert(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<ns__HistoryAlert > * SOAP_FMAC2 soap_instantiate_std__listTemplateOfns__HistoryAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOfns__HistoryAlert(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOfns__HistoryAlert, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<ns__HistoryAlert >);
		if (size)
			*size = sizeof(std::list<ns__HistoryAlert >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<ns__HistoryAlert >, n);
		if (size)
			*size = n * sizeof(std::list<ns__HistoryAlert >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<ns__HistoryAlert >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOfns__HistoryAlert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<ns__HistoryAlert > %p -> %p\n", q, p));
	*(std::list<ns__HistoryAlert >*)p = *(std::list<ns__HistoryAlert >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOfns__Account(struct soap *soap, std::list<ns__Account >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOfns__Account(struct soap *soap, const std::list<ns__Account >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<ns__Account >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOfns__Account(struct soap *soap, const char *tag, int id, const std::list<ns__Account >*a, const char *type)
{
	for (std::list<ns__Account >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<ns__Account >* SOAP_FMAC4 soap_in_std__listTemplateOfns__Account(struct soap *soap, const char *tag, std::list<ns__Account >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns__Account n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__Account, SOAP_TYPE_std__listTemplateOfns__Account, sizeof(ns__Account), 0))
				break;
			if (!soap_in_ns__Account(soap, tag, NULL, "ns:Account"))
				break;
		}
		else if (!soap_in_ns__Account(soap, tag, &n, "ns:Account"))
			break;
		if (!a && !(a = soap_new_std__listTemplateOfns__Account(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<ns__Account > * SOAP_FMAC2 soap_instantiate_std__listTemplateOfns__Account(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOfns__Account(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOfns__Account, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<ns__Account >);
		if (size)
			*size = sizeof(std::list<ns__Account >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<ns__Account >, n);
		if (size)
			*size = n * sizeof(std::list<ns__Account >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<ns__Account >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOfns__Account(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<ns__Account > %p -> %p\n", q, p));
	*(std::list<ns__Account >*)p = *(std::list<ns__Account >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOfns__MediaMessage(struct soap *soap, std::list<ns__MediaMessage >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOfns__MediaMessage(struct soap *soap, const std::list<ns__MediaMessage >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<ns__MediaMessage >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOfns__MediaMessage(struct soap *soap, const char *tag, int id, const std::list<ns__MediaMessage >*a, const char *type)
{
	for (std::list<ns__MediaMessage >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<ns__MediaMessage >* SOAP_FMAC4 soap_in_std__listTemplateOfns__MediaMessage(struct soap *soap, const char *tag, std::list<ns__MediaMessage >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns__MediaMessage n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__MediaMessage, SOAP_TYPE_std__listTemplateOfns__MediaMessage, sizeof(ns__MediaMessage), 0))
				break;
			if (!soap_in_ns__MediaMessage(soap, tag, NULL, "ns:MediaMessage"))
				break;
		}
		else if (!soap_in_ns__MediaMessage(soap, tag, &n, "ns:MediaMessage"))
			break;
		if (!a && !(a = soap_new_std__listTemplateOfns__MediaMessage(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<ns__MediaMessage > * SOAP_FMAC2 soap_instantiate_std__listTemplateOfns__MediaMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOfns__MediaMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOfns__MediaMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<ns__MediaMessage >);
		if (size)
			*size = sizeof(std::list<ns__MediaMessage >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<ns__MediaMessage >, n);
		if (size)
			*size = n * sizeof(std::list<ns__MediaMessage >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<ns__MediaMessage >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOfns__MediaMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<ns__MediaMessage > %p -> %p\n", q, p));
	*(std::list<ns__MediaMessage >*)p = *(std::list<ns__MediaMessage >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__listTemplateOfns__Participant(struct soap *soap, std::list<ns__Participant >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__listTemplateOfns__Participant(struct soap *soap, const std::list<ns__Participant >*a)
{
#ifndef WITH_NOIDREF
	for (std::list<ns__Participant >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__listTemplateOfns__Participant(struct soap *soap, const char *tag, int id, const std::list<ns__Participant >*a, const char *type)
{
	for (std::list<ns__Participant >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::list<ns__Participant >* SOAP_FMAC4 soap_in_std__listTemplateOfns__Participant(struct soap *soap, const char *tag, std::list<ns__Participant >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns__Participant n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns__Participant, SOAP_TYPE_std__listTemplateOfns__Participant, sizeof(ns__Participant), 0))
				break;
			if (!soap_in_ns__Participant(soap, tag, NULL, "ns:Participant"))
				break;
		}
		else if (!soap_in_ns__Participant(soap, tag, &n, "ns:Participant"))
			break;
		if (!a && !(a = soap_new_std__listTemplateOfns__Participant(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::list<ns__Participant > * SOAP_FMAC2 soap_instantiate_std__listTemplateOfns__Participant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__listTemplateOfns__Participant(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__listTemplateOfns__Participant, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::list<ns__Participant >);
		if (size)
			*size = sizeof(std::list<ns__Participant >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::list<ns__Participant >, n);
		if (size)
			*size = n * sizeof(std::list<ns__Participant >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::list<ns__Participant >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__listTemplateOfns__Participant(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::list<ns__Participant > %p -> %p\n", q, p));
	*(std::list<ns__Participant >*)p = *(std::list<ns__Participant >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
